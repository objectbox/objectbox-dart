// ignore_for_file: non_constant_identifier_names, public_member_api_docs, prefer_expression_function_bodies, avoid_positional_boolean_parameters, constant_identifier_names, camel_case_types

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings to ObjectBox C-API
class ObjectBoxC {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ObjectBoxC(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ObjectBoxC.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Return the (runtime) version of the library as ints. Pointers may be null
  void version(
    ffi.Pointer<ffi.Int> major,
    ffi.Pointer<ffi.Int> minor,
    ffi.Pointer<ffi.Int> patch,
  ) {
    return _version(
      major,
      minor,
      patch,
    );
  }

  late final _versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('obx_version');
  late final _version = _versionPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Check if the (runtime) version of the library is equal to or higher than the given version ints.
  bool version_is_at_least(
    int major,
    int minor,
    int patch,
  ) {
    return _version_is_at_least(
      major,
      minor,
      patch,
    );
  }

  late final _version_is_at_leastPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'obx_version_is_at_least');
  late final _version_is_at_least =
      _version_is_at_leastPtr.asFunction<bool Function(int, int, int)>();

  /// Return the (runtime) version of the library to be printed.
  /// The current format is "major.minor.patch" (e.g. "1.0.0") but may change in any future release.
  /// Thus, only use for information purposes.
  /// @see obx_version() and obx_version_is_at_least() for integer based versions
  ffi.Pointer<ffi.Char> version_string() {
    return _version_string();
  }

  late final _version_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'obx_version_string');
  late final _version_string =
      _version_stringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the version of the ObjectBox core to be printed (currently also contains a version date and features).
  /// The format may change in any future release; only use for information purposes.
  ffi.Pointer<ffi.Char> version_core_string() {
    return _version_core_string();
  }

  late final _version_core_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'obx_version_core_string');
  late final _version_core_string =
      _version_core_stringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Checks whether the given feature is available in the currently loaded library.
  bool has_feature(
    int feature,
  ) {
    return _has_feature(
      feature,
    );
  }

  late final _has_featurePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'obx_has_feature');
  late final _has_feature = _has_featurePtr.asFunction<bool Function(int)>();

  /// Delete the store files from the given directory
  int remove_db_files(
    ffi.Pointer<ffi.Char> directory,
  ) {
    return _remove_db_files(
      directory,
    );
  }

  late final _remove_db_filesPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<ffi.Char>)>>(
          'obx_remove_db_files');
  late final _remove_db_files =
      _remove_db_filesPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @returns the file size of the main database file, or 0 if the file does not exist or some error occurred.
  int db_file_size(
    ffi.Pointer<ffi.Char> directory,
  ) {
    return _db_file_size(
      directory,
    );
  }

  late final _db_file_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Char>)>>(
          'obx_db_file_size');
  late final _db_file_size =
      _db_file_sizePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Enable (or disable) debug logging for ObjectBox internals.
  /// This requires a version of the library with the DebugLog feature.
  /// You can check if the feature is available with obx_has_feature(OBXFeature_DebugLog).
  int debug_log(
    bool enabled,
  ) {
    return _debug_log(
      enabled,
    );
  }

  late final _debug_logPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Bool)>>('obx_debug_log');
  late final _debug_log = _debug_logPtr.asFunction<int Function(bool)>();

  /// Checks if debug logs are enabled for ObjectBox internals. This depends on the availability of the DebugLog feature.
  /// If the feature is available, it returns the current state, which is adjustable via obx_debug_log().
  /// Otherwise, it always returns false for standard release builds (or true if you are having a special debug version).
  bool debug_log_enabled() {
    return _debug_log_enabled();
  }

  late final _debug_log_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('obx_debug_log_enabled');
  late final _debug_log_enabled =
      _debug_log_enabledPtr.asFunction<bool Function()>();

  /// Gets the number, as used by ObjectBox, of the current thread.
  /// This e.g. allows to "associate" the thread with ObjectBox logs (each log entry contains the thread number).
  int thread_number() {
    return _thread_number();
  }

  late final _thread_numberPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('obx_thread_number');
  late final _thread_number = _thread_numberPtr.asFunction<int Function()>();

  /// Return the error status on the current thread and clear the error state.
  /// The buffer returned in out_message is valid only until the next call into ObjectBox.
  /// @param out_error receives the error code; optional: may be NULL
  /// @param out_message receives the pointer to the error messages; optional: may be NULL
  /// @returns true if an error was pending
  bool last_error_pop(
    ffi.Pointer<obx_err> out_error,
    ffi.Pointer<ffi.Pointer<ffi.Char>> out_message,
  ) {
    return _last_error_pop(
      out_error,
      out_message,
    );
  }

  late final _last_error_popPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<obx_err>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('obx_last_error_pop');
  late final _last_error_pop = _last_error_popPtr.asFunction<
      bool Function(
          ffi.Pointer<obx_err>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// The last error raised by an ObjectBox API call on the current thread, or OBX_SUCCESS if no error occurred yet.
  /// Note that API calls do not clear this error code (also true for this method).
  /// Thus, if you receive an error from this, it's usually a good idea to call obx_last_error_clear() to clear the error
  /// state (or use obx_last_error_pop()) for future API calls.
  int last_error_code() {
    return _last_error_code();
  }

  late final _last_error_codePtr =
      _lookup<ffi.NativeFunction<obx_err Function()>>('obx_last_error_code');
  late final _last_error_code =
      _last_error_codePtr.asFunction<int Function()>();

  /// The error message string attached to the error returned by obx_last_error_code().
  /// Like obx_last_error_code(), this is bound to the current thread, and this call does not clear the error state.
  /// The buffer returned is valid only until the next call into ObjectBox.
  ffi.Pointer<ffi.Char> last_error_message() {
    return _last_error_message();
  }

  late final _last_error_messagePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'obx_last_error_message');
  late final _last_error_message =
      _last_error_messagePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// The underlying error for the error returned by obx_last_error_code(). Where obx_last_error_code() may be a generic
  /// error like OBX_ERROR_STORAGE_GENERAL, this will give a further underlying and possibly platform-specific error code.
  int last_error_secondary() {
    return _last_error_secondary();
  }

  late final _last_error_secondaryPtr =
      _lookup<ffi.NativeFunction<obx_err Function()>>(
          'obx_last_error_secondary');
  late final _last_error_secondary =
      _last_error_secondaryPtr.asFunction<int Function()>();

  /// Clear the error state on the current thread; e.g. obx_last_error_code() will now return OBX_SUCCESS.
  /// Note that clearing the error state does not happen automatically;
  /// API calls set the error state when they produce an error, but do not clear it on success.
  /// See also: obx_last_error_pop() to retrieve the error state and clear it.
  void last_error_clear() {
    return _last_error_clear();
  }

  late final _last_error_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('obx_last_error_clear');
  late final _last_error_clear =
      _last_error_clearPtr.asFunction<void Function()>();

  /// Set the last error code and test - reserved for internal use from generated code.
  bool last_error_set(
    int code,
    int secondary,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _last_error_set(
      code,
      secondary,
      message,
    );
  }

  late final _last_error_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              obx_err, obx_err, ffi.Pointer<ffi.Char>)>>('obx_last_error_set');
  late final _last_error_set = _last_error_setPtr
      .asFunction<bool Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Utility function to calculate the distance of two given vectors.
  /// Note: the memory of the two vectors may not overlap!
  /// @param type The distance type that is to be used for the calculation.
  /// @param dimension The dimension of the vectors (number of elements).
  /// @returns A distance measure that is dependent on the distance type.
  /// @returns NaN on error; e.g. if the distance type is unknown, or the vector search feature is unavailable.
  double vector_distance_float32(
    int type,
    ffi.Pointer<ffi.Float> vector1,
    ffi.Pointer<ffi.Float> vector2,
    int dimension,
  ) {
    return _vector_distance_float32(
      type,
      vector1,
      vector2,
      dimension,
    );
  }

  late final _vector_distance_float32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Size)>>('obx_vector_distance_float32');
  late final _vector_distance_float32 = _vector_distance_float32Ptr.asFunction<
      double Function(
          int, ffi.Pointer<ffi.Float>, ffi.Pointer<ffi.Float>, int)>();

  /// Utility function to convert a vector distance (e.g. scores from query results) to a relevance score.
  /// The relevance score is a value between 0.0 and 1.0, with 1.0 indicating the most relevant.
  /// Note: the higher a distance (score), the lower the relevance score.
  /// Note: while the distance (score) is potentially unbound (e.g. Euclidean and dot product) and dependent on the type,
  /// relevance score always has fixed range (0.0 to 1.0).
  /// @param type The distance type indicates how the given distance score was calculated.
  /// @param distance distance score to convert (0.0 is the nearest; upper bound depends on the distance type).
  /// @returns a relevance score between 0.0 and 1.0 (1.0 is the most relevant).
  /// @returns NaN on error; e.g. if the distance type is unknown, or the vector search feature is unavailable.
  double vector_distance_to_relevance(
    int type,
    double distance,
  ) {
    return _vector_distance_to_relevance(
      type,
      distance,
    );
  }

  late final _vector_distance_to_relevancePtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Int32, ffi.Float)>>(
          'obx_vector_distance_to_relevance');
  late final _vector_distance_to_relevance = _vector_distance_to_relevancePtr
      .asFunction<double Function(int, double)>();

  /// Create an (empty) data meta model which is to be consumed by obx_opt_model().
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details.
  /// Note that obx_model_* functions handle OBX_model NULL pointers (will indicate an error but not crash).
  ffi.Pointer<OBX_model> model() {
    return _model();
  }

  late final _modelPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OBX_model> Function()>>(
          'obx_model');
  late final _model = _modelPtr.asFunction<ffi.Pointer<OBX_model> Function()>();

  /// Only call when not calling obx_store_open() (which will free it internally)
  /// @param model NULL-able; returns OBX_SUCCESS if model is NULL
  int model_free(
    ffi.Pointer<OBX_model> model,
  ) {
    return _model_free(
      model,
    );
  }

  late final _model_freePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_model>)>>(
          'obx_model_free');
  late final _model_free =
      _model_freePtr.asFunction<int Function(ffi.Pointer<OBX_model>)>();

  /// To minimise the amount of error handling code required when building a model, the first error is stored and can be
  /// obtained here. All the obx_model_XXX functions are null operations after the first model error has occurred.
  /// @param model NULL-able; returns OBX_ERROR_ILLEGAL_ARGUMENT if model is NULL
  int model_error_code(
    ffi.Pointer<OBX_model> model,
  ) {
    return _model_error_code(
      model,
    );
  }

  late final _model_error_codePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_model>)>>(
          'obx_model_error_code');
  late final _model_error_code =
      _model_error_codePtr.asFunction<int Function(ffi.Pointer<OBX_model>)>();

  /// To minimise the amount of error handling code required when building a model, the first error is stored and can be
  /// obtained here. All the obx_model_XXX functions are null operations after the first model error has occurred.
  /// @param model NULL-able; returns NULL if model is NULL
  ffi.Pointer<ffi.Char> model_error_message(
    ffi.Pointer<OBX_model> model,
  ) {
    return _model_error_message(
      model,
    );
  }

  late final _model_error_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<OBX_model>)>>('obx_model_error_message');
  late final _model_error_message = _model_error_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_model>)>();

  /// Starts the definition of a new entity type for the meta data model.
  /// After this, call obx_model_property() to add properties to the entity type.
  /// @param name A human readable name for the entity. Must be unique within the model
  /// @param entity_id Must be unique within this version of the model
  /// @param entity_uid Used to identify entities between versions of the model. Must be globally unique.
  int model_entity(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> name,
    int entity_id,
    int entity_uid,
  ) {
    return _model_entity(
      model,
      name,
      entity_id,
      entity_uid,
    );
  }

  late final _model_entityPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>,
              obx_schema_id, obx_uid)>>('obx_model_entity');
  late final _model_entity = _model_entityPtr.asFunction<
      int Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Refine the definition of the entity declared by the most recent obx_model_entity() call, specifying flags.
  /// @param flags See OBXEntityFlags for values (use bitwise OR to combine multiple flags)
  int model_entity_flags(
    ffi.Pointer<OBX_model> model,
    int flags,
  ) {
    return _model_entity_flags(
      model,
      flags,
    );
  }

  late final _model_entity_flagsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_model>, ffi.Uint32)>>('obx_model_entity_flags');
  late final _model_entity_flags = _model_entity_flagsPtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Set the highest ever known property id in the entity. Should always be equal to or higher than the
  /// last property id of the previous version of the entity.
  int model_entity_last_property_id(
    ffi.Pointer<OBX_model> model,
    int property_id,
    int property_uid,
  ) {
    return _model_entity_last_property_id(
      model,
      property_id,
      property_uid,
    );
  }

  late final _model_entity_last_property_idPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>, obx_schema_id,
              obx_uid)>>('obx_model_entity_last_property_id');
  late final _model_entity_last_property_id = _model_entity_last_property_idPtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int, int)>();

  /// Refine the definition of the entity declared by the most recent obx_model_entity() call: set the external name.
  /// This is an optional name used in an external system, e.g. another database that ObjectBox syncs with.
  int model_entity_external_name(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> external_name,
  ) {
    return _model_entity_external_name(
      model,
      external_name,
    );
  }

  late final _model_entity_external_namePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>,
              ffi.Pointer<ffi.Char>)>>('obx_model_entity_external_name');
  late final _model_entity_external_name =
      _model_entity_external_namePtr.asFunction<
          int Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>)>();

  /// Starts the definition of a new property for the entity type of the last obx_model_entity() call.
  /// @param name A human readable name for the property. Must be unique within the entity
  /// @param type The type of property required
  /// @param property_id Must be unique within the entity
  /// @param property_uid Used to identify properties between versions of the entity. Must be global unique.
  int model_property(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> name,
    int type,
    int property_id,
    int property_uid,
  ) {
    return _model_property(
      model,
      name,
      type,
      property_id,
      property_uid,
    );
  }

  late final _model_propertyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>,
              ffi.Int32, obx_schema_id, obx_uid)>>('obx_model_property');
  late final _model_property = _model_propertyPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Refine the definition of the property declared by the most recent obx_model_property() call, specifying flags.
  /// @param flags See OBXPropertyFlags for values (use bitwise OR to combine multiple flags)
  int model_property_flags(
    ffi.Pointer<OBX_model> model,
    int flags,
  ) {
    return _model_property_flags(
      model,
      flags,
    );
  }

  late final _model_property_flagsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_model>, ffi.Uint32)>>('obx_model_property_flags');
  late final _model_property_flags = _model_property_flagsPtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Refine the definition of the property declared by the most recent obx_model_property() call, declaring it a
  /// relation.
  /// @param target_entity The name of the entity linked to by the relation
  /// @param index_id Must be unique within this version of the model
  /// @param index_uid Used to identify relations between versions of the model. Must be globally unique.
  int model_property_relation(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> target_entity,
    int index_id,
    int index_uid,
  ) {
    return _model_property_relation(
      model,
      target_entity,
      index_id,
      index_uid,
    );
  }

  late final _model_property_relationPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>,
              obx_schema_id, obx_uid)>>('obx_model_property_relation');
  late final _model_property_relation = _model_property_relationPtr.asFunction<
      int Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Refine the definition of the property declared by the most recent obx_model_property() call, adding an index.
  /// @param index_id Must be unique within this version of the model
  /// @param index_uid Used to identify relations between versions of the model. Must be globally unique.
  int model_property_index_id(
    ffi.Pointer<OBX_model> model,
    int index_id,
    int index_uid,
  ) {
    return _model_property_index_id(
      model,
      index_id,
      index_uid,
    );
  }

  late final _model_property_index_idPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>, obx_schema_id,
              obx_uid)>>('obx_model_property_index_id');
  late final _model_property_index_id = _model_property_index_idPtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int, int)>();

  /// Refine the definition of the property declared by the most recent obx_model_property() call: set the external name.
  /// This is an optional name used in an external system, e.g. another database that ObjectBox syncs with.
  /// @param external_name The name of the property in the external system.
  int model_property_external_name(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> external_name,
  ) {
    return _model_property_external_name(
      model,
      external_name,
    );
  }

  late final _model_property_external_namePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>,
              ffi.Pointer<ffi.Char>)>>('obx_model_property_external_name');
  late final _model_property_external_name =
      _model_property_external_namePtr.asFunction<
          int Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>)>();

  /// Refine the definition of the property declared by the most recent obx_model_property() call: set the external type.
  /// This is an optional type used in an external system, e.g. another database that ObjectBox syncs with.
  /// Note that the supported mappings from ObjectBox types to external types are limited.
  /// @param external_type The type of the property in the external system.
  int model_property_external_type(
    ffi.Pointer<OBX_model> model,
    int external_type,
  ) {
    return _model_property_external_type(
      model,
      external_type,
    );
  }

  late final _model_property_external_typePtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_model>, ffi.Int32)>>(
      'obx_model_property_external_type');
  late final _model_property_external_type = _model_property_external_typePtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Sets the vector dimensionality for the HNSW index of the latest property (must be of a supported vector type).
  /// This a mandatory option for all HNSW indexes.
  /// Note 1: vectors with higher dimensions than this value are also indexed (ignoring the higher elements).
  /// Note 2: vectors with lower dimensions than this value are completely ignored for indexing.
  int model_property_index_hnsw_dimensions(
    ffi.Pointer<OBX_model> model,
    int value,
  ) {
    return _model_property_index_hnsw_dimensions(
      model,
      value,
    );
  }

  late final _model_property_index_hnsw_dimensionsPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_model>, ffi.Size)>>(
      'obx_model_property_index_hnsw_dimensions');
  late final _model_property_index_hnsw_dimensions =
      _model_property_index_hnsw_dimensionsPtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Sets the max number of neighbors per node (aka "M") for the HNSW index of the latest property.
  /// Higher number increases the graph connectivity which can lead to better results, but higher resources usage.
  /// If no value is set, a default value taken (currently 30).
  /// Try e.g. 16 for faster but less accurate results, or 64 for more accurate results.
  int model_property_index_hnsw_neighbors_per_node(
    ffi.Pointer<OBX_model> model,
    int value,
  ) {
    return _model_property_index_hnsw_neighbors_per_node(
      model,
      value,
    );
  }

  late final _model_property_index_hnsw_neighbors_per_nodePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>,
              ffi.Uint32)>>('obx_model_property_index_hnsw_neighbors_per_node');
  late final _model_property_index_hnsw_neighbors_per_node =
      _model_property_index_hnsw_neighbors_per_nodePtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Sets the max number of neighbors searched while indexing (aka "efConstruction") for the HNSW index of the latest
  /// property.
  /// If no value is set, a default value taken (currently 100, which can change in future version).
  /// The default value serves as a starting point that can likely be optimized for specific datasets and use cases.
  /// The higher the value, the more accurate the search, but the longer the indexing will take.
  /// If indexing time is not a major concern, a value of at least 200 is recommended to improve search quality.
  int model_property_index_hnsw_indexing_search_count(
    ffi.Pointer<OBX_model> model,
    int value,
  ) {
    return _model_property_index_hnsw_indexing_search_count(
      model,
      value,
    );
  }

  late final _model_property_index_hnsw_indexing_search_countPtr = _lookup<
          ffi.NativeFunction<
              obx_err Function(ffi.Pointer<OBX_model>, ffi.Uint32)>>(
      'obx_model_property_index_hnsw_indexing_search_count');
  late final _model_property_index_hnsw_indexing_search_count =
      _model_property_index_hnsw_indexing_search_countPtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Sets flags for the HNSW index of the latest property.
  /// For details see OBXHnswFlags and its individual values.
  /// @param flags See OBXHnswFlags for values (use bitwise OR to combine multiple flags)
  int model_property_index_hnsw_flags(
    ffi.Pointer<OBX_model> model,
    int flags,
  ) {
    return _model_property_index_hnsw_flags(
      model,
      flags,
    );
  }

  late final _model_property_index_hnsw_flagsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>,
              ffi.Uint32)>>('obx_model_property_index_hnsw_flags');
  late final _model_property_index_hnsw_flags =
      _model_property_index_hnsw_flagsPtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Sets the distance type for the HNSW index of the latest property.
  int model_property_index_hnsw_distance_type(
    ffi.Pointer<OBX_model> model,
    int value,
  ) {
    return _model_property_index_hnsw_distance_type(
      model,
      value,
    );
  }

  late final _model_property_index_hnsw_distance_typePtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_model>, ffi.Int32)>>(
      'obx_model_property_index_hnsw_distance_type');
  late final _model_property_index_hnsw_distance_type =
      _model_property_index_hnsw_distance_typePtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Sets the reparation backlink probability, for the HNSW index of the latest property.
  /// When repairing the graph after a node was removed, this gives the probability of adding backlinks to the repaired
  /// neighbors. The default is 1.0 (aka "always") as this should be worth a bit of extra costs as it improves the graph's
  /// quality.
  int model_property_index_hnsw_reparation_backlink_probability(
    ffi.Pointer<OBX_model> model,
    double value,
  ) {
    return _model_property_index_hnsw_reparation_backlink_probability(
      model,
      value,
    );
  }

  late final _model_property_index_hnsw_reparation_backlink_probabilityPtr =
      _lookup<
              ffi.NativeFunction<
                  obx_err Function(ffi.Pointer<OBX_model>, ffi.Float)>>(
          'obx_model_property_index_hnsw_reparation_backlink_probability');
  late final _model_property_index_hnsw_reparation_backlink_probability =
      _model_property_index_hnsw_reparation_backlink_probabilityPtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, double)>();

  /// Sets the vector cache hint size for the HNSW index of the latest property.
  /// This is a non-binding hint of the maximum size of the vector cache in KB (default: 2097152 or 2 GB/GiB).
  int model_property_index_hnsw_vector_cache_hint_size_kb(
    ffi.Pointer<OBX_model> model,
    int value,
  ) {
    return _model_property_index_hnsw_vector_cache_hint_size_kb(
      model,
      value,
    );
  }

  late final _model_property_index_hnsw_vector_cache_hint_size_kbPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_model>, ffi.Size)>>(
      'obx_model_property_index_hnsw_vector_cache_hint_size_kb');
  late final _model_property_index_hnsw_vector_cache_hint_size_kb =
      _model_property_index_hnsw_vector_cache_hint_size_kbPtr
          .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Add a standalone relation between the active entity and the target entity to the model
  /// @param relation_id Must be unique within this version of the model
  /// @param relation_uid Used to identify relations between versions of the model. Must be globally unique.
  /// @param target_id The id of the target entity of the relation
  /// @param target_uid The uid of the target entity of the relation
  int model_relation(
    ffi.Pointer<OBX_model> model,
    int relation_id,
    int relation_uid,
    int target_id,
    int target_uid,
  ) {
    return _model_relation(
      model,
      relation_id,
      relation_uid,
      target_id,
      target_uid,
    );
  }

  late final _model_relationPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>, obx_schema_id, obx_uid,
              obx_schema_id, obx_uid)>>('obx_model_relation');
  late final _model_relation = _model_relationPtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int, int, int, int)>();

  /// Augments the previously defined relation with a name
  int model_relation_name(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _model_relation_name(
      model,
      name,
    );
  }

  late final _model_relation_namePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>,
              ffi.Pointer<ffi.Char>)>>('obx_model_relation_name');
  late final _model_relation_name = _model_relation_namePtr.asFunction<
      int Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>)>();

  /// Augments the previously defined relation with an external name (used outside of ObjectBox)
  int model_relation_external_name(
    ffi.Pointer<OBX_model> model,
    ffi.Pointer<ffi.Char> external_name,
  ) {
    return _model_relation_external_name(
      model,
      external_name,
    );
  }

  late final _model_relation_external_namePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_model>,
              ffi.Pointer<ffi.Char>)>>('obx_model_relation_external_name');
  late final _model_relation_external_name =
      _model_relation_external_namePtr.asFunction<
          int Function(ffi.Pointer<OBX_model>, ffi.Pointer<ffi.Char>)>();

  /// Augments the previously defined relation with an external type (used outside of ObjectBox)
  int model_relation_external_type(
    ffi.Pointer<OBX_model> model,
    int external_type,
  ) {
    return _model_relation_external_type(
      model,
      external_type,
    );
  }

  late final _model_relation_external_typePtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_model>, ffi.Int32)>>(
      'obx_model_relation_external_type');
  late final _model_relation_external_type = _model_relation_external_typePtr
      .asFunction<int Function(ffi.Pointer<OBX_model>, int)>();

  /// Set the highest ever known entity id in the model. Should always be equal to or higher than the
  /// last entity id of the previous version of the model
  void model_last_entity_id(
    ffi.Pointer<OBX_model> arg0,
    int entity_id,
    int entity_uid,
  ) {
    return _model_last_entity_id(
      arg0,
      entity_id,
      entity_uid,
    );
  }

  late final _model_last_entity_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_model>, obx_schema_id,
              obx_uid)>>('obx_model_last_entity_id');
  late final _model_last_entity_id = _model_last_entity_idPtr
      .asFunction<void Function(ffi.Pointer<OBX_model>, int, int)>();

  /// Set the highest ever known index id in the model. Should always be equal to or higher than the
  /// last index id of the previous version of the model
  void model_last_index_id(
    ffi.Pointer<OBX_model> model,
    int index_id,
    int index_uid,
  ) {
    return _model_last_index_id(
      model,
      index_id,
      index_uid,
    );
  }

  late final _model_last_index_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_model>, obx_schema_id,
              obx_uid)>>('obx_model_last_index_id');
  late final _model_last_index_id = _model_last_index_idPtr
      .asFunction<void Function(ffi.Pointer<OBX_model>, int, int)>();

  /// Set the highest every known relation id in the model. Should always be equal to or higher than the
  /// last relation id of the previous version of the model.
  void model_last_relation_id(
    ffi.Pointer<OBX_model> model,
    int relation_id,
    int relation_uid,
  ) {
    return _model_last_relation_id(
      model,
      relation_id,
      relation_uid,
    );
  }

  late final _model_last_relation_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_model>, obx_schema_id,
              obx_uid)>>('obx_model_last_relation_id');
  late final _model_last_relation_id = _model_last_relation_idPtr
      .asFunction<void Function(ffi.Pointer<OBX_model>, int, int)>();

  /// Get the actual bytes from the given OBX_bytes_lazy.
  /// Because of the potential lazy creation of bytes, the given bytes are not const as it may be resolved internally.
  /// For the same reason, this function is not thread-safe, at least for the first call on a OBX_bytes_lazy instance.
  /// @param out_bytes The pointer to a data pointer may be null, e.g. if you are only interested in the size.
  int bytes_lazy_get(
    ffi.Pointer<OBX_bytes_lazy> bytes,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_bytes,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _bytes_lazy_get(
      bytes,
      out_bytes,
      out_size,
    );
  }

  late final _bytes_lazy_getPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_bytes_lazy>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_bytes_lazy_get');
  late final _bytes_lazy_get = _bytes_lazy_getPtr.asFunction<
      int Function(ffi.Pointer<OBX_bytes_lazy>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Size>)>();

  /// Releases any resources associated with the given OBX_bytes_lazy.
  void bytes_lazy_free(
    ffi.Pointer<OBX_bytes_lazy> bytes,
  ) {
    return _bytes_lazy_free(
      bytes,
    );
  }

  late final _bytes_lazy_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_bytes_lazy>)>>(
      'obx_bytes_lazy_free');
  late final _bytes_lazy_free = _bytes_lazy_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_bytes_lazy>)>();

  /// Create a default set of store options.
  /// @returns NULL on failure, a default set of options on success
  ffi.Pointer<OBX_store_options> opt() {
    return _opt();
  }

  late final _optPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OBX_store_options> Function()>>(
          'obx_opt');
  late final _opt =
      _optPtr.asFunction<ffi.Pointer<OBX_store_options> Function()>();

  /// Set the store directory on the options. The default is "objectbox".
  /// Use prefix "memory:" to open an in-memory database, e.g. "memory:myApp" (see docs for details).
  int opt_directory(
    ffi.Pointer<OBX_store_options> opt,
    ffi.Pointer<ffi.Char> dir,
  ) {
    return _opt_directory(
      opt,
      dir,
    );
  }

  late final _opt_directoryPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_store_options>,
              ffi.Pointer<ffi.Char>)>>('obx_opt_directory');
  late final _opt_directory = _opt_directoryPtr.asFunction<
      int Function(ffi.Pointer<OBX_store_options>, ffi.Pointer<ffi.Char>)>();

  /// Set the maximum db size on the options. The default is 1Gb.
  void opt_max_db_size_in_kb(
    ffi.Pointer<OBX_store_options> opt,
    int size_in_kb,
  ) {
    return _opt_max_db_size_in_kb(
      opt,
      size_in_kb,
    );
  }

  late final _opt_max_db_size_in_kbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint64)>>('obx_opt_max_db_size_in_kb');
  late final _opt_max_db_size_in_kb = _opt_max_db_size_in_kbPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Data size tracking is more involved than DB size tracking, e.g. it stores an internal counter.
  /// Thus only use it if a stricter, more accurate limit is required (it's off by default).
  /// It tracks the size of actual data bytes of objects (system and metadata is not considered).
  /// On the upside, reaching the data limit still allows data to be removed (assuming DB limit is not reached).
  /// Max data and DB sizes can be combined; data size must be below the DB size.
  void opt_max_data_size_in_kb(
    ffi.Pointer<OBX_store_options> opt,
    int size_in_kb,
  ) {
    return _opt_max_data_size_in_kb(
      opt,
      size_in_kb,
    );
  }

  late final _opt_max_data_size_in_kbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint64)>>('obx_opt_max_data_size_in_kb');
  late final _opt_max_data_size_in_kb = _opt_max_data_size_in_kbPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Set the file mode on the options. The default is 0644 (unix-style).
  void opt_file_mode(
    ffi.Pointer<OBX_store_options> opt,
    int file_mode,
  ) {
    return _opt_file_mode(
      opt,
      file_mode,
    );
  }

  late final _opt_file_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.UnsignedInt)>>('obx_opt_file_mode');
  late final _opt_file_mode = _opt_file_modePtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Set the maximum number of readers (related to read transactions) on the given options.
  /// "Readers" are an finite resource for which we need to define a maximum number upfront.
  /// The default value is enough for most apps and usually you can ignore it completely.
  /// However, if you get the OBX_ERROR_MAX_READERS_EXCEEDED error, you should verify your threading.
  /// For each thread, ObjectBox uses multiple readers.
  /// Their number (per thread) depends on number of types, relations, and usage patterns.
  /// Thus, if you are working with many threads (e.g. in a server-like scenario), it can make sense to increase the
  /// maximum number of readers.
  ///
  /// \note The internal default is currently 126. So when hitting this limit, try values around 200-500.
  ///
  /// \attention Each thread that performed a read transaction and is still alive holds on to a reader slot.
  /// These slots only get vacated when the thread ends. Thus be mindful with the number of active threads.
  /// Alternatively, you can opt to try the experimental noReaderThreadLocals option flag.
  void opt_max_readers(
    ffi.Pointer<OBX_store_options> opt,
    int max_readers,
  ) {
    return _opt_max_readers(
      opt,
      max_readers,
    );
  }

  late final _opt_max_readersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.UnsignedInt)>>('obx_opt_max_readers');
  late final _opt_max_readers = _opt_max_readersPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Disables the usage of thread locals for "readers" related to read transactions.
  /// This can make sense if you are using a lot of threads that are kept alive.
  /// \note This is still experimental, as it comes with subtle behavior changes at a low level and may affect
  /// corner cases with e.g. transactions, which may not be fully tested at the moment.
  void opt_no_reader_thread_locals(
    ffi.Pointer<OBX_store_options> opt,
    bool flag,
  ) {
    return _opt_no_reader_thread_locals(
      opt,
      flag,
    );
  }

  late final _opt_no_reader_thread_localsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Bool)>>('obx_opt_no_reader_thread_locals');
  late final _opt_no_reader_thread_locals = _opt_no_reader_thread_localsPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, bool)>();

  /// Set the model on the options. The default is no model.
  /// NOTE: the model is always freed by this function, including when an error occurs.
  int opt_model(
    ffi.Pointer<OBX_store_options> opt,
    ffi.Pointer<OBX_model> model,
  ) {
    return _opt_model(
      opt,
      model,
    );
  }

  late final _opt_modelPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_store_options>,
              ffi.Pointer<OBX_model>)>>('obx_opt_model');
  late final _opt_model = _opt_modelPtr.asFunction<
      int Function(ffi.Pointer<OBX_store_options>, ffi.Pointer<OBX_model>)>();

  /// Set the model on the options copying the given bytes. The default is no model.
  int opt_model_bytes(
    ffi.Pointer<OBX_store_options> opt,
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _opt_model_bytes(
      opt,
      bytes,
      size,
    );
  }

  late final _opt_model_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_store_options>,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_opt_model_bytes');
  late final _opt_model_bytes = _opt_model_bytesPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_store_options>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Like obx_opt_model_bytes BUT WITHOUT copying the given bytes.
  /// Thus, you must keep the bytes available until after the store is created.
  int opt_model_bytes_direct(
    ffi.Pointer<OBX_store_options> opt,
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _opt_model_bytes_direct(
      opt,
      bytes,
      size,
    );
  }

  late final _opt_model_bytes_directPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_store_options>,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_opt_model_bytes_direct');
  late final _opt_model_bytes_direct = _opt_model_bytes_directPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_store_options>, ffi.Pointer<ffi.Uint8>, int)>();

  /// When the DB is opened initially, ObjectBox can do a consistency check on the given amount of pages.
  /// Reliable file systems already guarantee consistency, so this is primarily meant to deal with unreliable
  /// OSes, file systems, or hardware. Thus, usually a low number (e.g. 1-20) is sufficient and does not impact
  /// startup performance significantly. To completely disable this you can pass 0, but we recommend a setting of
  /// at least 1.
  /// Note: ObjectBox builds upon ACID storage, which guarantees consistency given that the file system is working
  /// correctly (in particular fsync).
  /// @param page_limit limits the number of checked pages (currently defaults to 0, but will be increased in the future)
  /// @param flags flags used to influence how the validation checks are performed;
  /// see OBXValidateOnOpenPagesFlags for values (use bitwise OR to combine multiple flags)
  void opt_validate_on_open_pages(
    ffi.Pointer<OBX_store_options> opt,
    int page_limit,
    int flags,
  ) {
    return _opt_validate_on_open_pages(
      opt,
      page_limit,
      flags,
    );
  }

  late final _opt_validate_on_open_pagesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>, ffi.Size,
              ffi.Uint32)>>('obx_opt_validate_on_open_pages');
  late final _opt_validate_on_open_pages = _opt_validate_on_open_pagesPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int, int)>();

  /// When the DB is opened initially, ObjectBox can do a validation over the key/value pairs to check, for example,
  /// whether they're consistent towards our internal specification.
  /// @param flags flags used to influence how the validation checks are performed;
  /// see OBXValidateOnOpenKvFlags for values (use bitwise OR to combine multiple flags)
  void opt_validate_on_open_kv(
    ffi.Pointer<OBX_store_options> opt,
    int flags,
  ) {
    return _opt_validate_on_open_kv(
      opt,
      flags,
    );
  }

  late final _opt_validate_on_open_kvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_validate_on_open_kv');
  late final _opt_validate_on_open_kv = _opt_validate_on_open_kvPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Don't touch unless you know exactly what you are doing:
  /// Advanced setting typically meant for language bindings (not end users). See OBXPutPaddingMode description.
  void opt_put_padding_mode(
    ffi.Pointer<OBX_store_options> opt,
    int mode,
  ) {
    return _opt_put_padding_mode(
      opt,
      mode,
    );
  }

  late final _opt_put_padding_modePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Int32)>>('obx_opt_put_padding_mode');
  late final _opt_put_padding_mode = _opt_put_padding_modePtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Advanced setting meant only for special scenarios: setting to false causes opening the database in a limited,
  /// schema-less mode. If you don't know what this means exactly: ignore this flag. Defaults to true.
  void opt_read_schema(
    ffi.Pointer<OBX_store_options> opt,
    bool value,
  ) {
    return _opt_read_schema(
      opt,
      value,
    );
  }

  late final _opt_read_schemaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Bool)>>('obx_opt_read_schema');
  late final _opt_read_schema = _opt_read_schemaPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, bool)>();

  /// Advanced setting recommended to be used together with read-only mode to ensure no data is lost.
  /// Ignores the latest data snapshot (committed transaction state) and uses the previous snapshot instead.
  /// When used with care (e.g. backup the DB files first), this option may also recover data removed by the latest
  /// transaction. Defaults to false.
  void opt_use_previous_commit(
    ffi.Pointer<OBX_store_options> opt,
    bool value,
  ) {
    return _opt_use_previous_commit(
      opt,
      value,
    );
  }

  late final _opt_use_previous_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Bool)>>('obx_opt_use_previous_commit');
  late final _opt_use_previous_commit = _opt_use_previous_commitPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, bool)>();

  /// Open store in read-only mode: no schema update, no write transactions. Defaults to false.
  void opt_read_only(
    ffi.Pointer<OBX_store_options> opt,
    bool value,
  ) {
    return _opt_read_only(
      opt,
      value,
    );
  }

  late final _opt_read_onlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_store_options>, ffi.Bool)>>('obx_opt_read_only');
  late final _opt_read_only = _opt_read_onlyPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, bool)>();

  /// Configure debug flags (OBXDebugFlags); e.g. to influence logging. Defaults to NONE.
  /// Combine multiple flags using bitwise OR.
  void opt_debug_flags(
    ffi.Pointer<OBX_store_options> opt,
    int flags,
  ) {
    return _opt_debug_flags(
      opt,
      flags,
    );
  }

  late final _opt_debug_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_debug_flags');
  late final _opt_debug_flags = _opt_debug_flagsPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Adds debug flags (OBXDebugFlags) to potentially existing ones.
  /// Combine multiple flags using bitwise OR.
  void opt_add_debug_flags(
    ffi.Pointer<OBX_store_options> opt,
    int flags,
  ) {
    return _opt_add_debug_flags(
      opt,
      flags,
    );
  }

  late final _opt_add_debug_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_add_debug_flags');
  late final _opt_add_debug_flags = _opt_add_debug_flagsPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Maximum of async elements in the queue before new elements will be rejected.
  /// Hitting this limit usually hints that async processing cannot keep up;
  /// data is produced at a faster rate than it can be persisted in the background.
  /// In that case, increasing this value is not the only alternative; other values might also optimize throughput.
  /// For example, increasing maxInTxDurationMicros may help too.
  void opt_async_max_queue_length(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_max_queue_length(
      opt,
      value,
    );
  }

  late final _opt_async_max_queue_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Size)>>('obx_opt_async_max_queue_length');
  late final _opt_async_max_queue_length = _opt_async_max_queue_lengthPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Producers (AsyncTx submitter) is throttled when the queue size hits this
  void opt_async_throttle_at_queue_length(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_throttle_at_queue_length(
      opt,
      value,
    );
  }

  late final _opt_async_throttle_at_queue_lengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Size)>>('obx_opt_async_throttle_at_queue_length');
  late final _opt_async_throttle_at_queue_length =
      _opt_async_throttle_at_queue_lengthPtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Sleeping time for throttled producers on each submission
  void opt_async_throttle_micros(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_throttle_micros(
      opt,
      value,
    );
  }

  late final _opt_async_throttle_microsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_async_throttle_micros');
  late final _opt_async_throttle_micros = _opt_async_throttle_microsPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Maximum duration spent in a transaction before AsyncQ enforces a commit.
  /// This becomes relevant if the queue is constantly populated at a high rate.
  void opt_async_max_in_tx_duration(
    ffi.Pointer<OBX_store_options> opt,
    int micros,
  ) {
    return _opt_async_max_in_tx_duration(
      opt,
      micros,
    );
  }

  late final _opt_async_max_in_tx_durationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_async_max_in_tx_duration');
  late final _opt_async_max_in_tx_duration = _opt_async_max_in_tx_durationPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Maximum operations performed in a transaction before AsyncQ enforces a commit.
  /// This becomes relevant if the queue is constantly populated at a high rate.
  void opt_async_max_in_tx_operations(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_max_in_tx_operations(
      opt,
      value,
    );
  }

  late final _opt_async_max_in_tx_operationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_async_max_in_tx_operations');
  late final _opt_async_max_in_tx_operations =
      _opt_async_max_in_tx_operationsPtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Before the AsyncQ is triggered by a new element in queue to starts a new run, it delays actually starting the
  /// transaction by this value.
  /// This gives a newly starting producer some time to produce more than one a single operation before AsyncQ starts.
  /// Note: this value should typically be low to keep latency low and prevent accumulating too much operations.
  void opt_async_pre_txn_delay(
    ffi.Pointer<OBX_store_options> opt,
    int delay_micros,
  ) {
    return _opt_async_pre_txn_delay(
      opt,
      delay_micros,
    );
  }

  late final _opt_async_pre_txn_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_async_pre_txn_delay');
  late final _opt_async_pre_txn_delay = _opt_async_pre_txn_delayPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Before the AsyncQ is triggered by a new element in queue to starts a new run, it delays actually starting the
  /// transaction by this value.
  /// This gives a newly starting producer some time to produce more than one a single operation before AsyncQ starts.
  /// Note: this value should typically be low to keep latency low and prevent accumulating too much operations.
  void opt_async_pre_txn_delay4(
    ffi.Pointer<OBX_store_options> opt,
    int delay_micros,
    int delay2_micros,
    int min_queue_length_for_delay2,
  ) {
    return _opt_async_pre_txn_delay4(
      opt,
      delay_micros,
      delay2_micros,
      min_queue_length_for_delay2,
    );
  }

  late final _opt_async_pre_txn_delay4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>, ffi.Uint32,
              ffi.Uint32, ffi.Size)>>('obx_opt_async_pre_txn_delay4');
  late final _opt_async_pre_txn_delay4 =
      _opt_async_pre_txn_delay4Ptr.asFunction<
          void Function(ffi.Pointer<OBX_store_options>, int, int, int)>();

  /// Similar to preTxDelay but after a transaction was committed.
  /// One of the purposes is to give other transactions some time to execute.
  /// In combination with preTxDelay this can prolong non-TX batching time if only a few operations are around.
  void opt_async_post_txn_delay(
    ffi.Pointer<OBX_store_options> opt,
    int delay_micros,
  ) {
    return _opt_async_post_txn_delay(
      opt,
      delay_micros,
    );
  }

  late final _opt_async_post_txn_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_async_post_txn_delay');
  late final _opt_async_post_txn_delay = _opt_async_post_txn_delayPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Similar to preTxDelay but after a transaction was committed.
  /// One of the purposes is to give other transactions some time to execute.
  /// In combination with preTxDelay this can prolong non-TX batching time if only a few operations are around.
  /// @param subtract_processing_time If set, delay_micros is interpreted from the start of TX processing.
  /// In other words, the actual delay is delay_micros minus the TX processing time including the commit.
  /// This can make timings more accurate (e.g. when fixed batching interval are given).
  void opt_async_post_txn_delay5(
    ffi.Pointer<OBX_store_options> opt,
    int delay_micros,
    int delay2_micros,
    int min_queue_length_for_delay2,
    bool subtract_processing_time,
  ) {
    return _opt_async_post_txn_delay5(
      opt,
      delay_micros,
      delay2_micros,
      min_queue_length_for_delay2,
      subtract_processing_time,
    );
  }

  late final _opt_async_post_txn_delay5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_store_options>,
              ffi.Uint32,
              ffi.Uint32,
              ffi.Size,
              ffi.Bool)>>('obx_opt_async_post_txn_delay5');
  late final _opt_async_post_txn_delay5 =
      _opt_async_post_txn_delay5Ptr.asFunction<
          void Function(ffi.Pointer<OBX_store_options>, int, int, int, bool)>();

  /// Numbers of operations below this value are considered "minor refills"
  void opt_async_minor_refill_threshold(
    ffi.Pointer<OBX_store_options> opt,
    int queue_length,
  ) {
    return _opt_async_minor_refill_threshold(
      opt,
      queue_length,
    );
  }

  late final _opt_async_minor_refill_thresholdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Size)>>('obx_opt_async_minor_refill_threshold');
  late final _opt_async_minor_refill_threshold =
      _opt_async_minor_refill_thresholdPtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// If non-zero, this allows "minor refills" with small batches that came in (off by default).
  void opt_async_minor_refill_max_count(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_minor_refill_max_count(
      opt,
      value,
    );
  }

  late final _opt_async_minor_refill_max_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint32)>>('obx_opt_async_minor_refill_max_count');
  late final _opt_async_minor_refill_max_count =
      _opt_async_minor_refill_max_countPtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Default value: 10000, set to 0 to deactivate pooling
  void opt_async_max_tx_pool_size(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_max_tx_pool_size(
      opt,
      value,
    );
  }

  late final _opt_async_max_tx_pool_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Size)>>('obx_opt_async_max_tx_pool_size');
  late final _opt_async_max_tx_pool_size = _opt_async_max_tx_pool_sizePtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Total cache size; default: ~ 0.5 MB
  void opt_async_object_bytes_max_cache_size(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_object_bytes_max_cache_size(
      opt,
      value,
    );
  }

  late final _opt_async_object_bytes_max_cache_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint64)>>('obx_opt_async_object_bytes_max_cache_size');
  late final _opt_async_object_bytes_max_cache_size =
      _opt_async_object_bytes_max_cache_sizePtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Maximal size for an object to be cached (only cache smaller ones)
  void opt_async_object_bytes_max_size_to_cache(
    ffi.Pointer<OBX_store_options> opt,
    int value,
  ) {
    return _opt_async_object_bytes_max_size_to_cache(
      opt,
      value,
    );
  }

  late final _opt_async_object_bytes_max_size_to_cachePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint64)>>('obx_opt_async_object_bytes_max_size_to_cache');
  late final _opt_async_object_bytes_max_size_to_cache =
      _opt_async_object_bytes_max_size_to_cachePtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Registers a log callback, which is called for a selection of log events.
  /// Note: this does not replace the default logging, which is much more extensive (at least at this point).
  void opt_log_callback(
    ffi.Pointer<OBX_store_options> opt,
    ffi.Pointer<obx_log_callback> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _opt_log_callback(
      opt,
      callback,
      user_data,
    );
  }

  late final _opt_log_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_store_options>,
              ffi.Pointer<obx_log_callback>,
              ffi.Pointer<ffi.Void>)>>('obx_opt_log_callback');
  late final _opt_log_callback = _opt_log_callbackPtr.asFunction<
      void Function(ffi.Pointer<OBX_store_options>,
          ffi.Pointer<obx_log_callback>, ffi.Pointer<ffi.Void>)>();

  /// Before opening the database, this options instructs to restore the database content from the given backup file.
  /// Note: backup is a server-only feature.
  /// By default, actually restoring the backup is only performed if no database already exists
  /// (database does not contain data).
  /// @param flags For default behavior pass 0, or adjust defaults using OBXBackupRestoreFlags bit flags,
  /// e.g., to overwrite all existing data in the database.
  void opt_backup_restore(
    ffi.Pointer<OBX_store_options> opt,
    ffi.Pointer<ffi.Char> backup_file,
    int flags,
  ) {
    return _opt_backup_restore(
      opt,
      backup_file,
      flags,
    );
  }

  late final _opt_backup_restorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('obx_opt_backup_restore');
  late final _opt_backup_restore = _opt_backup_restorePtr.asFunction<
      void Function(
          ffi.Pointer<OBX_store_options>, ffi.Pointer<ffi.Char>, int)>();

  /// Enables Write-ahead logging (WAL) if OBXWalFlags_EnableWal is given.
  /// For now this is only supported for in-memory DBs.
  /// @param flags OBXWalFlags_EnableWal with optional other flags (bitwise OR).
  void opt_wal(
    ffi.Pointer<OBX_store_options> opt,
    int flags,
  ) {
    return _opt_wal(
      opt,
      flags,
    );
  }

  late final _opt_walPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_store_options>, ffi.Uint32)>>('obx_opt_wal');
  late final _opt_wal = _opt_walPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// The WAL file gets consolidated when it reached this size limit when opening the database.
  /// This setting is meant for applications that prefer to consolidate on startup,
  /// which may avoid consolidations on commits while the application is running.
  /// The default is 4096 (4 MB).
  void opt_wal_max_file_size_on_open_in_kb(
    ffi.Pointer<OBX_store_options> opt,
    int size_in_kb,
  ) {
    return _opt_wal_max_file_size_on_open_in_kb(
      opt,
      size_in_kb,
    );
  }

  late final _opt_wal_max_file_size_on_open_in_kbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint64)>>('obx_opt_wal_max_file_size_on_open_in_kb');
  late final _opt_wal_max_file_size_on_open_in_kb =
      _opt_wal_max_file_size_on_open_in_kbPtr
          .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// The WAL file gets consolidated when it reaches this size limit after a commit.
  /// As consolidation takes some time, it is a trade-off between accumulating enough data
  /// and the time the consolidation takes (longer with more data).
  /// The default is 16384 (16 MB).
  void opt_wal_max_file_size_in_kb(
    ffi.Pointer<OBX_store_options> opt,
    int size_in_kb,
  ) {
    return _opt_wal_max_file_size_in_kb(
      opt,
      size_in_kb,
    );
  }

  late final _opt_wal_max_file_size_in_kbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>,
              ffi.Uint64)>>('obx_opt_wal_max_file_size_in_kb');
  late final _opt_wal_max_file_size_in_kb = _opt_wal_max_file_size_in_kbPtr
      .asFunction<void Function(ffi.Pointer<OBX_store_options>, int)>();

  /// Gets the option for "directory"; this is either the default, or, the value set by obx_opt_directory().
  /// The returned value must not be modified and is only valid for the lifetime of the options or until the value is
  /// changed.
  /// @returns null if an error occurred, e.g. the given options were null.
  ffi.Pointer<ffi.Char> opt_get_directory(
    ffi.Pointer<OBX_store_options> opt,
  ) {
    return _opt_get_directory(
      opt,
    );
  }

  late final _opt_get_directoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<OBX_store_options>)>>('obx_opt_get_directory');
  late final _opt_get_directory = _opt_get_directoryPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_store_options>)>();

  /// Gets the option for "max DB size"; this is either the default, or, the value set by obx_opt_max_db_size_in_kb().
  /// @returns 0 if an error occurred, e.g. the given options were null.
  int opt_get_max_db_size_in_kb(
    ffi.Pointer<OBX_store_options> opt,
  ) {
    return _opt_get_max_db_size_in_kb(
      opt,
    );
  }

  late final _opt_get_max_db_size_in_kbPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint64 Function(ffi.Pointer<OBX_store_options>)>>(
      'obx_opt_get_max_db_size_in_kb');
  late final _opt_get_max_db_size_in_kb = _opt_get_max_db_size_in_kbPtr
      .asFunction<int Function(ffi.Pointer<OBX_store_options>)>();

  /// Gets the option for "max data size"; this is either the default, or, the value set by obx_opt_max_data_size_in_kb().
  /// @returns 0 if an error occurred, e.g. the given options were null.
  int opt_get_max_data_size_in_kb(
    ffi.Pointer<OBX_store_options> opt,
  ) {
    return _opt_get_max_data_size_in_kb(
      opt,
    );
  }

  late final _opt_get_max_data_size_in_kbPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint64 Function(ffi.Pointer<OBX_store_options>)>>(
      'obx_opt_get_max_data_size_in_kb');
  late final _opt_get_max_data_size_in_kb = _opt_get_max_data_size_in_kbPtr
      .asFunction<int Function(ffi.Pointer<OBX_store_options>)>();

  /// Gets the option for "debug flags"; this is either the default, or, the value set by obx_opt_debug_flags().
  /// @returns 0 if an error occurred, e.g. the given options were null.
  int opt_get_debug_flags(
    ffi.Pointer<OBX_store_options> opt,
  ) {
    return _opt_get_debug_flags(
      opt,
    );
  }

  late final _opt_get_debug_flagsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<OBX_store_options>)>>(
      'obx_opt_get_debug_flags');
  late final _opt_get_debug_flags = _opt_get_debug_flagsPtr
      .asFunction<int Function(ffi.Pointer<OBX_store_options>)>();

  /// Free the options.
  /// Note: Only free *unused* options, obx_store_open() frees the options internally
  void opt_free(
    ffi.Pointer<OBX_store_options> opt,
  ) {
    return _opt_free(
      opt,
    );
  }

  late final _opt_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<OBX_store_options>)>>('obx_opt_free');
  late final _opt_free =
      _opt_freePtr.asFunction<void Function(ffi.Pointer<OBX_store_options>)>();

  /// Opens (creates) a "store", which represents an ObjectBox database instance in a given directory.
  /// The store is an entry point to data access APIs such as box (obx_box_*), query (obx_qb_* and obx_query_*),
  /// and transaction (obx_txn_*).
  /// It's possible to open multiple stores in different directories, e.g. at the same time.
  /// See also obx_store_close() to close a previously opened store.
  /// Note: the given options are always freed by this function, including when an error occurs.
  /// @param opt required parameter holding the data model (obx_opt_model()) and optional options (see obx_opt_*())
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_store> store_open(
    ffi.Pointer<OBX_store_options> opt,
  ) {
    return _store_open(
      opt,
    );
  }

  late final _store_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<OBX_store_options>)>>('obx_store_open');
  late final _store_open = _store_openPtr.asFunction<
      ffi.Pointer<OBX_store> Function(ffi.Pointer<OBX_store_options>)>();

  /// Check if an open store was found for the given path (i.e. opened before and not yet closed).
  bool store_is_open(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _store_is_open(
      path,
    );
  }

  late final _store_is_openPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'obx_store_is_open');
  late final _store_is_open =
      _store_is_openPtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  /// Attach to a previously opened store matching the path of the DB directory, which was used for opening the store.
  /// The returned store is a new instance (e.g. different pointer value) and must also be closed via obx_store_close().
  /// The actual underlying store is only closed when the last store OBX_store instance is closed.
  /// @returns nullptr if no open store was found (i.e. not opened before or already closed)
  /// @see obx_store_clone() for "attaching" to a available store instance.
  ffi.Pointer<OBX_store> store_attach(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _store_attach(
      path,
    );
  }

  late final _store_attachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<ffi.Char>)>>('obx_store_attach');
  late final _store_attach = _store_attachPtr
      .asFunction<ffi.Pointer<OBX_store> Function(ffi.Pointer<ffi.Char>)>();

  /// Attach to a previously opened store matching the given store ID.
  /// The returned store is a new instance (e.g. different pointer value) and must also be closed via obx_store_close().
  /// The actual underlying store is only closed when the last store OBX_store instance is closed.
  /// @param store_id The ID previously obtained from a store.
  /// @returns nullptr if no open store was found (i.e. not opened before or already closed)
  /// @see obx_store_clone() for "attaching" to a available store instance.
  ffi.Pointer<OBX_store> store_attach_id(
    int store_id,
  ) {
    return _store_attach_id(
      store_id,
    );
  }

  late final _store_attach_idPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OBX_store> Function(ffi.Uint64)>>(
          'obx_store_attach_id');
  late final _store_attach_id =
      _store_attach_idPtr.asFunction<ffi.Pointer<OBX_store> Function(int)>();

  /// Combines the functionality of obx_store_attach() and obx_store_open() in a thread-safe way.
  /// @param check_matching_options if true, some effort will be taken to check if the given options match an existing
  /// store. Usually this should be set to true as options should not diverge when opening/attaching.
  /// Note that additional checks will be added in the future.
  /// @param out_attached (optional) if given a pointer to a flag that telling if the function attached to an existing
  /// store (true) or a new store was created (false).
  ffi.Pointer<OBX_store> store_attach_or_open(
    ffi.Pointer<OBX_store_options> opt,
    bool check_matching_options,
    ffi.Pointer<ffi.Bool> out_attached,
  ) {
    return _store_attach_or_open(
      opt,
      check_matching_options,
      out_attached,
    );
  }

  late final _store_attach_or_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(ffi.Pointer<OBX_store_options>,
              ffi.Bool, ffi.Pointer<ffi.Bool>)>>('obx_store_attach_or_open');
  late final _store_attach_or_open = _store_attach_or_openPtr.asFunction<
      ffi.Pointer<OBX_store> Function(
          ffi.Pointer<OBX_store_options>, bool, ffi.Pointer<ffi.Bool>)>();

  /// Store IDs can be used to attach to a store later.
  /// The IDs are stable and unique during the lifetime of the process.
  /// E.g. these IDs can be shared across threads efficiently and can serve a similar purpose as weak pointers do.
  int store_id(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_id(
      store,
    );
  }

  late final _store_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_id');
  late final _store_id =
      _store_idPtr.asFunction<int Function(ffi.Pointer<OBX_store>)>();

  /// Get the size of the store. For a disk-based store type, this corresponds to the size on disk, and for the
  /// in-memory store type, this is roughly the used memory bytes occupied by the data.
  /// @returns the size in bytes of the database, or 0 if the file does not exist or some error occurred.
  int store_size(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_size(
      store,
    );
  }

  late final _store_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_size');
  late final _store_size =
      _store_sizePtr.asFunction<int Function(ffi.Pointer<OBX_store>)>();

  /// The size in bytes occupied by the database on disk (if any).
  /// @returns 0 if the underlying database is in-memory only, or the size could not be determined.
  int store_size_on_disk(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_size_on_disk(
      store,
    );
  }

  late final _store_size_on_diskPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_size_on_disk');
  late final _store_size_on_disk =
      _store_size_on_diskPtr.asFunction<int Function(ffi.Pointer<OBX_store>)>();

  /// Gives the store type ID for the given store
  /// @returns One of ::OBXStoreTypeId
  int store_type_id(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_type_id(
      store,
    );
  }

  late final _store_type_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_type_id');
  late final _store_type_id =
      _store_type_idPtr.asFunction<int Function(ffi.Pointer<OBX_store>)>();

  /// Clone a previously opened store; while a store instance is usable from multiple threads, situations may exist
  /// in which cloning a store simplifies the overall lifecycle.
  /// E.g. when a store is used for multiple threads and it may only be fully released once the last thread completes.
  /// The returned store is a new instance (e.g. different pointer value) and must also be closed via obx_store_close().
  /// The actual underlying store is only closed when the last store OBX_store instance is closed.
  /// @returns nullptr if the store could not be cloned
  /// @see obx_store_attach() for "cloning" using the store's path.
  ffi.Pointer<OBX_store> store_clone(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_clone(
      store,
    );
  }

  late final _store_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<OBX_store>)>>('obx_store_clone');
  late final _store_clone = _store_clonePtr
      .asFunction<ffi.Pointer<OBX_store> Function(ffi.Pointer<OBX_store>)>();

  /// For stores created outside of this C API, e.g. via C++ or Java, this is how you can use it via C too.
  /// Like this, it is OK to use the same store instance (same database) from multiple languages in parallel.
  /// Note: the store's life time will still be managed outside of the C API;
  /// thus ensure that store is not closed while calling any C function on it.
  /// Once you are done with the C specific OBX_store, call obx_store_close() to free any C related resources.
  /// This, however, will not close the "core store".
  /// @param core_store A pointer to the core C++ ObjectStore, or the native JNI handle for a BoxStore.
  ffi.Pointer<OBX_store> store_wrap(
    ffi.Pointer<ffi.Void> core_store,
  ) {
    return _store_wrap(
      core_store,
    );
  }

  late final _store_wrapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<ffi.Void>)>>('obx_store_wrap');
  late final _store_wrap = _store_wrapPtr
      .asFunction<ffi.Pointer<OBX_store> Function(ffi.Pointer<ffi.Void>)>();

  /// Look for an entity with the given name in the model and return its Entity ID.
  int store_entity_id(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<ffi.Char> entity_name,
  ) {
    return _store_entity_id(
      store,
      entity_name,
    );
  }

  late final _store_entity_idPtr = _lookup<
      ffi.NativeFunction<
          obx_schema_id Function(ffi.Pointer<OBX_store>,
              ffi.Pointer<ffi.Char>)>>('obx_store_entity_id');
  late final _store_entity_id = _store_entity_idPtr.asFunction<
      int Function(ffi.Pointer<OBX_store>, ffi.Pointer<ffi.Char>)>();

  /// Return the property id from the property name or 0 if the name is not found
  int store_entity_property_id(
    ffi.Pointer<OBX_store> store,
    int entity_id,
    ffi.Pointer<ffi.Char> property_name,
  ) {
    return _store_entity_property_id(
      store,
      entity_id,
      property_name,
    );
  }

  late final _store_entity_property_idPtr = _lookup<
      ffi.NativeFunction<
          obx_schema_id Function(ffi.Pointer<OBX_store>, obx_schema_id,
              ffi.Pointer<ffi.Char>)>>('obx_store_entity_property_id');
  late final _store_entity_property_id =
      _store_entity_property_idPtr.asFunction<
          int Function(ffi.Pointer<OBX_store>, int, ffi.Pointer<ffi.Char>)>();

  /// Await for all (including future) async submissions to be completed (the async queue becomes empty).
  /// @returns true if all submissions were completed or async processing was not started
  /// @returns false if shutting down or an error occurred
  bool store_await_async_completion(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_await_async_completion(
      store,
    );
  }

  late final _store_await_async_completionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_await_async_completion');
  late final _store_await_async_completion = _store_await_async_completionPtr
      .asFunction<bool Function(ffi.Pointer<OBX_store>)>();

  /// Await async operations that have been submitted up to this point to be completed
  /// (the async queue may still contain elements).
  /// @returns true if all submissions were completed (or async processing was not started)
  /// @returns false if shutting down or an error occurred
  bool store_await_async_submitted(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_await_async_submitted(
      store,
    );
  }

  late final _store_await_async_submittedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_await_async_submitted');
  late final _store_await_async_submitted = _store_await_async_submittedPtr
      .asFunction<bool Function(ffi.Pointer<OBX_store>)>();

  /// Backs up the store DB to the given backup-file, using the given flags.
  /// Note: backup is a server-only feature.
  /// @param backup_flags 0 for defaults or OBXBackupFlags bit flags
  int store_back_up_to_file(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<ffi.Char> backup_file,
    int backup_flags,
  ) {
    return _store_back_up_to_file(
      store,
      backup_file,
      backup_flags,
    );
  }

  late final _store_back_up_to_filePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_store>, ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('obx_store_back_up_to_file');
  late final _store_back_up_to_file = _store_back_up_to_filePtr.asFunction<
      int Function(ffi.Pointer<OBX_store>, ffi.Pointer<ffi.Char>, int)>();

  /// Configure debug logging
  /// @param flags See OBXDebugFlags for values (use bitwise OR to combine multiple flags)
  int store_debug_flags(
    ffi.Pointer<OBX_store> store,
    int flags,
  ) {
    return _store_debug_flags(
      store,
      flags,
    );
  }

  late final _store_debug_flagsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_store>, ffi.Uint32)>>('obx_store_debug_flags');
  late final _store_debug_flags = _store_debug_flagsPtr
      .asFunction<int Function(ffi.Pointer<OBX_store>, int)>();

  /// @returns true if the store was opened with a previous commit
  /// @see obx_opt_use_previous_commit()
  bool store_opened_with_previous_commit(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_opened_with_previous_commit(
      store,
    );
  }

  late final _store_opened_with_previous_commitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_opened_with_previous_commit');
  late final _store_opened_with_previous_commit =
      _store_opened_with_previous_commitPtr
          .asFunction<bool Function(ffi.Pointer<OBX_store>)>();

  /// Prepares the store to close by setting its internal state to "closing".
  /// Functions relying on the store will result in OBX_ERROR_SHUTTING_DOWN status once closing is initiated.
  /// Unlike obx_store_close(), this method will return immediately and does not free resources just yet.
  /// This is typically used in a multi-threaded context to allow an orderly shutdown in stages which go through a
  /// "not accepting new requests" state.
  int store_prepare_to_close(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_prepare_to_close(
      store,
    );
  }

  late final _store_prepare_to_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_prepare_to_close');
  late final _store_prepare_to_close = _store_prepare_to_closePtr
      .asFunction<int Function(ffi.Pointer<OBX_store>)>();

  /// Closes a previously opened store and thus freeing all resources associated with the store.
  /// \note This waits for write transactions to finish before returning from this call.
  /// @param store may be NULL
  int store_close(
    ffi.Pointer<OBX_store> store,
  ) {
    return _store_close(
      store,
    );
  }

  late final _store_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_store>)>>(
          'obx_store_close');
  late final _store_close =
      _store_closePtr.asFunction<int Function(ffi.Pointer<OBX_store>)>();

  /// Registers the default DB type, which is used if no other types matched a path prefix.
  /// @param storeTypeId Must be one of OBXStoreTypeId (for now).
  int store_type_id_register_default(
    int storeTypeId,
  ) {
    return _store_type_id_register_default(
      storeTypeId,
    );
  }

  late final _store_type_id_register_defaultPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint32)>>(
          'obx_store_type_id_register_default');
  late final _store_type_id_register_default =
      _store_type_id_register_defaultPtr.asFunction<int Function(int)>();

  /// Create a write transaction (read and write).
  /// Transaction creation can be nested (recursive), however only the outermost transaction is relevant on the DB level.
  /// Once you are done tithe the transaction, you must call obx_txn_success() or obx_txn_close().
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details; e.g. code
  /// OBX_ERROR_ILLEGAL_STATE will be set if called when inside a read transaction.
  ffi.Pointer<OBX_txn> txn_write(
    ffi.Pointer<OBX_store> store,
  ) {
    return _txn_write(
      store,
    );
  }

  late final _txn_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_txn> Function(
              ffi.Pointer<OBX_store>)>>('obx_txn_write');
  late final _txn_write = _txn_writePtr
      .asFunction<ffi.Pointer<OBX_txn> Function(ffi.Pointer<OBX_store>)>();

  /// Create a read transaction (read only).
  /// Transaction creation can be nested (recursive), however only the outermost transaction is relevant on the DB level.
  /// Once you are done tithe the transaction, you must call obx_txn_close().
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_txn> txn_read(
    ffi.Pointer<OBX_store> store,
  ) {
    return _txn_read(
      store,
    );
  }

  late final _txn_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_txn> Function(
              ffi.Pointer<OBX_store>)>>('obx_txn_read');
  late final _txn_read = _txn_readPtr
      .asFunction<ffi.Pointer<OBX_txn> Function(ffi.Pointer<OBX_store>)>();

  /// "Finish" this write transaction successfully and close it, performing a commit if this is the top level
  /// transaction and all inner transactions (if any) were also successful (obx_txn_success() was called on them).
  /// Because this also closes the given transaction along with all resources, the given OBX_txn pointer becomes invalid.
  /// Thus, the OBX_txn pointer must not be used afterwards; do not even call obx_txn_close().
  /// @return OBX_ERROR_ILLEGAL_STATE if the given transaction is not a write transaction.
  int txn_success(
    ffi.Pointer<OBX_txn> txn,
  ) {
    return _txn_success(
      txn,
    );
  }

  late final _txn_successPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_txn>)>>(
          'obx_txn_success');
  late final _txn_success =
      _txn_successPtr.asFunction<int Function(ffi.Pointer<OBX_txn>)>();

  /// Close the transaction (read or write) and free all of its resources; the given OBX_txn pointer must not be used
  /// afterwards. If the given transaction is a write transaction, it is aborted (not committed) right away (without
  /// waiting for the top level transaction).
  /// If an error is returned (e.g., a commit failed because DB is full), you can assume that the transaction was closed.
  /// @param txn may be NULL
  int txn_close(
    ffi.Pointer<OBX_txn> txn,
  ) {
    return _txn_close(
      txn,
    );
  }

  late final _txn_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_txn>)>>(
          'obx_txn_close');
  late final _txn_close =
      _txn_closePtr.asFunction<int Function(ffi.Pointer<OBX_txn>)>();

  /// Note: At the moment, you typically want to use only obx_txn_close() instead.
  /// Abort the underlying transaction immediately and thus frees DB resources.
  /// Only obx_txn_close() is allowed to be called on the transaction after calling this.
  int txn_abort(
    ffi.Pointer<OBX_txn> txn,
  ) {
    return _txn_abort(
      txn,
    );
  }

  late final _txn_abortPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_txn>)>>(
          'obx_txn_abort');
  late final _txn_abort =
      _txn_abortPtr.asFunction<int Function(ffi.Pointer<OBX_txn>)>();

  int txn_data_size(
    ffi.Pointer<OBX_txn> txn,
    ffi.Pointer<ffi.Uint64> out_committed_size,
    ffi.Pointer<ffi.Int64> out_size_change,
  ) {
    return _txn_data_size(
      txn,
      out_committed_size,
      out_size_change,
    );
  }

  late final _txn_data_sizePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_txn>, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Int64>)>>('obx_txn_data_size');
  late final _txn_data_size = _txn_data_sizePtr.asFunction<
      int Function(ffi.Pointer<OBX_txn>, ffi.Pointer<ffi.Uint64>,
          ffi.Pointer<ffi.Int64>)>();

  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_cursor> cursor(
    ffi.Pointer<OBX_txn> txn,
    int entity_id,
  ) {
    return _cursor(
      txn,
      entity_id,
    );
  }

  late final _cursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_cursor> Function(
              ffi.Pointer<OBX_txn>, obx_schema_id)>>('obx_cursor');
  late final _cursor = _cursorPtr.asFunction<
      ffi.Pointer<OBX_cursor> Function(ffi.Pointer<OBX_txn>, int)>();

  /// @param cursor may be NULL
  int cursor_close(
    ffi.Pointer<OBX_cursor> cursor,
  ) {
    return _cursor_close(
      cursor,
    );
  }

  late final _cursor_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_cursor>)>>(
          'obx_cursor_close');
  late final _cursor_close =
      _cursor_closePtr.asFunction<int Function(ffi.Pointer<OBX_cursor>)>();

  /// Call this when putting an object to generate/prepare an ID for it.
  /// @param id_or_zero The ID of the entity. If you pass 0, this will generate a new one.
  /// @seealso obx_box_id_for_put()
  int cursor_id_for_put(
    ffi.Pointer<OBX_cursor> cursor,
    int id_or_zero,
  ) {
    return _cursor_id_for_put(
      cursor,
      id_or_zero,
    );
  }

  late final _cursor_id_for_putPtr = _lookup<
          ffi.NativeFunction<obx_id Function(ffi.Pointer<OBX_cursor>, obx_id)>>(
      'obx_cursor_id_for_put');
  late final _cursor_id_for_put = _cursor_id_for_putPtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, int)>();

  /// Puts the given object data using the given ID.
  /// A "put" in ObjectBox follows "insert or update" semantics;
  /// New objects (no pre-existing object for given ID) are inserted while existing objects are replaced/updated.
  /// @param id non-zero
  int cursor_put(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _cursor_put(
      cursor,
      id,
      data,
      size,
    );
  }

  late final _cursor_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_cursor_put');
  late final _cursor_put = _cursor_putPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Like put obx_cursor_put(), but takes an additional parameter (4th parameter) for choosing a put mode.
  /// @param id non-zero
  /// @param mode Changes the put semantics to the given mode, e.g. OBXPutMode_INSERT or OBXPutMode_UPDATE.
  /// @returns OBX_SUCCESS if the put operation was successful
  /// @returns OBX_ERROR_ID_ALREADY_EXISTS OBXPutMode_INSERT was used, but an existing object was found using the given ID
  /// @returns OBX_ERROR_ID_NOT_FOUND OBXPutMode_UPDATE was used, but no object was found for the given ID
  int cursor_put4(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
    int mode,
  ) {
    return _cursor_put4(
      cursor,
      id,
      data,
      size,
      mode,
    );
  }

  late final _cursor_put4Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Int32)>>('obx_cursor_put4');
  late final _cursor_put4 = _cursor_put4Ptr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// An optimized version of obx_cursor_put() if you can ensure that the given ID is not used yet.
  /// Typically used right after getting a new ID via obx_cursor_id_for_put().
  /// WARNING: using this incorrectly (an object with the given ID already exists) may result in inconsistent data
  /// (e.g. indexes do not get updated).
  /// @param id non-zero
  int cursor_put_new(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _cursor_put_new(
      cursor,
      id,
      data,
      size,
    );
  }

  late final _cursor_put_newPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_cursor_put_new');
  late final _cursor_put_new = _cursor_put_newPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Convenience for obx_cursor_put4() with OBXPutMode_INSERT.
  /// @param id non-zero
  /// @returns OBX_ERROR_ID_ALREADY_EXISTS if an insert fails because of a colliding ID
  int cursor_insert(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _cursor_insert(
      cursor,
      id,
      data,
      size,
    );
  }

  late final _cursor_insertPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_cursor_insert');
  late final _cursor_insert = _cursor_insertPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Convenience for obx_cursor_put4() with OBXPutMode_UPDATE.
  /// @param id non-zero
  /// @returns OBX_ERROR_ID_NOT_FOUND  if an update fails because the given ID does not represent any object
  int cursor_update(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _cursor_update(
      cursor,
      id,
      data,
      size,
    );
  }

  late final _cursor_updatePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_cursor_update');
  late final _cursor_update = _cursor_updatePtr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// FB ID slot must be present; new entities must prepare the slot using the special value OBX_ID_NEW.
  /// Alternatively, you may also pass 0 to indicate a new entity if you are aware that FlatBuffers builders typically
  /// skip zero values by default. Thus, you have to "force" writing the zero in FlatBuffers.
  /// @param data object data, non-const because the ID slot will be written (mutated) for new entites (see above)
  /// @returns id if the object could be put, or 0 in case of an error
  int cursor_put_object(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _cursor_put_object(
      cursor,
      data,
      size,
    );
  }

  late final _cursor_put_objectPtr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('obx_cursor_put_object');
  late final _cursor_put_object = _cursor_put_objectPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Void>, int)>();

  /// @overload obx_id obx_cursor_put_object(OBX_cursor* cursor, void* data, size_t size)
  int cursor_put_object4(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Void> data,
    int size,
    int mode,
  ) {
    return _cursor_put_object4(
      cursor,
      data,
      size,
      mode,
    );
  }

  late final _cursor_put_object4Ptr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Int32)>>('obx_cursor_put_object4');
  late final _cursor_put_object4 = _cursor_put_object4Ptr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Void>, int, int)>();

  int cursor_get(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _cursor_get(
      cursor,
      id,
      data,
      size,
    );
  }

  late final _cursor_getPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_cursor>,
              obx_id,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_cursor_get');
  late final _cursor_get = _cursor_getPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Size>)>();

  /// Get all objects as bytes.
  /// For larger quantities, it's recommended to iterate using obx_cursor_first and obx_cursor_next.
  /// However, if the calling overhead is high (e.g., for language bindings), this method helps.
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_bytes_array> cursor_get_all(
    ffi.Pointer<OBX_cursor> cursor,
  ) {
    return _cursor_get_all(
      cursor,
    );
  }

  late final _cursor_get_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_array> Function(
              ffi.Pointer<OBX_cursor>)>>('obx_cursor_get_all');
  late final _cursor_get_all = _cursor_get_allPtr.asFunction<
      ffi.Pointer<OBX_bytes_array> Function(ffi.Pointer<OBX_cursor>)>();

  int cursor_first(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _cursor_first(
      cursor,
      data,
      size,
    );
  }

  late final _cursor_firstPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_cursor_first');
  late final _cursor_first = _cursor_firstPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>)>();

  int cursor_next(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _cursor_next(
      cursor,
      data,
      size,
    );
  }

  late final _cursor_nextPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_cursor_next');
  late final _cursor_next = _cursor_nextPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>)>();

  int cursor_seek(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
  ) {
    return _cursor_seek(
      cursor,
      id,
    );
  }

  late final _cursor_seekPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_cursor>, obx_id)>>(
      'obx_cursor_seek');
  late final _cursor_seek =
      _cursor_seekPtr.asFunction<int Function(ffi.Pointer<OBX_cursor>, int)>();

  int cursor_current(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _cursor_current(
      cursor,
      data,
      size,
    );
  }

  late final _cursor_currentPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_cursor_current');
  late final _cursor_current = _cursor_currentPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>)>();

  int cursor_remove(
    ffi.Pointer<OBX_cursor> cursor,
    int id,
  ) {
    return _cursor_remove(
      cursor,
      id,
    );
  }

  late final _cursor_removePtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_cursor>, obx_id)>>(
      'obx_cursor_remove');
  late final _cursor_remove = _cursor_removePtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, int)>();

  int cursor_remove_all(
    ffi.Pointer<OBX_cursor> cursor,
  ) {
    return _cursor_remove_all(
      cursor,
    );
  }

  late final _cursor_remove_allPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_cursor>)>>(
          'obx_cursor_remove_all');
  late final _cursor_remove_all =
      _cursor_remove_allPtr.asFunction<int Function(ffi.Pointer<OBX_cursor>)>();

  /// Count the number of available objects
  int cursor_count(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Uint64> count,
  ) {
    return _cursor_count(
      cursor,
      count,
    );
  }

  late final _cursor_countPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Uint64>)>>('obx_cursor_count');
  late final _cursor_count = _cursor_countPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Uint64>)>();

  /// Count the number of available objects up to the specified maximum
  int cursor_count_max(
    ffi.Pointer<OBX_cursor> cursor,
    int max_count,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _cursor_count_max(
      cursor,
      max_count,
      out_count,
    );
  }

  late final _cursor_count_maxPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('obx_cursor_count_max');
  late final _cursor_count_max = _cursor_count_maxPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, int, ffi.Pointer<ffi.Uint64>)>();

  /// Return true if there is no object available (false if at least one object is available)
  int cursor_is_empty(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Bool> out_is_empty,
  ) {
    return _cursor_is_empty(
      cursor,
      out_is_empty,
    );
  }

  late final _cursor_is_emptyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Bool>)>>('obx_cursor_is_empty');
  late final _cursor_is_empty = _cursor_is_emptyPtr.asFunction<
      int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<ffi.Bool>)>();

  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_bytes_array> cursor_backlinks(
    ffi.Pointer<OBX_cursor> cursor,
    int entity_id,
    int property_id,
    int id,
  ) {
    return _cursor_backlinks(
      cursor,
      entity_id,
      property_id,
      id,
    );
  }

  late final _cursor_backlinksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_array> Function(ffi.Pointer<OBX_cursor>,
              obx_schema_id, obx_schema_id, obx_id)>>('obx_cursor_backlinks');
  late final _cursor_backlinks = _cursor_backlinksPtr.asFunction<
      ffi.Pointer<OBX_bytes_array> Function(
          ffi.Pointer<OBX_cursor>, int, int, int)>();

  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_id_array> cursor_backlink_ids(
    ffi.Pointer<OBX_cursor> cursor,
    int entity_id,
    int property_id,
    int id,
  ) {
    return _cursor_backlink_ids(
      cursor,
      entity_id,
      property_id,
      id,
    );
  }

  late final _cursor_backlink_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(
              ffi.Pointer<OBX_cursor>,
              obx_schema_id,
              obx_schema_id,
              obx_id)>>('obx_cursor_backlink_ids');
  late final _cursor_backlink_ids = _cursor_backlink_idsPtr.asFunction<
      ffi.Pointer<OBX_id_array> Function(
          ffi.Pointer<OBX_cursor>, int, int, int)>();

  /// Puts a standalone (many-to-many) relation instance to "connect" two objects.
  /// @warning Ensure that the source and target IDs are pointing to actually existing objects.
  /// Failing to do so may result in subtle errors.
  /// For example, a known problem is that sync filters always filter out relations that have no valid objects.
  /// @note It's called a "standalone" relation because the relation data is stored separately of object data.
  int cursor_rel_put(
    ffi.Pointer<OBX_cursor> cursor,
    int relation_id,
    int source_id,
    int target_id,
  ) {
    return _cursor_rel_put(
      cursor,
      relation_id,
      source_id,
      target_id,
    );
  }

  late final _cursor_rel_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_schema_id, obx_id,
              obx_id)>>('obx_cursor_rel_put');
  late final _cursor_rel_put = _cursor_rel_putPtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, int, int, int)>();

  /// Removes a standalone (many-to-many) relation instance to "disconnect" two objects.
  int cursor_rel_remove(
    ffi.Pointer<OBX_cursor> cursor,
    int relation_id,
    int source_id,
    int target_id,
  ) {
    return _cursor_rel_remove(
      cursor,
      relation_id,
      source_id,
      target_id,
    );
  }

  late final _cursor_rel_removePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>, obx_schema_id, obx_id,
              obx_id)>>('obx_cursor_rel_remove');
  late final _cursor_rel_remove = _cursor_rel_removePtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, int, int, int)>();

  /// Gets the standalone (many-to-many) relation instance for the given source ID (the "connections" to other objects).
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_id_array> cursor_rel_ids(
    ffi.Pointer<OBX_cursor> cursor,
    int relation_id,
    int source_id,
  ) {
    return _cursor_rel_ids(
      cursor,
      relation_id,
      source_id,
    );
  }

  late final _cursor_rel_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_cursor>,
              obx_schema_id, obx_id)>>('obx_cursor_rel_ids');
  late final _cursor_rel_ids = _cursor_rel_idsPtr.asFunction<
      ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_cursor>, int, int)>();

  /// Gets the first object ID or zero if there was no object
  int cursor_seek_first_id(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<obx_id> out_id,
  ) {
    return _cursor_seek_first_id(
      cursor,
      out_id,
    );
  }

  late final _cursor_seek_first_idPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>,
              ffi.Pointer<obx_id>)>>('obx_cursor_seek_first_id');
  late final _cursor_seek_first_id = _cursor_seek_first_idPtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<obx_id>)>();

  /// Gets the next object ID or zero if there was no next object
  int cursor_seek_next_id(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<obx_id> out_id,
  ) {
    return _cursor_seek_next_id(
      cursor,
      out_id,
    );
  }

  late final _cursor_seek_next_idPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>,
              ffi.Pointer<obx_id>)>>('obx_cursor_seek_next_id');
  late final _cursor_seek_next_id = _cursor_seek_next_idPtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<obx_id>)>();

  /// Gets the object ID at the current position; ensures being up-to-date by verifying against database.
  /// @param out_id pointer to receive an output. If the cursor is not positioned at an actual object,
  /// it receives one of two special IDs:
  /// 0 (OBJECT_ID_BEFORE_START) if the cursor was not yet moved or reached the end (going backwards).
  /// 0xFFFFFFFFFFFFFFFF (OBJECT_ID_BEYOND_END) if the cursor reached the end (going forwards).
  int cursor_current_id(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<obx_id> out_id,
  ) {
    return _cursor_current_id(
      cursor,
      out_id,
    );
  }

  late final _cursor_current_idPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_cursor>,
              ffi.Pointer<obx_id>)>>('obx_cursor_current_id');
  late final _cursor_current_id = _cursor_current_idPtr
      .asFunction<int Function(ffi.Pointer<OBX_cursor>, ffi.Pointer<obx_id>)>();

  /// Time series: get the limits (min/max time values) over all objects
  /// @param out_min_id pointer to receive an output (may be NULL)
  /// @param out_min_value pointer to receive an output (may be NULL)
  /// @param out_max_id pointer to receive an output (may be NULL)
  /// @param out_max_value pointer to receive an output (may be NULL)
  /// @returns OBX_NOT_FOUND if no objects are stored
  int cursor_ts_min_max(
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<obx_id> out_min_id,
    ffi.Pointer<ffi.Int64> out_min_value,
    ffi.Pointer<obx_id> out_max_id,
    ffi.Pointer<ffi.Int64> out_max_value,
  ) {
    return _cursor_ts_min_max(
      cursor,
      out_min_id,
      out_min_value,
      out_max_id,
      out_max_value,
    );
  }

  late final _cursor_ts_min_maxPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_cursor>,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>)>>('obx_cursor_ts_min_max');
  late final _cursor_ts_min_max = _cursor_ts_min_maxPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>)>();

  /// Time series: get the limits (min/max time values) over objects within the given time range
  /// @param out_min_id pointer to receive an output (may be NULL)
  /// @param out_min_value pointer to receive an output (may be NULL)
  /// @param out_max_id pointer to receive an output (may be NULL)
  /// @param out_max_value pointer to receive an output (may be NULL)
  /// @returns OBX_NOT_FOUND if no objects are stored in the given range
  int cursor_ts_min_max_range(
    ffi.Pointer<OBX_cursor> cursor,
    int range_begin,
    int range_end,
    ffi.Pointer<obx_id> out_min_id,
    ffi.Pointer<ffi.Int64> out_min_value,
    ffi.Pointer<obx_id> out_max_id,
    ffi.Pointer<ffi.Int64> out_max_value,
  ) {
    return _cursor_ts_min_max_range(
      cursor,
      range_begin,
      range_end,
      out_min_id,
      out_min_value,
      out_max_id,
      out_max_value,
    );
  }

  late final _cursor_ts_min_max_rangePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_cursor>,
              ffi.Int64,
              ffi.Int64,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>)>>('obx_cursor_ts_min_max_range');
  late final _cursor_ts_min_max_range = _cursor_ts_min_max_rangePtr.asFunction<
      int Function(
          ffi.Pointer<OBX_cursor>,
          int,
          int,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>)>();

  /// Get access to the box for the given entity. A box may be used across threads.
  /// Boxes are shared instances and managed by the store so there's no need to close/free them manually.
  ffi.Pointer<OBX_box> box(
    ffi.Pointer<OBX_store> store,
    int entity_id,
  ) {
    return _box(
      store,
      entity_id,
    );
  }

  late final _boxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_box> Function(
              ffi.Pointer<OBX_store>, obx_schema_id)>>('obx_box');
  late final _box = _boxPtr
      .asFunction<ffi.Pointer<OBX_box> Function(ffi.Pointer<OBX_store>, int)>();

  /// Get access to the store this box belongs to - utility for when you only have access to the `box` variable but need
  /// some store method, such as starting a transaction.
  /// This doesn't produce a new instance of OBX_store, just gives you back the same pointer you've created this box with.
  /// In other words, don't close the returned store separately.
  ffi.Pointer<OBX_store> box_store(
    ffi.Pointer<OBX_box> box,
  ) {
    return _box_store(
      box,
    );
  }

  late final _box_storePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<OBX_box>)>>('obx_box_store');
  late final _box_store = _box_storePtr
      .asFunction<ffi.Pointer<OBX_store> Function(ffi.Pointer<OBX_box>)>();

  /// Check whether a given object exists in the box.
  int box_contains(
    ffi.Pointer<OBX_box> box,
    int id,
    ffi.Pointer<ffi.Bool> out_contains,
  ) {
    return _box_contains(
      box,
      id,
      out_contains,
    );
  }

  late final _box_containsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_id,
              ffi.Pointer<ffi.Bool>)>>('obx_box_contains');
  late final _box_contains = _box_containsPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int, ffi.Pointer<ffi.Bool>)>();

  /// Check whether this box contains objects with all of the IDs given.
  /// @param out_contains is set to true if all of the IDs are present, otherwise false
  int box_contains_many(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<OBX_id_array> ids,
    ffi.Pointer<ffi.Bool> out_contains,
  ) {
    return _box_contains_many(
      box,
      ids,
      out_contains,
    );
  }

  late final _box_contains_manyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_id_array>,
              ffi.Pointer<ffi.Bool>)>>('obx_box_contains_many');
  late final _box_contains_many = _box_contains_manyPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_id_array>,
          ffi.Pointer<ffi.Bool>)>();

  /// Fetch a single object from the box; must be called inside a (reentrant) transaction.
  /// The exposed data comes directly from the OS to allow zero-copy access, which limits the data lifetime:
  /// \attention The exposed data is only valid as long as the (top) transaction is still active and no write
  /// \attention operation (e.g. put/remove) was executed. Accessing data after this is undefined behavior.
  /// @returns OBX_ERROR_ILLEGAL_STATE if not inside of an active transaction (see obx_txn_read() and obx_txn_write())
  int box_get(
    ffi.Pointer<OBX_box> box,
    int id,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _box_get(
      box,
      id,
      data,
      size,
    );
  }

  late final _box_getPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_box>,
              obx_id,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_box_get');
  late final _box_get = _box_getPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Size>)>();

  /// Fetch multiple objects for the given IDs from the box; must be called inside a (reentrant) transaction.
  /// \attention See obx_box_get() for important notes on the limited lifetime of the exposed data.
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details; e.g. code
  /// OBX_ERROR_ILLEGAL_STATE will be set if not inside of an active transaction
  /// (see obx_txn_read() and obx_txn_write())
  ffi.Pointer<OBX_bytes_array> box_get_many(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<OBX_id_array> ids,
  ) {
    return _box_get_many(
      box,
      ids,
    );
  }

  late final _box_get_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_array> Function(ffi.Pointer<OBX_box>,
              ffi.Pointer<OBX_id_array>)>>('obx_box_get_many');
  late final _box_get_many = _box_get_manyPtr.asFunction<
      ffi.Pointer<OBX_bytes_array> Function(
          ffi.Pointer<OBX_box>, ffi.Pointer<OBX_id_array>)>();

  /// Fetch all objects from the box; must be called inside a (reentrant) transaction.
  /// NOTE: don't call this in 32 bit mode! Use obx_box_visit_all() instead.
  /// \attention See obx_box_get() for important notes on the limited lifetime of the exposed data.
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details; e.g. code
  /// OBX_ERROR_ILLEGAL_STATE will be set if not inside of an active transaction
  /// (see obx_txn_read() and obx_txn_write())
  ffi.Pointer<OBX_bytes_array> box_get_all(
    ffi.Pointer<OBX_box> box,
  ) {
    return _box_get_all(
      box,
    );
  }

  late final _box_get_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_array> Function(
              ffi.Pointer<OBX_box>)>>('obx_box_get_all');
  late final _box_get_all = _box_get_allPtr.asFunction<
      ffi.Pointer<OBX_bytes_array> Function(ffi.Pointer<OBX_box>)>();

  /// Read given objects from the database in a single transaction.
  /// Call the visitor() on each object, passing user_data, object data & size as arguments.
  /// The given visitor must return true to keep receiving results, false to cancel.
  /// If an object is not found, the visitor() is still called, passing NULL as data and a 0 as size.
  int box_visit_many(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<OBX_id_array> ids,
    ffi.Pointer<obx_data_visitor> visitor,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _box_visit_many(
      box,
      ids,
      visitor,
      user_data,
    );
  }

  late final _box_visit_manyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_box>,
              ffi.Pointer<OBX_id_array>,
              ffi.Pointer<obx_data_visitor>,
              ffi.Pointer<ffi.Void>)>>('obx_box_visit_many');
  late final _box_visit_many = _box_visit_manyPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_id_array>,
          ffi.Pointer<obx_data_visitor>, ffi.Pointer<ffi.Void>)>();

  /// Read all objects in a single transaction.
  /// Calls the visitor() on each object, passing visitor_arg, object data & size as arguments.
  /// The given visitor must return true to keep receiving results, false to cancel.
  int box_visit_all(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<obx_data_visitor> visitor,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _box_visit_all(
      box,
      visitor,
      user_data,
    );
  }

  late final _box_visit_allPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Pointer<obx_data_visitor>,
              ffi.Pointer<ffi.Void>)>>('obx_box_visit_all');
  late final _box_visit_all = _box_visit_allPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<obx_data_visitor>,
          ffi.Pointer<ffi.Void>)>();

  /// Prepares an ID for insertion: pass in 0 (zero) to reserve a new ID or an existing ID to check/prepare it.
  /// @param id_or_zero The ID of the entity. If you pass 0, this will generate a new one.
  /// @seealso obx_cursor_id_for_put()
  int box_id_for_put(
    ffi.Pointer<OBX_box> box,
    int id_or_zero,
  ) {
    return _box_id_for_put(
      box,
      id_or_zero,
    );
  }

  late final _box_id_for_putPtr = _lookup<
          ffi.NativeFunction<obx_id Function(ffi.Pointer<OBX_box>, obx_id)>>(
      'obx_box_id_for_put');
  late final _box_id_for_put =
      _box_id_for_putPtr.asFunction<int Function(ffi.Pointer<OBX_box>, int)>();

  /// Reserve the given number of (new) IDs for insertion; a bulk version of obx_box_id_for_put().
  /// @param count number of IDs to reserve, max 10000
  /// @param out_first_id the first ID of the sequence as
  /// @returns an error in case the required number of IDs could not be reserved.
  int box_ids_for_put(
    ffi.Pointer<OBX_box> box,
    int count,
    ffi.Pointer<obx_id> out_first_id,
  ) {
    return _box_ids_for_put(
      box,
      count,
      out_first_id,
    );
  }

  late final _box_ids_for_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Uint64,
              ffi.Pointer<obx_id>)>>('obx_box_ids_for_put');
  late final _box_ids_for_put = _box_ids_for_putPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int, ffi.Pointer<obx_id>)>();

  /// Put the given object using the given ID synchronously; note that the ID also must match the one present in data.
  /// @param id An ID usually reserved via obx_box_id_for_put().
  /// @see obx_box_put5() to additionally provide a put mode
  /// @see obx_box_put_object() for a variant not requiring reserving IDs
  int box_put(
    ffi.Pointer<OBX_box> box,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _box_put(
      box,
      id,
      data,
      size,
    );
  }

  late final _box_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_id, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_box_put');
  late final _box_put = _box_putPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Convenience for obx_box_put5() with OBXPutMode_INSERT.
  /// @param id non-zero
  /// @returns OBX_ERROR_ID_ALREADY_EXISTS if an insert fails because of a colliding ID
  int box_insert(
    ffi.Pointer<OBX_box> box,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _box_insert(
      box,
      id,
      data,
      size,
    );
  }

  late final _box_insertPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_id, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_box_insert');
  late final _box_insert = _box_insertPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Convenience for obx_cursor_put4() with OBXPutMode_UPDATE.
  /// @param id non-zero
  /// @returns OBX_ERROR_ID_NOT_FOUND  if an update fails because the given ID does not represent any object
  int box_update(
    ffi.Pointer<OBX_box> box,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _box_update(
      box,
      id,
      data,
      size,
    );
  }

  late final _box_updatePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_id, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_box_update');
  late final _box_update = _box_updatePtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Put the given object using the given ID synchronously; note that the ID also must match the one present in data.
  /// @param id An ID usually reserved via obx_box_id_for_put().
  /// @see obx_box_put() for standard put mode
  /// @see obx_box_put_object() for a variant not requiring reserving IDs
  int box_put5(
    ffi.Pointer<OBX_box> box,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
    int mode,
  ) {
    return _box_put5(
      box,
      id,
      data,
      size,
      mode,
    );
  }

  late final _box_put5Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_id, ffi.Pointer<ffi.Uint8>,
              ffi.Size, ffi.Int32)>>('obx_box_put5');
  late final _box_put5 = _box_put5Ptr.asFunction<
      int Function(
          ffi.Pointer<OBX_box>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// FB ID slot must be present in the given data; new entities must have an ID value of zero or OBX_ID_NEW.
  /// @param data writable data buffer, which may be updated for the ID
  /// @returns id if the object could be put, or 0 in case of an error
  int box_put_object(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _box_put_object(
      box,
      data,
      size,
    );
  }

  late final _box_put_objectPtr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_box>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('obx_box_put_object');
  late final _box_put_object = _box_put_objectPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<ffi.Void>, int)>();

  /// FB ID slot must be present in the given data; new entities must have an ID value of zero or OBX_ID_NEW
  /// @param data writable data buffer, which may be updated for the ID
  /// @returns id if the object, or 0 in case of an error, e.g. the entity was not put according to OBXPutMode
  int box_put_object4(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<ffi.Void> data,
    int size,
    int mode,
  ) {
    return _box_put_object4(
      box,
      data,
      size,
      mode,
    );
  }

  late final _box_put_object4Ptr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_box>, ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Int32)>>('obx_box_put_object4');
  late final _box_put_object4 = _box_put_object4Ptr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Put all given objects in the database in a single transaction. If any of the individual objects failed to put,
  /// none are put and an error is returned, equivalent to calling obx_box_put_many5() with fail_on_id_failure=true.
  /// @param ids Previously allocated IDs for the given given objects (e.g. using obx_box_ids_for_put)
  int box_put_many(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<OBX_bytes_array> objects,
    ffi.Pointer<obx_id> ids,
    int mode,
  ) {
    return _box_put_many(
      box,
      objects,
      ids,
      mode,
    );
  }

  late final _box_put_manyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_bytes_array>,
              ffi.Pointer<obx_id>, ffi.Int32)>>('obx_box_put_many');
  late final _box_put_many = _box_put_manyPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_bytes_array>,
          ffi.Pointer<obx_id>, int)>();

  /// Like obx_box_put_many(), but with an additional flag indicating how to treat ID failures with OBXPutMode_INSERT and
  /// OBXPutMode_UPDATE.
  /// @param fail_on_id_failure if set to true, an ID failure (OBX_ERROR_ID_ALREADY_EXISTS and OBX_ERROR_ID_NOT_FOUND)
  /// will fail the transaction, and none of the objects are put/inserted/updated.
  /// Note 1: If this function is run inside a managed TX (created by obx_txn_write()) with fail_on_id_failure=true and
  /// a failure occurs, the whole outer TX is also aborted.
  /// Note 2: ID failure errors are returned even if fail_on_id_failure=false and the TX wasn't aborted.
  int box_put_many5(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<OBX_bytes_array> objects,
    ffi.Pointer<obx_id> ids,
    int mode,
    bool fail_on_id_failure,
  ) {
    return _box_put_many5(
      box,
      objects,
      ids,
      mode,
      fail_on_id_failure,
    );
  }

  late final _box_put_many5Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_bytes_array>,
              ffi.Pointer<obx_id>, ffi.Int32, ffi.Bool)>>('obx_box_put_many5');
  late final _box_put_many5 = _box_put_many5Ptr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_bytes_array>,
          ffi.Pointer<obx_id>, int, bool)>();

  /// Remove a single object
  /// will return OBX_NOT_FOUND if an object with the given ID doesn't exist
  int box_remove(
    ffi.Pointer<OBX_box> box,
    int id,
  ) {
    return _box_remove(
      box,
      id,
    );
  }

  late final _box_removePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_box>, obx_id)>>(
      'obx_box_remove');
  late final _box_remove =
      _box_removePtr.asFunction<int Function(ffi.Pointer<OBX_box>, int)>();

  /// Remove all given objects from the database in a single transaction.
  /// Note that this method will not fail if the object is not found (e.g. already removed).
  /// In case you need to strictly check whether all of the objects exist before removing them,
  /// execute obx_box_contains_ids() and obx_box_remove_ids() inside a single write transaction.
  /// @param out_count Pointer to retrieve the number of removed objects; optional: may be NULL.
  int box_remove_many(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<OBX_id_array> ids,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _box_remove_many(
      box,
      ids,
      out_count,
    );
  }

  late final _box_remove_manyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_id_array>,
              ffi.Pointer<ffi.Uint64>)>>('obx_box_remove_many');
  late final _box_remove_many = _box_remove_manyPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<OBX_id_array>,
          ffi.Pointer<ffi.Uint64>)>();

  /// Remove all objects and set the out_count the the number of removed objects.
  /// @param out_count Pointer to retrieve the number of removed objects; optional: may be NULL.
  int box_remove_all(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _box_remove_all(
      box,
      out_count,
    );
  }

  late final _box_remove_allPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>,
              ffi.Pointer<ffi.Uint64>)>>('obx_box_remove_all');
  late final _box_remove_all = _box_remove_allPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, ffi.Pointer<ffi.Uint64>)>();

  /// Check whether there are any objects for this entity and updates the out_is_empty accordingly
  int box_is_empty(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<ffi.Bool> out_is_empty,
  ) {
    return _box_is_empty(
      box,
      out_is_empty,
    );
  }

  late final _box_is_emptyPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>,
              ffi.Pointer<ffi.Bool>)>>('obx_box_is_empty');
  late final _box_is_empty = _box_is_emptyPtr
      .asFunction<int Function(ffi.Pointer<OBX_box>, ffi.Pointer<ffi.Bool>)>();

  /// Count the number of objects in the box, up to the given maximum.
  /// You can pass limit=0 to count all objects without any limitation.
  int box_count(
    ffi.Pointer<OBX_box> box,
    int limit,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _box_count(
      box,
      limit,
      out_count,
    );
  }

  late final _box_countPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('obx_box_count');
  late final _box_count = _box_countPtr.asFunction<
      int Function(ffi.Pointer<OBX_box>, int, ffi.Pointer<ffi.Uint64>)>();

  /// Fetch IDs of all objects that link back to the given object (ID) using the given relation property (ID).
  /// Note: This method refers to "property based relations" unlike the "stand-alone relations" (see obx_box_rel_*).
  /// @param property_id the relation property, which must belong to the entity type represented by this box
  /// @param id object ID; the object's type is the target of the relation property (typically from another Box)
  /// @returns resulting IDs representing objects in this Box, or NULL in case of an error
  ffi.Pointer<OBX_id_array> box_get_backlink_ids(
    ffi.Pointer<OBX_box> box,
    int property_id,
    int id,
  ) {
    return _box_get_backlink_ids(
      box,
      property_id,
      id,
    );
  }

  late final _box_get_backlink_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_box>,
              obx_schema_id, obx_id)>>('obx_box_get_backlink_ids');
  late final _box_get_backlink_ids = _box_get_backlink_idsPtr.asFunction<
      ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_box>, int, int)>();

  /// Insert a standalone relation entry between two objects.
  /// @param relation_id must be a standalone relation ID with source entity belonging to this box
  /// @param source_id identifies an object from this box
  /// @param target_id identifies an object from the target box (as per the relation definition)
  int box_rel_put(
    ffi.Pointer<OBX_box> box,
    int relation_id,
    int source_id,
    int target_id,
  ) {
    return _box_rel_put(
      box,
      relation_id,
      source_id,
      target_id,
    );
  }

  late final _box_rel_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_schema_id, obx_id,
              obx_id)>>('obx_box_rel_put');
  late final _box_rel_put = _box_rel_putPtr
      .asFunction<int Function(ffi.Pointer<OBX_box>, int, int, int)>();

  /// Remove a standalone relation entry between two objects.
  /// See obx_box_rel_put() for parameters documentation.
  int box_rel_remove(
    ffi.Pointer<OBX_box> box,
    int relation_id,
    int source_id,
    int target_id,
  ) {
    return _box_rel_remove(
      box,
      relation_id,
      source_id,
      target_id,
    );
  }

  late final _box_rel_removePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_box>, obx_schema_id, obx_id,
              obx_id)>>('obx_box_rel_remove');
  late final _box_rel_remove = _box_rel_removePtr
      .asFunction<int Function(ffi.Pointer<OBX_box>, int, int, int)>();

  /// Fetch IDs of all objects in this Box related to the given object (typically from another Box).
  /// Used for a stand-alone relation and its "regular" direction; this Box represents the target of the relation.
  /// @param relation_id ID of a standalone relation, whose target type matches this Box
  /// @param id object ID of the relation source type (typically from another Box)
  /// @returns resulting IDs representing objects in this Box, or NULL in case of an error
  ffi.Pointer<OBX_id_array> box_rel_get_ids(
    ffi.Pointer<OBX_box> box,
    int relation_id,
    int id,
  ) {
    return _box_rel_get_ids(
      box,
      relation_id,
      id,
    );
  }

  late final _box_rel_get_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_box>,
              obx_schema_id, obx_id)>>('obx_box_rel_get_ids');
  late final _box_rel_get_ids = _box_rel_get_idsPtr.asFunction<
      ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_box>, int, int)>();

  /// Fetch IDs of all objects in this Box related to the given object (typically from another Box).
  /// Used for a stand-alone relation and its "backlink" direction; this Box represents the source of the relation.
  /// @param relation_id ID of a standalone relation, whose source type matches this Box
  /// @param id object ID of the relation target type (typically from another Box)
  /// @returns resulting IDs representing objects in this Box, or NULL in case of an error
  ffi.Pointer<OBX_id_array> box_rel_get_backlink_ids(
    ffi.Pointer<OBX_box> box,
    int relation_id,
    int id,
  ) {
    return _box_rel_get_backlink_ids(
      box,
      relation_id,
      id,
    );
  }

  late final _box_rel_get_backlink_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_box>,
              obx_schema_id, obx_id)>>('obx_box_rel_get_backlink_ids');
  late final _box_rel_get_backlink_ids =
      _box_rel_get_backlink_idsPtr.asFunction<
          ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_box>, int, int)>();

  /// Removes expired objects of one or all entity types.
  /// @param entity_id Type of the objects to be remove; if zero, all types are included.
  /// Hint: if you only have the entity type's name, use obx_store_entity_id() to get the ID.
  /// @param out_removed_count If given (non-null), it will receive the count of removed objects.
  /// @see OBXPropertyFlags_EXPIRATION_TIME to define a property for the expiration time.
  int expired_objects_remove(
    ffi.Pointer<OBX_txn> txn,
    int entity_id,
    ffi.Pointer<ffi.Size> out_removed_count,
  ) {
    return _expired_objects_remove(
      txn,
      entity_id,
      out_removed_count,
    );
  }

  late final _expired_objects_removePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_txn>, obx_schema_id,
              ffi.Pointer<ffi.Size>)>>('obx_expired_objects_remove');
  late final _expired_objects_remove = _expired_objects_removePtr.asFunction<
      int Function(ffi.Pointer<OBX_txn>, int, ffi.Pointer<ffi.Size>)>();

  /// Asynchronously removes expired objects of one or all entity types.
  /// @param entity_id Type of the objects to be remove; if zero, all types are included.
  /// Hint: if you only have the entity type's name, use obx_store_entity_id() to get the ID.
  /// @see OBXPropertyFlags_EXPIRATION_TIME to define a property for the expiration time.
  int expired_objects_remove_async(
    ffi.Pointer<OBX_store> store,
    int entity_id,
    ffi.Pointer<obx_status_callback> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _expired_objects_remove_async(
      store,
      entity_id,
      callback,
      user_data,
    );
  }

  late final _expired_objects_remove_asyncPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_store>,
              obx_schema_id,
              ffi.Pointer<obx_status_callback>,
              ffi.Pointer<ffi.Void>)>>('obx_expired_objects_remove_async');
  late final _expired_objects_remove_async =
      _expired_objects_remove_asyncPtr.asFunction<
          int Function(ffi.Pointer<OBX_store>, int,
              ffi.Pointer<obx_status_callback>, ffi.Pointer<ffi.Void>)>();

  /// Time series: get the limits (min/max time values) over all objects
  /// @param out_min_id pointer to receive an output (may be NULL)
  /// @param out_min_value pointer to receive an output (may be NULL)
  /// @param out_max_id pointer to receive an output (may be NULL)
  /// @param out_max_value pointer to receive an output (may be NULL)
  /// @returns OBX_NOT_FOUND if no objects are stored
  int box_ts_min_max(
    ffi.Pointer<OBX_box> box,
    ffi.Pointer<obx_id> out_min_id,
    ffi.Pointer<ffi.Int64> out_min_value,
    ffi.Pointer<obx_id> out_max_id,
    ffi.Pointer<ffi.Int64> out_max_value,
  ) {
    return _box_ts_min_max(
      box,
      out_min_id,
      out_min_value,
      out_max_id,
      out_max_value,
    );
  }

  late final _box_ts_min_maxPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_box>,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>)>>('obx_box_ts_min_max');
  late final _box_ts_min_max = _box_ts_min_maxPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_box>,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>)>();

  /// Time series: get the limits (min/max time values) over objects within the given time range
  /// @param out_min_id pointer to receive an output (may be NULL)
  /// @param out_min_value pointer to receive an output (may be NULL)
  /// @param out_max_id pointer to receive an output (may be NULL)
  /// @param out_max_value pointer to receive an output (may be NULL)
  /// @returns OBX_NOT_FOUND if no objects are stored in the given range
  int box_ts_min_max_range(
    ffi.Pointer<OBX_box> box,
    int range_begin,
    int range_end,
    ffi.Pointer<obx_id> out_min_id,
    ffi.Pointer<ffi.Int64> out_min_value,
    ffi.Pointer<obx_id> out_max_id,
    ffi.Pointer<ffi.Int64> out_max_value,
  ) {
    return _box_ts_min_max_range(
      box,
      range_begin,
      range_end,
      out_min_id,
      out_min_value,
      out_max_id,
      out_max_value,
    );
  }

  late final _box_ts_min_max_rangePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_box>,
              ffi.Int64,
              ffi.Int64,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Int64>)>>('obx_box_ts_min_max_range');
  late final _box_ts_min_max_range = _box_ts_min_max_rangePtr.asFunction<
      int Function(
          ffi.Pointer<OBX_box>,
          int,
          int,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Int64>)>();

  /// Note: DO NOT close this OBX_async; its lifetime is tied to the OBX_box instance.
  ffi.Pointer<OBX_async> async1(
    ffi.Pointer<OBX_box> box,
  ) {
    return _async1(
      box,
    );
  }

  late final _async1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_async> Function(ffi.Pointer<OBX_box>)>>('obx_async');
  late final _async1 = _async1Ptr
      .asFunction<ffi.Pointer<OBX_async> Function(ffi.Pointer<OBX_box>)>();

  /// Put asynchronously with standard put semantics (insert or update).
  int async_put(
    ffi.Pointer<OBX_async> async1,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _async_put(
      async1,
      id,
      data,
      size,
    );
  }

  late final _async_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_async>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_async_put');
  late final _async_put = _async_putPtr.asFunction<
      int Function(ffi.Pointer<OBX_async>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Put asynchronously using the given mode.
  int async_put5(
    ffi.Pointer<OBX_async> async1,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
    int mode,
  ) {
    return _async_put5(
      async1,
      id,
      data,
      size,
      mode,
    );
  }

  late final _async_put5Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_async>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Int32)>>('obx_async_put5');
  late final _async_put5 = _async_put5Ptr.asFunction<
      int Function(
          ffi.Pointer<OBX_async>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Put asynchronously with inserts semantics (won't put if object already exists).
  int async_insert(
    ffi.Pointer<OBX_async> async1,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _async_insert(
      async1,
      id,
      data,
      size,
    );
  }

  late final _async_insertPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_async>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_async_insert');
  late final _async_insert = _async_insertPtr.asFunction<
      int Function(ffi.Pointer<OBX_async>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Put asynchronously with update semantics (won't put if object is not yet present).
  int async_update(
    ffi.Pointer<OBX_async> async1,
    int id,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _async_update(
      async1,
      id,
      data,
      size,
    );
  }

  late final _async_updatePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_async>, obx_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_async_update');
  late final _async_update = _async_updatePtr.asFunction<
      int Function(ffi.Pointer<OBX_async>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Reserve an ID, which is returned immediately for future reference, and put asynchronously.
  /// Note: of course, it can NOT be guaranteed that the entity will actually be put successfully in the DB.
  /// @param data the given bytes are mutated to update the contained ID data.
  /// @returns id of the new object, 0 on error
  int async_put_object(
    ffi.Pointer<OBX_async> async1,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _async_put_object(
      async1,
      data,
      size,
    );
  }

  late final _async_put_objectPtr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_async>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('obx_async_put_object');
  late final _async_put_object = _async_put_objectPtr.asFunction<
      int Function(ffi.Pointer<OBX_async>, ffi.Pointer<ffi.Void>, int)>();

  /// FB ID slot must be present in the given data; new entities must have an ID value of zero or OBX_ID_NEW
  /// @param data writable data buffer, which may be updated for the ID
  /// @returns id of the new object, 0 on error, e.g. the entity can't be put according to OBXPutMode
  int async_put_object4(
    ffi.Pointer<OBX_async> async1,
    ffi.Pointer<ffi.Void> data,
    int size,
    int mode,
  ) {
    return _async_put_object4(
      async1,
      data,
      size,
      mode,
    );
  }

  late final _async_put_object4Ptr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_async>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Int32)>>('obx_async_put_object4');
  late final _async_put_object4 = _async_put_object4Ptr.asFunction<
      int Function(ffi.Pointer<OBX_async>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Reserve an ID, which is returned immediately for future reference, and insert asynchronously.
  /// Note: of course, it can NOT be guaranteed that the entity will actually be inserted successfully in the DB.
  /// @param data the given bytes are mutated to update the contained ID data.
  /// @returns id of the new object, 0 on error
  int async_insert_object(
    ffi.Pointer<OBX_async> async1,
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _async_insert_object(
      async1,
      data,
      size,
    );
  }

  late final _async_insert_objectPtr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_async>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('obx_async_insert_object');
  late final _async_insert_object = _async_insert_objectPtr.asFunction<
      int Function(ffi.Pointer<OBX_async>, ffi.Pointer<ffi.Void>, int)>();

  /// Remove asynchronously.
  int async_remove(
    ffi.Pointer<OBX_async> async1,
    int id,
  ) {
    return _async_remove(
      async1,
      id,
    );
  }

  late final _async_removePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_async>, obx_id)>>(
      'obx_async_remove');
  late final _async_remove =
      _async_removePtr.asFunction<int Function(ffi.Pointer<OBX_async>, int)>();

  /// Create a custom OBX_async instance that has to be closed using obx_async_close().
  /// Note: for standard tasks, prefer obx_box_async() giving you a shared instance that does not have to be closed.
  ffi.Pointer<OBX_async> async_create(
    ffi.Pointer<OBX_box> box,
    int enqueue_timeout_millis,
  ) {
    return _async_create(
      box,
      enqueue_timeout_millis,
    );
  }

  late final _async_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_async> Function(
              ffi.Pointer<OBX_box>, ffi.Uint64)>>('obx_async_create');
  late final _async_create = _async_createPtr
      .asFunction<ffi.Pointer<OBX_async> Function(ffi.Pointer<OBX_box>, int)>();

  /// Close a custom OBX_async instance created with obx_async_create().
  /// @return OBX_ERROR_ILLEGAL_ARGUMENT if you pass the shared instance from obx_box_async()
  int async_close(
    ffi.Pointer<OBX_async> async1,
  ) {
    return _async_close(
      async1,
    );
  }

  late final _async_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_async>)>>(
          'obx_async_close');
  late final _async_close =
      _async_closePtr.asFunction<int Function(ffi.Pointer<OBX_async>)>();

  /// Create a query builder which is used to collect conditions using the obx_qb_* functions.
  /// Once all conditions are applied, use obx_query() to build a OBX_query that is used to actually retrieve data.
  /// Use obx_qb_close() to close (free) the query builder.
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_query_builder> query_builder(
    ffi.Pointer<OBX_store> store,
    int entity_id,
  ) {
    return _query_builder(
      store,
      entity_id,
    );
  }

  late final _query_builderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_builder> Function(
              ffi.Pointer<OBX_store>, obx_schema_id)>>('obx_query_builder');
  late final _query_builder = _query_builderPtr.asFunction<
      ffi.Pointer<OBX_query_builder> Function(ffi.Pointer<OBX_store>, int)>();

  /// Close the query builder; note that OBX_query objects outlive their builder and thus are not affected by this call.
  /// @param builder may be NULL
  int qb_close(
    ffi.Pointer<OBX_query_builder> builder,
  ) {
    return _qb_close(
      builder,
    );
  }

  late final _qb_closePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_query_builder>)>>(
      'obx_qb_close');
  late final _qb_close =
      _qb_closePtr.asFunction<int Function(ffi.Pointer<OBX_query_builder>)>();

  /// @returns the entity type ID that was used to construct the query builder.
  int qb_type_id(
    ffi.Pointer<OBX_query_builder> builder,
  ) {
    return _qb_type_id(
      builder,
    );
  }

  late final _qb_type_idPtr = _lookup<
      ffi.NativeFunction<
          obx_schema_id Function(
              ffi.Pointer<OBX_query_builder>)>>('obx_qb_type_id');
  late final _qb_type_id =
      _qb_type_idPtr.asFunction<int Function(ffi.Pointer<OBX_query_builder>)>();

  /// To minimise the amount of error handling code required when building a query, the first error is stored in the query
  /// and can be obtained here. All the obx_qb_XXX functions are null operations after the first query error has occurred.
  int qb_error_code(
    ffi.Pointer<OBX_query_builder> builder,
  ) {
    return _qb_error_code(
      builder,
    );
  }

  late final _qb_error_codePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_query_builder>)>>(
      'obx_qb_error_code');
  late final _qb_error_code = _qb_error_codePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>)>();

  /// To minimise the amount of error handling code required when building a query, the first error is stored in the query
  /// and can be obtained here. All the obx_qb_XXX functions are null operations after the first query error has occurred.
  ffi.Pointer<ffi.Char> qb_error_message(
    ffi.Pointer<OBX_query_builder> builder,
  ) {
    return _qb_error_message(
      builder,
    );
  }

  late final _qb_error_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<OBX_query_builder>)>>('obx_qb_error_message');
  late final _qb_error_message = _qb_error_messagePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_query_builder>)>();

  /// Add null check to the query
  int qb_null(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
  ) {
    return _qb_null(
      builder,
      property_id,
    );
  }

  late final _qb_nullPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>, obx_schema_id)>>('obx_qb_null');
  late final _qb_null = _qb_nullPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int)>();

  /// Add not-null check to the query
  int qb_not_null(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
  ) {
    return _qb_not_null(
      builder,
      property_id,
    );
  }

  late final _qb_not_nullPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>,
              obx_schema_id)>>('obx_qb_not_null');
  late final _qb_not_null = _qb_not_nullPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int)>();

  /// For string and flex properties, this looks for a value equal to the given one.
  int qb_equals_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_equals_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_equals_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_equals_string');
  late final _qb_equals_string = _qb_equals_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_not_equals_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_not_equals_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_not_equals_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_not_equals_string');
  late final _qb_not_equals_string = _qb_not_equals_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_contains_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_contains_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_contains_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_contains_string');
  late final _qb_contains_string = _qb_contains_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  /// For container types (e.g. string vector or flex), this looks for a element that equals the given string.
  int qb_contains_element_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_contains_element_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_contains_element_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_contains_element_string');
  late final _qb_contains_element_string =
      _qb_contains_element_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, bool)>();

  /// @Deprecated use obx_qb_equals_key_value_string instead
  int qb_contains_key_value_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_contains_key_value_string(
      builder,
      property_id,
      key,
      value,
      case_sensitive,
    );
  }

  late final _qb_contains_key_value_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_contains_key_value_string');
  late final _qb_contains_key_value_string =
      _qb_contains_key_value_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must equal this one.
  /// @param case_sensitive if true, the value's match is case-sensitive, otherwise case-insensitive.
  int qb_equals_key_value_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_equals_key_value_string(
      builder,
      property_id,
      key,
      value,
      case_sensitive,
    );
  }

  late final _qb_equals_key_value_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_equals_key_value_string');
  late final _qb_equals_key_value_string =
      _qb_equals_key_value_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must equal this one.
  int qb_equals_key_value_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _qb_equals_key_value_int(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_equals_key_value_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('obx_qb_equals_key_value_int');
  late final _qb_equals_key_value_int = _qb_equals_key_value_intPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, int)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must equal this one.
  int qb_equals_key_value_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _qb_equals_key_value_double(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_equals_key_value_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Double)>>('obx_qb_equals_key_value_double');
  late final _qb_equals_key_value_double =
      _qb_equals_key_value_doublePtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, double)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being greater than the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be greater than this one.
  /// @param case_sensitive if true, the value's match is case-sensitive, otherwise case-insensitive.
  int qb_greater_key_value_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_greater_key_value_string(
      builder,
      property_id,
      key,
      value,
      case_sensitive,
    );
  }

  late final _qb_greater_key_value_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_greater_key_value_string');
  late final _qb_greater_key_value_string =
      _qb_greater_key_value_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being greater than the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be greater than this one.
  int qb_greater_key_value_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _qb_greater_key_value_int(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_greater_key_value_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('obx_qb_greater_key_value_int');
  late final _qb_greater_key_value_int =
      _qb_greater_key_value_intPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, int)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being greater than the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be greater than this one.
  int qb_greater_key_value_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _qb_greater_key_value_double(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_greater_key_value_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Double)>>('obx_qb_greater_key_value_double');
  late final _qb_greater_key_value_double =
      _qb_greater_key_value_doublePtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, double)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being greater than or equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be greater than or equal to this one.
  /// @param case_sensitive if true, the value's match is case-sensitive, otherwise case-insensitive.
  int qb_greater_or_equal_key_value_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_greater_or_equal_key_value_string(
      builder,
      property_id,
      key,
      value,
      case_sensitive,
    );
  }

  late final _qb_greater_or_equal_key_value_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_greater_or_equal_key_value_string');
  late final _qb_greater_or_equal_key_value_string =
      _qb_greater_or_equal_key_value_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being greater than or equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be greater than or equal to this one.
  int qb_greater_or_equal_key_value_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _qb_greater_or_equal_key_value_int(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_greater_or_equal_key_value_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('obx_qb_greater_or_equal_key_value_int');
  late final _qb_greater_or_equal_key_value_int =
      _qb_greater_or_equal_key_value_intPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, int)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being greater than or equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be greater than or equal to this one.
  int qb_greater_or_equal_key_value_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _qb_greater_or_equal_key_value_double(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_greater_or_equal_key_value_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Double)>>('obx_qb_greater_or_equal_key_value_double');
  late final _qb_greater_or_equal_key_value_double =
      _qb_greater_or_equal_key_value_doublePtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, double)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being lesser than the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be lesser than this one.
  /// @param case_sensitive if true, the value's match is case-sensitive, otherwise case-insensitive.
  int qb_less_than_key_value_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_less_than_key_value_string(
      builder,
      property_id,
      key,
      value,
      case_sensitive,
    );
  }

  late final _qb_less_than_key_value_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_less_than_key_value_string');
  late final _qb_less_than_key_value_string =
      _qb_less_than_key_value_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being lesser than the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be lesser than this one.
  int qb_less_than_key_value_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _qb_less_than_key_value_int(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_less_than_key_value_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('obx_qb_less_than_key_value_int');
  late final _qb_less_than_key_value_int =
      _qb_less_than_key_value_intPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, int)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being lesser than the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be lesser than this one.
  int qb_less_than_key_value_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _qb_less_than_key_value_double(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_less_than_key_value_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Double)>>('obx_qb_less_than_key_value_double');
  late final _qb_less_than_key_value_double =
      _qb_less_than_key_value_doublePtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, double)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being lesser than or equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be lesser than or equal to this one.
  /// @param case_sensitive if true, the value's match is case-sensitive, otherwise case-insensitive.
  int qb_less_or_equal_key_value_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_less_or_equal_key_value_string(
      builder,
      property_id,
      key,
      value,
      case_sensitive,
    );
  }

  late final _qb_less_or_equal_key_value_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_less_or_equal_key_value_string');
  late final _qb_less_or_equal_key_value_string =
      _qb_less_or_equal_key_value_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, bool)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being lesser than or equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be lesser than or equal to this one.
  int qb_less_or_equal_key_value_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    int value,
  ) {
    return _qb_less_or_equal_key_value_int(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_less_or_equal_key_value_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('obx_qb_less_or_equal_key_value_int');
  late final _qb_less_or_equal_key_value_int =
      _qb_less_or_equal_key_value_intPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, int)>();

  /// For flex properties that have a map as root value, this looks for a matching key/value pair,
  /// with the map value being lesser than or equal to the given one.
  /// @param key must be an exact match exactly (case-sensitive)
  /// @param value the map's value must be lesser than or equal to this one.
  int qb_less_or_equal_key_value_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> key,
    double value,
  ) {
    return _qb_less_or_equal_key_value_double(
      builder,
      property_id,
      key,
      value,
    );
  }

  late final _qb_less_or_equal_key_value_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Double)>>('obx_qb_less_or_equal_key_value_double');
  late final _qb_less_or_equal_key_value_double =
      _qb_less_or_equal_key_value_doublePtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, double)>();

  int qb_starts_with_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_starts_with_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_starts_with_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_starts_with_string');
  late final _qb_starts_with_string = _qb_starts_with_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_ends_with_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_ends_with_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_ends_with_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_ends_with_string');
  late final _qb_ends_with_string = _qb_ends_with_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_greater_than_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_greater_than_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_greater_than_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_greater_than_string');
  late final _qb_greater_than_string = _qb_greater_than_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_greater_or_equal_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_greater_or_equal_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_greater_or_equal_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_qb_greater_or_equal_string');
  late final _qb_greater_or_equal_string =
      _qb_greater_or_equal_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Char>, bool)>();

  int qb_less_than_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_less_than_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_less_than_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_less_than_string');
  late final _qb_less_than_string = _qb_less_than_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_less_or_equal_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_less_or_equal_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_less_or_equal_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_less_or_equal_string');
  late final _qb_less_or_equal_string = _qb_less_or_equal_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  /// Note that all string values are copied and thus do not need to be maintained by the calling code.
  int qb_in_strings(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Pointer<ffi.Char>> values,
    int count,
    bool case_sensitive,
  ) {
    return _qb_in_strings(
      builder,
      property_id,
      values,
      count,
      case_sensitive,
    );
  }

  late final _qb_in_stringsPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size,
              ffi.Bool)>>('obx_qb_in_strings');
  late final _qb_in_strings = _qb_in_stringsPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_builder>, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, int, bool)>();

  /// @deprecated Please use obx_qb_contains_element_string() instead.
  int qb_any_equals_string(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    bool case_sensitive,
  ) {
    return _qb_any_equals_string(
      builder,
      property_id,
      value,
      case_sensitive,
    );
  }

  late final _qb_any_equals_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Char>, ffi.Bool)>>('obx_qb_any_equals_string');
  late final _qb_any_equals_string = _qb_any_equals_stringPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Char>, bool)>();

  int qb_equals_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value,
  ) {
    return _qb_equals_int(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_equals_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64)>>('obx_qb_equals_int');
  late final _qb_equals_int = _qb_equals_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  int qb_not_equals_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value,
  ) {
    return _qb_not_equals_int(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_not_equals_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64)>>('obx_qb_not_equals_int');
  late final _qb_not_equals_int = _qb_not_equals_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  int qb_greater_than_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value,
  ) {
    return _qb_greater_than_int(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_greater_than_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64)>>('obx_qb_greater_than_int');
  late final _qb_greater_than_int = _qb_greater_than_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  int qb_greater_or_equal_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value,
  ) {
    return _qb_greater_or_equal_int(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_greater_or_equal_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64)>>('obx_qb_greater_or_equal_int');
  late final _qb_greater_or_equal_int = _qb_greater_or_equal_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  int qb_less_than_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value,
  ) {
    return _qb_less_than_int(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_less_than_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64)>>('obx_qb_less_than_int');
  late final _qb_less_than_int = _qb_less_than_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  int qb_less_or_equal_int(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value,
  ) {
    return _qb_less_or_equal_int(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_less_or_equal_intPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64)>>('obx_qb_less_or_equal_int');
  late final _qb_less_or_equal_int = _qb_less_or_equal_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  int qb_between_2ints(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int value_a,
    int value_b,
  ) {
    return _qb_between_2ints(
      builder,
      property_id,
      value_a,
      value_b,
    );
  }

  late final _qb_between_2intsPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Int64, ffi.Int64)>>('obx_qb_between_2ints');
  late final _qb_between_2ints = _qb_between_2intsPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_builder>, int, int, int)>();

  /// Note that all values are copied and thus do not need to be maintained by the calling code.
  int qb_in_int64s(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Int64> values,
    int count,
  ) {
    return _qb_in_int64s(
      builder,
      property_id,
      values,
      count,
    );
  }

  late final _qb_in_int64sPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Int64>, ffi.Size)>>('obx_qb_in_int64s');
  late final _qb_in_int64s = _qb_in_int64sPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Int64>, int)>();

  /// Note that all values are copied and thus do not need to be maintained by the calling code.
  int qb_not_in_int64s(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Int64> values,
    int count,
  ) {
    return _qb_not_in_int64s(
      builder,
      property_id,
      values,
      count,
    );
  }

  late final _qb_not_in_int64sPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Int64>, ffi.Size)>>('obx_qb_not_in_int64s');
  late final _qb_not_in_int64s = _qb_not_in_int64sPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Int64>, int)>();

  /// Note that all values are copied and thus do not need to be maintained by the calling code.
  int qb_in_int32s(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Int32> values,
    int count,
  ) {
    return _qb_in_int32s(
      builder,
      property_id,
      values,
      count,
    );
  }

  late final _qb_in_int32sPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Int32>, ffi.Size)>>('obx_qb_in_int32s');
  late final _qb_in_int32s = _qb_in_int32sPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Int32>, int)>();

  /// Note that all values are copied and thus do not need to be maintained by the calling code.
  int qb_not_in_int32s(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Int32> values,
    int count,
  ) {
    return _qb_not_in_int32s(
      builder,
      property_id,
      values,
      count,
    );
  }

  late final _qb_not_in_int32sPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Int32>, ffi.Size)>>('obx_qb_not_in_int32s');
  late final _qb_not_in_int32s = _qb_not_in_int32sPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Int32>, int)>();

  int qb_greater_than_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    double value,
  ) {
    return _qb_greater_than_double(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_greater_than_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Double)>>('obx_qb_greater_than_double');
  late final _qb_greater_than_double = _qb_greater_than_doublePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, double)>();

  int qb_greater_or_equal_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    double value,
  ) {
    return _qb_greater_or_equal_double(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_greater_or_equal_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Double)>>('obx_qb_greater_or_equal_double');
  late final _qb_greater_or_equal_double = _qb_greater_or_equal_doublePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, double)>();

  int qb_less_than_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    double value,
  ) {
    return _qb_less_than_double(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_less_than_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Double)>>('obx_qb_less_than_double');
  late final _qb_less_than_double = _qb_less_than_doublePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, double)>();

  int qb_less_or_equal_double(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    double value,
  ) {
    return _qb_less_or_equal_double(
      builder,
      property_id,
      value,
    );
  }

  late final _qb_less_or_equal_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Double)>>('obx_qb_less_or_equal_double');
  late final _qb_less_or_equal_double = _qb_less_or_equal_doublePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, double)>();

  int qb_between_2doubles(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    double value_a,
    double value_b,
  ) {
    return _qb_between_2doubles(
      builder,
      property_id,
      value_a,
      value_b,
    );
  }

  late final _qb_between_2doublesPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Double, ffi.Double)>>('obx_qb_between_2doubles');
  late final _qb_between_2doubles = _qb_between_2doublesPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_builder>, int, double, double)>();

  int qb_equals_bytes(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _qb_equals_bytes(
      builder,
      property_id,
      value,
      size,
    );
  }

  late final _qb_equals_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_qb_equals_bytes');
  late final _qb_equals_bytes = _qb_equals_bytesPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Uint8>, int)>();

  int qb_greater_than_bytes(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _qb_greater_than_bytes(
      builder,
      property_id,
      value,
      size,
    );
  }

  late final _qb_greater_than_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_qb_greater_than_bytes');
  late final _qb_greater_than_bytes = _qb_greater_than_bytesPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Uint8>, int)>();

  int qb_greater_or_equal_bytes(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _qb_greater_or_equal_bytes(
      builder,
      property_id,
      value,
      size,
    );
  }

  late final _qb_greater_or_equal_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_qb_greater_or_equal_bytes');
  late final _qb_greater_or_equal_bytes =
      _qb_greater_or_equal_bytesPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Uint8>, int)>();

  int qb_less_than_bytes(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _qb_less_than_bytes(
      builder,
      property_id,
      value,
      size,
    );
  }

  late final _qb_less_than_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_qb_less_than_bytes');
  late final _qb_less_than_bytes = _qb_less_than_bytesPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Uint8>, int)>();

  int qb_less_or_equal_bytes(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _qb_less_or_equal_bytes(
      builder,
      property_id,
      value,
      size,
    );
  }

  late final _qb_less_or_equal_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_qb_less_or_equal_bytes');
  late final _qb_less_or_equal_bytes = _qb_less_or_equal_bytesPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// An object matches, if it has a given number of related objects pointing to it.
  /// At this point, there are a couple of limitations (later version may improve on that):
  /// 1) 1:N relations only, 2) the complexity is O(n * (relationCount + 1)) and cannot be improved via indexes,
  /// 3) The relation count cannot be set as an parameter.
  /// @param relation_entity_id ID of the entity type the relation comes from.
  /// @param relation_property_id ID of the property in the related entity type representing the relation.
  /// @param relation_count Number of related object an object must have to match. May be 0 if objects shall be matched
  /// that do not have related objects. (Typically low numbers are used for the count.)
  int qb_relation_count_property(
    ffi.Pointer<OBX_query_builder> builder,
    int relation_entity_id,
    int relation_property_id,
    int relation_count,
  ) {
    return _qb_relation_count_property(
      builder,
      relation_entity_id,
      relation_property_id,
      relation_count,
    );
  }

  late final _qb_relation_count_propertyPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              obx_schema_id, ffi.Uint32)>>('obx_qb_relation_count_property');
  late final _qb_relation_count_property =
      _qb_relation_count_propertyPtr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int, int, int)>();

  /// Combine conditions[] to a new condition using operator AND (all).
  int qb_all(
    ffi.Pointer<OBX_query_builder> builder,
    ffi.Pointer<obx_qb_cond> conditions,
    int count,
  ) {
    return _qb_all(
      builder,
      conditions,
      count,
    );
  }

  late final _qb_allPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>,
              ffi.Pointer<obx_qb_cond>, ffi.Size)>>('obx_qb_all');
  late final _qb_all = _qb_allPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, ffi.Pointer<obx_qb_cond>, int)>();

  /// Combine conditions[] to a new condition using operator OR (any).
  int qb_any(
    ffi.Pointer<OBX_query_builder> builder,
    ffi.Pointer<obx_qb_cond> conditions,
    int count,
  ) {
    return _qb_any(
      builder,
      conditions,
      count,
    );
  }

  late final _qb_anyPtr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(ffi.Pointer<OBX_query_builder>,
              ffi.Pointer<obx_qb_cond>, ffi.Size)>>('obx_qb_any');
  late final _qb_any = _qb_anyPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query_builder>, ffi.Pointer<obx_qb_cond>, int)>();

  /// Create an alias for the previous condition (the one added just before calling this function).
  /// This is useful when you have a query with multiple conditions of the same property (e.g. height < 20 or height > 50)
  /// and you want to use obx_query_param_* to change the values. Consider the following simplified example.
  ///
  /// **Example:** Create a query with two aliased params and set their values later during query execution:
  ///
  /// OBX_query_builder* qb = obx_query_builder(store, entity_id);
  /// obx_qb_less_than_int(qb, height_prop_id, 0)
  /// obx_qb_param_alias(qb, "height-lt")
  /// obx_qb_greater_than_int(qb, height_prop_id, 0)
  /// obx_qb_param_alias(qb, "height-gt")
  /// OBX_query* query = obx_query(OBX_query_builder* qb);
  /// ...
  /// obx_query_param_alias_int(query, "height-lt", 20)
  /// obx_query_param_alias_int(query, "height-gt", 50)
  /// OBX_bytes_array* results = obx_query_find(query)
  /// obx_query_param_alias_int(query, "height-lt", 100)
  /// obx_query_param_alias_int(query, "height-gt", 500)
  /// OBX_bytes_array* results2 = obx_query_find(query)
  /// @param alias any non-empty string
  int qb_param_alias(
    ffi.Pointer<OBX_query_builder> builder,
    ffi.Pointer<ffi.Char> alias,
  ) {
    return _qb_param_alias(
      builder,
      alias,
    );
  }

  late final _qb_param_aliasPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_builder>,
              ffi.Pointer<ffi.Char>)>>('obx_qb_param_alias');
  late final _qb_param_alias = _qb_param_aliasPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_builder>, ffi.Pointer<ffi.Char>)>();

  /// Configures an order of results in the query
  int qb_order(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
    int flags,
  ) {
    return _qb_order(
      builder,
      property_id,
      flags,
    );
  }

  late final _qb_orderPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_builder>, obx_schema_id,
              ffi.Uint32)>>('obx_qb_order');
  late final _qb_order = _qb_orderPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_builder>, int, int)>();

  /// Create a link based on a property-relation (many-to-one)
  ffi.Pointer<OBX_query_builder> qb_link_property(
    ffi.Pointer<OBX_query_builder> builder,
    int property_id,
  ) {
    return _qb_link_property(
      builder,
      property_id,
    );
  }

  late final _qb_link_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_builder> Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id)>>('obx_qb_link_property');
  late final _qb_link_property = _qb_link_propertyPtr.asFunction<
      ffi.Pointer<OBX_query_builder> Function(
          ffi.Pointer<OBX_query_builder>, int)>();

  /// Create a backlink based on a property-relation used in reverse (one-to-many)
  ffi.Pointer<OBX_query_builder> qb_backlink_property(
    ffi.Pointer<OBX_query_builder> builder,
    int source_entity_id,
    int source_property_id,
  ) {
    return _qb_backlink_property(
      builder,
      source_entity_id,
      source_property_id,
    );
  }

  late final _qb_backlink_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_builder> Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              obx_schema_id)>>('obx_qb_backlink_property');
  late final _qb_backlink_property = _qb_backlink_propertyPtr.asFunction<
      ffi.Pointer<OBX_query_builder> Function(
          ffi.Pointer<OBX_query_builder>, int, int)>();

  /// Create a link based on a standalone relation (many-to-many)
  ffi.Pointer<OBX_query_builder> qb_link_standalone(
    ffi.Pointer<OBX_query_builder> builder,
    int relation_id,
  ) {
    return _qb_link_standalone(
      builder,
      relation_id,
    );
  }

  late final _qb_link_standalonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_builder> Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id)>>('obx_qb_link_standalone');
  late final _qb_link_standalone = _qb_link_standalonePtr.asFunction<
      ffi.Pointer<OBX_query_builder> Function(
          ffi.Pointer<OBX_query_builder>, int)>();

  /// Create a backlink based on a standalone relation (many-to-many, reverse direction)
  ffi.Pointer<OBX_query_builder> qb_backlink_standalone(
    ffi.Pointer<OBX_query_builder> builder,
    int relation_id,
  ) {
    return _qb_backlink_standalone(
      builder,
      relation_id,
    );
  }

  late final _qb_backlink_standalonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_builder> Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id)>>('obx_qb_backlink_standalone');
  late final _qb_backlink_standalone = _qb_backlink_standalonePtr.asFunction<
      ffi.Pointer<OBX_query_builder> Function(
          ffi.Pointer<OBX_query_builder>, int)>();

  /// Link the (time series) entity type to another entity space using a time point or range defined in the given
  /// linked entity type and properties.
  /// Note: time series functionality must be available to use this.
  /// @param linked_entity_id Entity type that defines a time point or range
  /// @param begin_property_id Property of the linked entity defining a time point or the begin of a time range.
  /// Must be a date type (e.g. PropertyType_Date or PropertyType_DateNano).
  /// @param end_property_id Optional property of the linked entity defining the end of a time range.
  /// Pass zero to only define a time point (begin_property_id).
  /// Must be a date type (e.g. PropertyType_Date or PropertyType_DateNano).
  ffi.Pointer<OBX_query_builder> qb_link_time(
    ffi.Pointer<OBX_query_builder> builder,
    int linked_entity_id,
    int begin_property_id,
    int end_property_id,
  ) {
    return _qb_link_time(
      builder,
      linked_entity_id,
      begin_property_id,
      end_property_id,
    );
  }

  late final _qb_link_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_builder> Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              obx_schema_id,
              obx_schema_id)>>('obx_qb_link_time');
  late final _qb_link_time = _qb_link_timePtr.asFunction<
      ffi.Pointer<OBX_query_builder> Function(
          ffi.Pointer<OBX_query_builder>, int, int, int)>();

  /// Performs an approximate nearest neighbor (ANN) search to find objects near to the given query_vector.
  /// This requires the vector property to have a HNSW index.
  /// @param vector_property_id the vector property ID of the entity
  /// @param query_vector the query vector; its dimensions should be at least the dimensions of the vector property.
  /// @param max_result_count maximum number of objects to return by the ANN condition.
  /// Hint: it can also be used as the "ef" HNSW parameter to increase the search quality in combination with a
  /// query limit.
  /// For example, use 100 here with a query limit of 10 to have 10 results that are of potentially better quality
  /// than just passing in 10 here (quality/performance tradeoff).
  int qb_nearest_neighbors_f32(
    ffi.Pointer<OBX_query_builder> builder,
    int vector_property_id,
    ffi.Pointer<ffi.Float> query_vector,
    int max_result_count,
  ) {
    return _qb_nearest_neighbors_f32(
      builder,
      vector_property_id,
      query_vector,
      max_result_count,
    );
  }

  late final _qb_nearest_neighbors_f32Ptr = _lookup<
      ffi.NativeFunction<
          obx_qb_cond Function(
              ffi.Pointer<OBX_query_builder>,
              obx_schema_id,
              ffi.Pointer<ffi.Float>,
              ffi.Size)>>('obx_qb_nearest_neighbors_f32');
  late final _qb_nearest_neighbors_f32 =
      _qb_nearest_neighbors_f32Ptr.asFunction<
          int Function(ffi.Pointer<OBX_query_builder>, int,
              ffi.Pointer<ffi.Float>, int)>();

  /// Builds a query from the given query builder (with the query conditions previously called on the query builder).
  /// Note: this does not release the query builder, you still need to call obx_qb_close() on it.
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_query> query(
    ffi.Pointer<OBX_query_builder> builder,
  ) {
    return _query(
      builder,
    );
  }

  late final _queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query> Function(
              ffi.Pointer<OBX_query_builder>)>>('obx_query');
  late final _query = _queryPtr.asFunction<
      ffi.Pointer<OBX_query> Function(ffi.Pointer<OBX_query_builder>)>();

  /// Close the query and free resources.
  int query_close(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_close(
      query,
    );
  }

  late final _query_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_query>)>>(
          'obx_query_close');
  late final _query_close =
      _query_closePtr.asFunction<int Function(ffi.Pointer<OBX_query>)>();

  /// Create a clone of the given query such that it can be run on a separate thread
  ffi.Pointer<OBX_query> query_clone(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_clone(
      query,
    );
  }

  late final _query_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_clone');
  late final _query_clone = _query_clonePtr
      .asFunction<ffi.Pointer<OBX_query> Function(ffi.Pointer<OBX_query>)>();

  /// Configure an offset for this query - all methods that support offset will return/process objects starting at this
  /// offset. Example use case: use together with limit to get a slice of the whole result, e.g. for "result paging".
  /// Call with offset=0 to reset to the default behavior, i.e. starting from the first element.
  int query_offset(
    ffi.Pointer<OBX_query> query,
    int offset,
  ) {
    return _query_offset(
      query,
      offset,
    );
  }

  late final _query_offsetPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_query>, ffi.Size)>>(
      'obx_query_offset');
  late final _query_offset =
      _query_offsetPtr.asFunction<int Function(ffi.Pointer<OBX_query>, int)>();

  /// Configure an offset and a limit for this query - all methods that support an offset/limit will return/process
  /// objects starting at this offset and up to the given limit. Example use case: get a slice of the whole result, e.g.
  /// for "result paging". Call with offset/limit=0 to reset to the default behavior, i.e. starting from the first element
  /// without limit.
  int query_offset_limit(
    ffi.Pointer<OBX_query> query,
    int offset,
    int limit,
  ) {
    return _query_offset_limit(
      query,
      offset,
      limit,
    );
  }

  late final _query_offset_limitPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Size,
              ffi.Size)>>('obx_query_offset_limit');
  late final _query_offset_limit = _query_offset_limitPtr
      .asFunction<int Function(ffi.Pointer<OBX_query>, int, int)>();

  /// Configure a limit for this query - all methods that support limit will return/process only the given number of
  /// objects. Example use case: use together with offset to get a slice of the whole result, e.g. for "result paging".
  /// Call with limit=0 to reset to the default behavior - zero limit means no limit applied.
  int query_limit(
    ffi.Pointer<OBX_query> query,
    int limit,
  ) {
    return _query_limit(
      query,
      limit,
    );
  }

  late final _query_limitPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_query>, ffi.Size)>>(
      'obx_query_limit');
  late final _query_limit =
      _query_limitPtr.asFunction<int Function(ffi.Pointer<OBX_query>, int)>();

  /// Find objects matching the query.
  /// NOTE: You must use an explicit transaction and the returned data is only valid as long the transaction is active!
  /// Note: if no order conditions is present, the order is arbitrary (sometimes ordered by ID, but never guaranteed to).
  ffi.Pointer<OBX_bytes_array> query_find(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_find(
      query,
    );
  }

  late final _query_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_array> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_find');
  late final _query_find = _query_findPtr.asFunction<
      ffi.Pointer<OBX_bytes_array> Function(ffi.Pointer<OBX_query>)>();

  /// Find objects matching the query associated to their query score (e.g. distance in NN search).
  /// The resulting array is sorted by score in ascending order (unlike obx_query_find()).
  ffi.Pointer<OBX_bytes_score_array> query_find_with_scores(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_find_with_scores(
      query,
    );
  }

  late final _query_find_with_scoresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_score_array> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_find_with_scores');
  late final _query_find_with_scores = _query_find_with_scoresPtr.asFunction<
      ffi.Pointer<OBX_bytes_score_array> Function(ffi.Pointer<OBX_query>)>();

  /// Find object IDs matching the query associated to their query score (e.g. distance in NN search).
  /// The resulting array is sorted by score in ascending order (unlike obx_query_find_ids()).
  ffi.Pointer<OBX_id_score_array> query_find_ids_with_scores(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_find_ids_with_scores(
      query,
    );
  }

  late final _query_find_ids_with_scoresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_score_array> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_find_ids_with_scores');
  late final _query_find_ids_with_scores =
      _query_find_ids_with_scoresPtr.asFunction<
          ffi.Pointer<OBX_id_score_array> Function(ffi.Pointer<OBX_query>)>();

  /// Find object IDs matching the query ordered by their query score (e.g. distance in NN search).
  /// The resulting array is sorted by score in ascending order (unlike obx_query_find_ids()).
  /// Unlike obx_query_find_ids_with_scores(), this method returns a simple array of IDs without scores.
  ffi.Pointer<OBX_id_array> query_find_ids_by_score(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_find_ids_by_score(
      query,
    );
  }

  late final _query_find_ids_by_scorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_find_ids_by_score');
  late final _query_find_ids_by_score = _query_find_ids_by_scorePtr
      .asFunction<ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_query>)>();

  /// Find the first object matching the query.
  /// @returns OBX_NOT_FOUND if no object matches.
  /// The exposed data comes directly from the OS to allow zero-copy access, which limits the data lifetime:
  /// @warning Currently ignores offset, taking the the first matching element.
  /// @attention The exposed data is only valid as long as the (top) transaction is still active and no write
  /// operation (e.g. put/remove) was executed. Accessing data after this is undefined behavior.
  int query_find_first(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _query_find_first(
      query,
      data,
      size,
    );
  }

  late final _query_find_firstPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_query_find_first');
  late final _query_find_first = _query_find_firstPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>)>();

  /// Find the only object matching the query.
  /// @returns OBX_NOT_FOUND if no object matches, an error if there are multiple objects matching the query.
  /// The exposed data comes directly from the OS to allow zero-copy access, which limits the data lifetime:
  /// @warning Currently ignores offset and limit, considering all matching elements.
  /// @attention The exposed data is only valid as long as the (top) transaction is still active and no write
  /// operation (e.g. put/remove) was executed. Accessing data after this is undefined behavior.
  int query_find_unique(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _query_find_unique(
      query,
      data,
      size,
    );
  }

  late final _query_find_uniquePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_query_find_unique');
  late final _query_find_unique = _query_find_uniquePtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>)>();

  /// Walk over matching objects one-by-one using the given data visitor (a callback function).
  /// Note: if no order conditions is present, the order is arbitrary (sometimes ordered by ID, but never guaranteed to).
  int query_visit(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<obx_data_visitor> visitor,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _query_visit(
      query,
      visitor,
      user_data,
    );
  }

  late final _query_visitPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<obx_data_visitor>,
              ffi.Pointer<ffi.Void>)>>('obx_query_visit');
  late final _query_visit = _query_visitPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<obx_data_visitor>,
          ffi.Pointer<ffi.Void>)>();

  /// Walk over matching objects with their query score one-by-one using the given data visitor (a callback function).
  /// Note: the elements are ordered by the score (ascending).
  int query_visit_with_score(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<obx_data_score_visitor> visitor,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _query_visit_with_score(
      query,
      visitor,
      user_data,
    );
  }

  late final _query_visit_with_scorePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<obx_data_score_visitor>,
              ffi.Pointer<ffi.Void>)>>('obx_query_visit_with_score');
  late final _query_visit_with_score = _query_visit_with_scorePtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<obx_data_score_visitor>,
          ffi.Pointer<ffi.Void>)>();

  /// Return the IDs of all matching objects.
  /// Note: if no order conditions is present, the order is arbitrary (sometimes ordered by ID, but never guaranteed to).
  ffi.Pointer<OBX_id_array> query_find_ids(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_find_ids(
      query,
    );
  }

  late final _query_find_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_find_ids');
  late final _query_find_ids = _query_find_idsPtr
      .asFunction<ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_query>)>();

  /// Return the number of matching objects
  int query_count(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _query_count(
      query,
      out_count,
    );
  }

  late final _query_countPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Uint64>)>>('obx_query_count');
  late final _query_count = _query_countPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Uint64>)>();

  /// Remove all matching objects from the database & return the number of deleted objects
  int query_remove(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _query_remove(
      query,
      out_count,
    );
  }

  late final _query_removePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Uint64>)>>('obx_query_remove');
  late final _query_remove = _query_removePtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Uint64>)>();

  /// The returned char* is valid until another call to describe() is made on the query or until the query is freed
  ffi.Pointer<ffi.Char> query_describe(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_describe(
      query,
    );
  }

  late final _query_describePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_describe');
  late final _query_describe = _query_describePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_query>)>();

  /// The returned char* is valid until another call to describe_params() is made on the query or until the query is freed
  ffi.Pointer<ffi.Char> query_describe_params(
    ffi.Pointer<OBX_query> query,
  ) {
    return _query_describe_params(
      query,
    );
  }

  late final _query_describe_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<OBX_query>)>>('obx_query_describe_params');
  late final _query_describe_params = _query_describe_paramsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_query>)>();

  int query_cursor_visit(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<obx_data_visitor> visitor,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _query_cursor_visit(
      query,
      cursor,
      visitor,
      user_data,
    );
  }

  late final _query_cursor_visitPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<OBX_cursor>,
              ffi.Pointer<obx_data_visitor>,
              ffi.Pointer<ffi.Void>)>>('obx_query_cursor_visit');
  late final _query_cursor_visit = _query_cursor_visitPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>,
          ffi.Pointer<obx_data_visitor>, ffi.Pointer<ffi.Void>)>();

  /// Find entities matching the query; NOTE: the returned data is only valid as long the transaction is active!
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_bytes_array> query_cursor_find(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<OBX_cursor> cursor,
  ) {
    return _query_cursor_find(
      query,
      cursor,
    );
  }

  late final _query_cursor_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_bytes_array> Function(ffi.Pointer<OBX_query>,
              ffi.Pointer<OBX_cursor>)>>('obx_query_cursor_find');
  late final _query_cursor_find = _query_cursor_findPtr.asFunction<
      ffi.Pointer<OBX_bytes_array> Function(
          ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>)>();

  ffi.Pointer<OBX_id_array> query_cursor_find_ids(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<OBX_cursor> cursor,
  ) {
    return _query_cursor_find_ids(
      query,
      cursor,
    );
  }

  late final _query_cursor_find_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(ffi.Pointer<OBX_query>,
              ffi.Pointer<OBX_cursor>)>>('obx_query_cursor_find_ids');
  late final _query_cursor_find_ids = _query_cursor_find_idsPtr.asFunction<
      ffi.Pointer<OBX_id_array> Function(
          ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>)>();

  int query_cursor_count(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _query_cursor_count(
      query,
      cursor,
      out_count,
    );
  }

  late final _query_cursor_countPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Uint64>)>>('obx_query_cursor_count');
  late final _query_cursor_count = _query_cursor_countPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>,
          ffi.Pointer<ffi.Uint64>)>();

  /// Remove (delete!) all matching objects.
  int query_cursor_remove(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<OBX_cursor> cursor,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _query_cursor_remove(
      query,
      cursor,
      out_count,
    );
  }

  late final _query_cursor_removePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>,
              ffi.Pointer<ffi.Uint64>)>>('obx_query_cursor_remove');
  late final _query_cursor_remove = _query_cursor_removePtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<OBX_cursor>,
          ffi.Pointer<ffi.Uint64>)>();

  int query_param_string(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _query_param_string(
      query,
      entity_id,
      property_id,
      value,
    );
  }

  late final _query_param_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Pointer<ffi.Char>)>>('obx_query_param_string');
  late final _query_param_string = _query_param_stringPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, int, int, ffi.Pointer<ffi.Char>)>();

  int query_param_2strings(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Char> value,
    ffi.Pointer<ffi.Char> value2,
  ) {
    return _query_param_2strings(
      query,
      entity_id,
      property_id,
      value,
      value2,
    );
  }

  late final _query_param_2stringsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              obx_schema_id,
              obx_schema_id,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('obx_query_param_2strings');
  late final _query_param_2strings = _query_param_2stringsPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int query_param_strings(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Pointer<ffi.Char>> values,
    int count,
  ) {
    return _query_param_strings(
      query,
      entity_id,
      property_id,
      values,
      count,
    );
  }

  late final _query_param_stringsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              obx_schema_id,
              obx_schema_id,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size)>>('obx_query_param_strings');
  late final _query_param_strings = _query_param_stringsPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int query_param_int(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    int value,
  ) {
    return _query_param_int(
      query,
      entity_id,
      property_id,
      value,
    );
  }

  late final _query_param_intPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Int64)>>('obx_query_param_int');
  late final _query_param_int = _query_param_intPtr
      .asFunction<int Function(ffi.Pointer<OBX_query>, int, int, int)>();

  int query_param_2ints(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    int value_a,
    int value_b,
  ) {
    return _query_param_2ints(
      query,
      entity_id,
      property_id,
      value_a,
      value_b,
    );
  }

  late final _query_param_2intsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Int64, ffi.Int64)>>('obx_query_param_2ints');
  late final _query_param_2ints = _query_param_2intsPtr
      .asFunction<int Function(ffi.Pointer<OBX_query>, int, int, int, int)>();

  int query_param_int64s(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Int64> values,
    int count,
  ) {
    return _query_param_int64s(
      query,
      entity_id,
      property_id,
      values,
      count,
    );
  }

  late final _query_param_int64sPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Pointer<ffi.Int64>, ffi.Size)>>('obx_query_param_int64s');
  late final _query_param_int64s = _query_param_int64sPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query>, int, int, ffi.Pointer<ffi.Int64>, int)>();

  int query_param_int32s(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Int32> values,
    int count,
  ) {
    return _query_param_int32s(
      query,
      entity_id,
      property_id,
      values,
      count,
    );
  }

  late final _query_param_int32sPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Pointer<ffi.Int32>, ffi.Size)>>('obx_query_param_int32s');
  late final _query_param_int32s = _query_param_int32sPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query>, int, int, ffi.Pointer<ffi.Int32>, int)>();

  int query_param_double(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    double value,
  ) {
    return _query_param_double(
      query,
      entity_id,
      property_id,
      value,
    );
  }

  late final _query_param_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Double)>>('obx_query_param_double');
  late final _query_param_double = _query_param_doublePtr
      .asFunction<int Function(ffi.Pointer<OBX_query>, int, int, double)>();

  int query_param_2doubles(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    double value_a,
    double value_b,
  ) {
    return _query_param_2doubles(
      query,
      entity_id,
      property_id,
      value_a,
      value_b,
    );
  }

  late final _query_param_2doublesPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Double, ffi.Double)>>('obx_query_param_2doubles');
  late final _query_param_2doubles = _query_param_2doublesPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, int, int, double, double)>();

  int query_param_bytes(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _query_param_bytes(
      query,
      entity_id,
      property_id,
      value,
      size,
    );
  }

  late final _query_param_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, obx_schema_id, obx_schema_id,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_query_param_bytes');
  late final _query_param_bytes = _query_param_bytesPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_query>, int, int, ffi.Pointer<ffi.Uint8>, int)>();

  int query_param_vector_float32(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
    ffi.Pointer<ffi.Float> value,
    int element_count,
  ) {
    return _query_param_vector_float32(
      query,
      entity_id,
      property_id,
      value,
      element_count,
    );
  }

  late final _query_param_vector_float32Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              obx_schema_id,
              obx_schema_id,
              ffi.Pointer<ffi.Float>,
              ffi.Size)>>('obx_query_param_vector_float32');
  late final _query_param_vector_float32 =
      _query_param_vector_float32Ptr.asFunction<
          int Function(
              ffi.Pointer<OBX_query>, int, int, ffi.Pointer<ffi.Float>, int)>();

  /// Gets the size of the property type used in a query condition.
  /// A typical use case of this is to allow language bindings (e.g. Swift) use the right type (e.g. 32 bit ints) even
  /// if the language has a bias towards another type (e.g. 64 bit ints).
  /// @returns the size of the underlying property
  /// @returns 0 if it does not have a fixed size (e.g. strings, vectors) or an error occurred
  int query_param_get_type_size(
    ffi.Pointer<OBX_query> query,
    int entity_id,
    int property_id,
  ) {
    return _query_param_get_type_size(
      query,
      entity_id,
      property_id,
    );
  }

  late final _query_param_get_type_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<OBX_query>, obx_schema_id,
              obx_schema_id)>>('obx_query_param_get_type_size');
  late final _query_param_get_type_size = _query_param_get_type_sizePtr
      .asFunction<int Function(ffi.Pointer<OBX_query>, int, int)>();

  int query_param_alias_string(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _query_param_alias_string(
      query,
      alias,
      value,
    );
  }

  late final _query_param_alias_stringPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('obx_query_param_alias_string');
  late final _query_param_alias_string =
      _query_param_alias_stringPtr.asFunction<
          int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  int query_param_alias_strings(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    ffi.Pointer<ffi.Pointer<ffi.Char>> values,
    int count,
  ) {
    return _query_param_alias_strings(
      query,
      alias,
      values,
      count,
    );
  }

  late final _query_param_alias_stringsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size)>>('obx_query_param_alias_strings');
  late final _query_param_alias_strings =
      _query_param_alias_stringsPtr.asFunction<
          int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int query_param_alias_int(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    int value,
  ) {
    return _query_param_alias_int(
      query,
      alias,
      value,
    );
  }

  late final _query_param_alias_intPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('obx_query_param_alias_int');
  late final _query_param_alias_int = _query_param_alias_intPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>, int)>();

  int query_param_alias_2ints(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    int value_a,
    int value_b,
  ) {
    return _query_param_alias_2ints(
      query,
      alias,
      value_a,
      value_b,
    );
  }

  late final _query_param_alias_2intsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Int64, ffi.Int64)>>('obx_query_param_alias_2ints');
  late final _query_param_alias_2ints = _query_param_alias_2intsPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>, int, int)>();

  int query_param_alias_int64s(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    ffi.Pointer<ffi.Int64> values,
    int count,
  ) {
    return _query_param_alias_int64s(
      query,
      alias,
      values,
      count,
    );
  }

  late final _query_param_alias_int64sPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int64>,
              ffi.Size)>>('obx_query_param_alias_int64s');
  late final _query_param_alias_int64s =
      _query_param_alias_int64sPtr.asFunction<
          int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int64>, int)>();

  int query_param_alias_int32s(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    ffi.Pointer<ffi.Int32> values,
    int count,
  ) {
    return _query_param_alias_int32s(
      query,
      alias,
      values,
      count,
    );
  }

  late final _query_param_alias_int32sPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int32>,
              ffi.Size)>>('obx_query_param_alias_int32s');
  late final _query_param_alias_int32s =
      _query_param_alias_int32sPtr.asFunction<
          int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int32>, int)>();

  int query_param_alias_double(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    double value,
  ) {
    return _query_param_alias_double(
      query,
      alias,
      value,
    );
  }

  late final _query_param_alias_doublePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Double)>>('obx_query_param_alias_double');
  late final _query_param_alias_double =
      _query_param_alias_doublePtr.asFunction<
          int Function(
              ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>, double)>();

  int query_param_alias_2doubles(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    double value_a,
    double value_b,
  ) {
    return _query_param_alias_2doubles(
      query,
      alias,
      value_a,
      value_b,
    );
  }

  late final _query_param_alias_2doublesPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Double, ffi.Double)>>('obx_query_param_alias_2doubles');
  late final _query_param_alias_2doubles =
      _query_param_alias_2doublesPtr.asFunction<
          int Function(
              ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>, double, double)>();

  int query_param_alias_bytes(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    ffi.Pointer<ffi.Uint8> value,
    int size,
  ) {
    return _query_param_alias_bytes(
      query,
      alias,
      value,
      size,
    );
  }

  late final _query_param_alias_bytesPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_query_param_alias_bytes');
  late final _query_param_alias_bytes = _query_param_alias_bytesPtr.asFunction<
      int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>, int)>();

  int query_param_alias_vector_float32(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
    ffi.Pointer<ffi.Float> value,
    int element_count,
  ) {
    return _query_param_alias_vector_float32(
      query,
      alias,
      value,
      element_count,
    );
  }

  late final _query_param_alias_vector_float32Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Float>,
              ffi.Size)>>('obx_query_param_alias_vector_float32');
  late final _query_param_alias_vector_float32 =
      _query_param_alias_vector_float32Ptr.asFunction<
          int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Float>, int)>();

  /// Gets the size of the property type used in a query condition.
  /// A typical use case of this is to allow language bindings (e.g. Swift) use the right type (e.g. 32 bit ints) even
  /// if the language has a bias towards another type (e.g. 64 bit ints).
  /// @returns the size of the underlying property
  /// @returns 0 if it does not have a fixed size (e.g. strings, vectors) or an error occurred
  int query_param_alias_get_type_size(
    ffi.Pointer<OBX_query> query,
    ffi.Pointer<ffi.Char> alias,
  ) {
    return _query_param_alias_get_type_size(
      query,
      alias,
    );
  }

  late final _query_param_alias_get_type_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<OBX_query>,
              ffi.Pointer<ffi.Char>)>>('obx_query_param_alias_get_type_size');
  late final _query_param_alias_get_type_size =
      _query_param_alias_get_type_sizePtr.asFunction<
          int Function(ffi.Pointer<OBX_query>, ffi.Pointer<ffi.Char>)>();

  /// Create a "property query" with results referring to single property (not complete objects).
  /// Also provides aggregates like for example obx_query_prop_avg().
  ffi.Pointer<OBX_query_prop> query_prop(
    ffi.Pointer<OBX_query> query,
    int property_id,
  ) {
    return _query_prop(
      query,
      property_id,
    );
  }

  late final _query_propPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_query_prop> Function(
              ffi.Pointer<OBX_query>, obx_schema_id)>>('obx_query_prop');
  late final _query_prop = _query_propPtr.asFunction<
      ffi.Pointer<OBX_query_prop> Function(ffi.Pointer<OBX_query>, int)>();

  /// Close the property query and release resources.
  int query_prop_close(
    ffi.Pointer<OBX_query_prop> query,
  ) {
    return _query_prop_close(
      query,
    );
  }

  late final _query_prop_closePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_query_prop>)>>(
      'obx_query_prop_close');
  late final _query_prop_close = _query_prop_closePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_prop>)>();

  /// Configure the property query to work only on distinct values.
  /// @note not all methods support distinct, those that don't will return an error
  int query_prop_distinct(
    ffi.Pointer<OBX_query_prop> query,
    bool distinct,
  ) {
    return _query_prop_distinct(
      query,
      distinct,
    );
  }

  late final _query_prop_distinctPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>,
              ffi.Bool)>>('obx_query_prop_distinct');
  late final _query_prop_distinct = _query_prop_distinctPtr
      .asFunction<int Function(ffi.Pointer<OBX_query_prop>, bool)>();

  /// Configure the property query to work only on distinct values.
  /// This version is reserved for string properties and defines the case sensitivity for distinctness.
  /// @note not all methods support distinct, those that don't will return an error
  int query_prop_distinct_case(
    ffi.Pointer<OBX_query_prop> query,
    bool distinct,
    bool case_sensitive,
  ) {
    return _query_prop_distinct_case(
      query,
      distinct,
      case_sensitive,
    );
  }

  late final _query_prop_distinct_casePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Bool,
              ffi.Bool)>>('obx_query_prop_distinct_case');
  late final _query_prop_distinct_case = _query_prop_distinct_casePtr
      .asFunction<int Function(ffi.Pointer<OBX_query_prop>, bool, bool)>();

  /// Count the number of non-NULL values of the given property across all objects matching the query
  int query_prop_count(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _query_prop_count(
      query,
      out_count,
    );
  }

  late final _query_prop_countPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Uint64>)>>('obx_query_prop_count');
  late final _query_prop_count = _query_prop_countPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Uint64>)>();

  /// Calculate an average value for the given numeric property across all objects matching the query.
  /// @param query the query to run
  /// @param out_average the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// E.g. a floating point NaN value will trigger the short cut as the average will be a NaN no matter
  /// what values will follow.
  int query_prop_avg(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Double> out_average,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_avg(
      query,
      out_average,
      out_count,
    );
  }

  late final _query_prop_avgPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_avg');
  late final _query_prop_avg = _query_prop_avgPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Int64>)>();

  /// Calculate an average value for the given numeric property across all objects matching the query.
  /// @param query the query to run
  /// @param out_average the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// @returns OBX_ERROR_NUMERIC_OVERFLOW if the result does not fit into an int64_t
  int query_prop_avg_int(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int64> out_average,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_avg_int(
      query,
      out_average,
      out_count,
    );
  }

  late final _query_prop_avg_intPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_avg_int');
  late final _query_prop_avg_int = _query_prop_avg_intPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// Find the minimum value of the given floating-point property across all objects matching the query.
  /// @param query the query to run
  /// @param out_minimum the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// E.g. if an index is used, it will be set to 0 or -1, instead of the actual count of objects.
  int query_prop_min(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Double> out_minimum,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_min(
      query,
      out_minimum,
      out_count,
    );
  }

  late final _query_prop_minPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_min');
  late final _query_prop_min = _query_prop_minPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Int64>)>();

  /// Find the maximum value of the given floating-point property across all objects matching the query
  /// @param query the query to run
  /// @param out_maximum the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// E.g. if an index is used, it will be set to 0 or -1, instead of the actual count of objects.
  int query_prop_max(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Double> out_maximum,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_max(
      query,
      out_maximum,
      out_count,
    );
  }

  late final _query_prop_maxPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_max');
  late final _query_prop_max = _query_prop_maxPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Int64>)>();

  /// Calculate the sum of the given floating-point property across all objects matching the query.
  /// @param query the query to run
  /// @param out_sum the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// E.g. a floating point NaN value will trigger the short cut as the average will be a NaN no matter
  /// what values will follow.
  int query_prop_sum(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Double> out_sum,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_sum(
      query,
      out_sum,
      out_count,
    );
  }

  late final _query_prop_sumPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_sum');
  late final _query_prop_sum = _query_prop_sumPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Int64>)>();

  /// Find the minimum value of the given property across all objects matching the query.
  /// @param query the query to run
  /// @param out_minimum the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// E.g. if an index is used, it will be set to 0 or -1, instead of the actual count of objects.
  int query_prop_min_int(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int64> out_minimum,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_min_int(
      query,
      out_minimum,
      out_count,
    );
  }

  late final _query_prop_min_intPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_min_int');
  late final _query_prop_min_int = _query_prop_min_intPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// Find the maximum value of the given property across all objects matching the query.
  /// @param query the query to run
  /// @param out_maximum the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// E.g. if an index is used, it will be set to 0 or -1, instead of the actual count of objects.
  int query_prop_max_int(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int64> out_maximum,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_max_int(
      query,
      out_maximum,
      out_count,
    );
  }

  late final _query_prop_max_intPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_max_int');
  late final _query_prop_max_int = _query_prop_max_intPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// Calculate the sum of the given property across all objects matching the query.
  /// @param query the query to run
  /// @param out_sum the result of the query
  /// @param out_count (optional, may be NULL) number of objects contributing to the result (counted on the fly).
  /// A negative count indicates that the computation used a short cut and thus the count is incomplete.
  /// @returns OBX_ERROR_NUMERIC_OVERFLOW if the result does not fit into an int64_t
  int query_prop_sum_int(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int64> out_sum,
    ffi.Pointer<ffi.Int64> out_count,
  ) {
    return _query_prop_sum_int(
      query,
      out_sum,
      out_count,
    );
  }

  late final _query_prop_sum_intPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_sum_int');
  late final _query_prop_sum_int = _query_prop_sum_intPtr.asFunction<
      int Function(ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// Return an array of strings stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified field are skipped
  ffi.Pointer<OBX_string_array> query_prop_find_strings(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Char> value_if_null,
  ) {
    return _query_prop_find_strings(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_stringsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_string_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Char>)>>('obx_query_prop_find_strings');
  late final _query_prop_find_strings = _query_prop_find_stringsPtr.asFunction<
      ffi.Pointer<OBX_string_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Char>)>();

  /// Return an array of ints stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified are skipped
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_int64_array> query_prop_find_int64s(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int64> value_if_null,
  ) {
    return _query_prop_find_int64s(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_int64sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_int64_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Int64>)>>('obx_query_prop_find_int64s');
  late final _query_prop_find_int64s = _query_prop_find_int64sPtr.asFunction<
      ffi.Pointer<OBX_int64_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int64>)>();

  /// Return an array of ints stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified are skipped
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_int32_array> query_prop_find_int32s(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int32> value_if_null,
  ) {
    return _query_prop_find_int32s(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_int32sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_int32_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Int32>)>>('obx_query_prop_find_int32s');
  late final _query_prop_find_int32s = _query_prop_find_int32sPtr.asFunction<
      ffi.Pointer<OBX_int32_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int32>)>();

  /// Return an array of ints stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified are skipped
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_int16_array> query_prop_find_int16s(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int16> value_if_null,
  ) {
    return _query_prop_find_int16s(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_int16sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_int16_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Int16>)>>('obx_query_prop_find_int16s');
  late final _query_prop_find_int16s = _query_prop_find_int16sPtr.asFunction<
      ffi.Pointer<OBX_int16_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int16>)>();

  /// Return an array of ints stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified are skipped
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_int8_array> query_prop_find_int8s(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Int8> value_if_null,
  ) {
    return _query_prop_find_int8s(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_int8sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_int8_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Int8>)>>('obx_query_prop_find_int8s');
  late final _query_prop_find_int8s = _query_prop_find_int8sPtr.asFunction<
      ffi.Pointer<OBX_int8_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Int8>)>();

  /// Return an array of doubles stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified are skipped
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_double_array> query_prop_find_doubles(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Double> value_if_null,
  ) {
    return _query_prop_find_doubles(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_doublesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_double_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Double>)>>('obx_query_prop_find_doubles');
  late final _query_prop_find_doubles = _query_prop_find_doublesPtr.asFunction<
      ffi.Pointer<OBX_double_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Double>)>();

  /// Return an array of int stored as the given property across all objects matching the query.
  /// @param value_if_null value that should be used in place of NULL values on object fields;
  /// if value_if_null=NULL is given, objects with NULL values of the specified are skipped
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_float_array> query_prop_find_floats(
    ffi.Pointer<OBX_query_prop> query,
    ffi.Pointer<ffi.Float> value_if_null,
  ) {
    return _query_prop_find_floats(
      query,
      value_if_null,
    );
  }

  late final _query_prop_find_floatsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_float_array> Function(ffi.Pointer<OBX_query_prop>,
              ffi.Pointer<ffi.Float>)>>('obx_query_prop_find_floats');
  late final _query_prop_find_floats = _query_prop_find_floatsPtr.asFunction<
      ffi.Pointer<OBX_float_array> Function(
          ffi.Pointer<OBX_query_prop>, ffi.Pointer<ffi.Float>)>();

  /// Create an observer (callback) to be notified about all data changes (for all object types).
  /// The callback is invoked right after a successful commit.
  /// \par Threading note
  /// The given callback is called on the thread issuing the commit for the data change, e.g. via obx_txn_success().
  /// Future versions might change that to a background thread, so be careful with threading assumptions.
  /// Also, it's a usually good idea to make the callback return quickly to let the calling thread continue.
  /// \attention Currently, you can not call any data operations from inside the call back.
  /// \attention More accurately, no transaction may be strated. (This restriction may be removed in a later version.)
  /// @param user_data any value you want to be forwarded to the given observer callback (usually some context info).
  /// @param callback pointer to be called when the observed data changes.
  /// @returns NULL if a illegal locking situation was detected, e.g. called from an observer itself or a
  /// timeout/deadlock was detected (OBX_ERROR_ILLEGAL_STATE).
  ffi.Pointer<OBX_observer> observe(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<obx_observer> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _observe(
      store,
      callback,
      user_data,
    );
  }

  late final _observePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_observer> Function(
              ffi.Pointer<OBX_store>,
              ffi.Pointer<obx_observer>,
              ffi.Pointer<ffi.Void>)>>('obx_observe');
  late final _observe = _observePtr.asFunction<
      ffi.Pointer<OBX_observer> Function(ffi.Pointer<OBX_store>,
          ffi.Pointer<obx_observer>, ffi.Pointer<ffi.Void>)>();

  /// Create an observer (callback) to be notified about data changes for a given object type.
  /// The callback is invoked right after a successful commit.
  /// \note  If you intend to observe more than one type, it is more efficient to use obx_observe().
  /// \par Threading note
  /// The given callback is called on the thread issuing the commit for the data change, e.g. via obx_txn_success().
  /// Future versions might change that to a background thread, so be careful with threading assumptions.
  /// Also, it's a usually good idea to make the callback return quickly to let the calling thread continue.
  /// \attention Currently, you can not call any data operations from inside the call back.
  /// \attention More accurately, no transaction may be started. (This restriction may be removed in a later version.)
  /// @param type_id ID of the object type to be observer.
  /// @param user_data any value you want to be forwarded to the given observer callback (usually some context info).
  /// @param callback pointer to be called when the observed data changes.
  /// @returns NULL if a illegal locking situation was detected, e.g. called from an observer itself or a
  /// timeout/deadlock was detected (OBX_ERROR_ILLEGAL_STATE).
  ffi.Pointer<OBX_observer> observe_single_type(
    ffi.Pointer<OBX_store> store,
    int type_id,
    ffi.Pointer<obx_observer_single_type> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _observe_single_type(
      store,
      type_id,
      callback,
      user_data,
    );
  }

  late final _observe_single_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_observer> Function(
              ffi.Pointer<OBX_store>,
              obx_schema_id,
              ffi.Pointer<obx_observer_single_type>,
              ffi.Pointer<ffi.Void>)>>('obx_observe_single_type');
  late final _observe_single_type = _observe_single_typePtr.asFunction<
      ffi.Pointer<OBX_observer> Function(ffi.Pointer<OBX_store>, int,
          ffi.Pointer<obx_observer_single_type>, ffi.Pointer<ffi.Void>)>();

  /// Free the memory used by the given observer and unsubscribe it from its box or query.
  /// @returns OBX_ERROR_ILLEGAL_STATE if a illegal locking situation was detected, e.g. called from an observer itself
  /// or a timeout/deadlock was detected. In that case, the caller must try to close again in a valid situation
  /// not causing lock failures.
  int observer_close(
    ffi.Pointer<OBX_observer> observer,
  ) {
    return _observer_close(
      observer,
    );
  }

  late final _observer_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_observer>)>>(
          'obx_observer_close');
  late final _observer_close =
      _observer_closePtr.asFunction<int Function(ffi.Pointer<OBX_observer>)>();

  /// Creates a options object that is passed to tree creation via obx_tree().
  ffi.Pointer<OBX_tree_options> tree_options() {
    return _tree_options();
  }

  late final _tree_optionsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OBX_tree_options> Function()>>(
          'obx_tree_options');
  late final _tree_options =
      _tree_optionsPtr.asFunction<ffi.Pointer<OBX_tree_options> Function()>();

  /// Free the tree options if they were not used (and "consumed") by obx_tree().
  /// Note: Only free *unused* options, obx_tree() frees the options internally.
  void tree_options_free(
    ffi.Pointer<OBX_tree_options> options,
  ) {
    return _tree_options_free(
      options,
    );
  }

  late final _tree_options_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_tree_options>)>>(
      'obx_tree_options_free');
  late final _tree_options_free = _tree_options_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_tree_options>)>();

  /// Adjusts the path delimiter character, which is by default "/".
  int tree_opt_path_delimiter(
    ffi.Pointer<OBX_tree_options> options,
    int path_delimiter,
  ) {
    return _tree_opt_path_delimiter(
      options,
      path_delimiter,
    );
  }

  late final _tree_opt_path_delimiterPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_tree_options>,
              ffi.Char)>>('obx_tree_opt_path_delimiter');
  late final _tree_opt_path_delimiter = _tree_opt_path_delimiterPtr
      .asFunction<int Function(ffi.Pointer<OBX_tree_options>, int)>();

  /// Sets the given OBXTreeOptionFlags at the tree options.
  /// Combine multiple flags using bitwise OR.
  int tree_opt_flags(
    ffi.Pointer<OBX_tree_options> options,
    int flags,
  ) {
    return _tree_opt_flags(
      options,
      flags,
    );
  }

  late final _tree_opt_flagsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_tree_options>,
              ffi.Uint32)>>('obx_tree_opt_flags');
  late final _tree_opt_flags = _tree_opt_flagsPtr
      .asFunction<int Function(ffi.Pointer<OBX_tree_options>, int)>();

  /// Creates a tree for the given store.
  /// @param options can be null for default options (e.g. use '/' as a path delimiter).
  /// The options are always freed when calling this function.
  ffi.Pointer<OBX_tree> tree(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<OBX_tree_options> options,
  ) {
    return _tree(
      store,
      options,
    );
  }

  late final _treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_tree> Function(ffi.Pointer<OBX_store>,
              ffi.Pointer<OBX_tree_options>)>>('obx_tree');
  late final _tree = _treePtr.asFunction<
      ffi.Pointer<OBX_tree> Function(
          ffi.Pointer<OBX_store>, ffi.Pointer<OBX_tree_options>)>();

  void tree_close(
    ffi.Pointer<OBX_tree> tree,
  ) {
    return _tree_close(
      tree,
    );
  }

  late final _tree_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_tree>)>>(
          'obx_tree_close');
  late final _tree_close =
      _tree_closePtr.asFunction<void Function(ffi.Pointer<OBX_tree>)>();

  /// To get/put data from tree, you need to create a tree cursor using this method.
  /// @param txn may be null if the transaction will be set later via obx_tree_cursor_txn()
  ffi.Pointer<OBX_tree_cursor> tree_cursor(
    ffi.Pointer<OBX_tree> tree,
    ffi.Pointer<OBX_txn> txn,
  ) {
    return _tree_cursor(
      tree,
      txn,
    );
  }

  late final _tree_cursorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_tree_cursor> Function(
              ffi.Pointer<OBX_tree>, ffi.Pointer<OBX_txn>)>>('obx_tree_cursor');
  late final _tree_cursor = _tree_cursorPtr.asFunction<
      ffi.Pointer<OBX_tree_cursor> Function(
          ffi.Pointer<OBX_tree>, ffi.Pointer<OBX_txn>)>();

  /// Gets the number of currently tracked node conflicts (non-unique nodes at the same path).
  /// This count gets resent when conflicts get consolidated.
  /// Only tracked if OBXTreeOptionFlags_DetectNonUniqueNodes (or OBXTreeOptionFlags_AutoConsolidateNonUniqueNodes) is
  /// set.
  int tree_node_conflict_count(
    ffi.Pointer<OBX_tree> tree,
  ) {
    return _tree_node_conflict_count(
      tree,
    );
  }

  late final _tree_node_conflict_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<OBX_tree>)>>(
          'obx_tree_node_conflict_count');
  late final _tree_node_conflict_count = _tree_node_conflict_countPtr
      .asFunction<int Function(ffi.Pointer<OBX_tree>)>();

  /// \brief Closes the tree cursor, e.g. before a transaction is ending.
  /// The cursor cannot be used afterwards (consider obx_tree_cursor_reset() if you want to keep using it).
  void tree_cursor_close(
    ffi.Pointer<OBX_tree_cursor> cursor,
  ) {
    return _tree_cursor_close(
      cursor,
    );
  }

  late final _tree_cursor_closePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_tree_cursor>)>>(
      'obx_tree_cursor_close');
  late final _tree_cursor_close = _tree_cursor_closePtr
      .asFunction<void Function(ffi.Pointer<OBX_tree_cursor>)>();

  /// \brief Sets or clears a transaction from the tree cursor.
  ///
  /// A typical use case for this function is to cache the tree cursor for reusing it later.
  /// Note: before closing a transaction, ensure to clear it here first (set to null).
  int tree_cursor_txn(
    ffi.Pointer<OBX_tree_cursor> cursor,
    ffi.Pointer<OBX_txn> txn,
  ) {
    return _tree_cursor_txn(
      cursor,
      txn,
    );
  }

  late final _tree_cursor_txnPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_tree_cursor>,
              ffi.Pointer<OBX_txn>)>>('obx_tree_cursor_txn');
  late final _tree_cursor_txn = _tree_cursor_txnPtr.asFunction<
      int Function(ffi.Pointer<OBX_tree_cursor>, ffi.Pointer<OBX_txn>)>();

  /// \brief A "low-level" get operation to access a tree leaf using the raw FlatBuffer bytes stored in the database.
  /// As usual, the data is only valid during the lifetime of the transaction and before the first write to the DB.
  /// An advantage of using "raw" operations is that custom properties can be passed in the FlatBuffer.
  /// @param data receiver of the data pointer (non-null pointer to a pointer), which will be pointing to FlatBuffers
  /// bytes for the data leaf after this call.
  /// @param metadata optional FlatBuffers receiver (nullable pointer to a pointer) for the meta leaf.
  /// @returns general success/error codes and some tree-specific ones (OBX_ERROR_TREE_*)
  int tree_cursor_get_raw(
    ffi.Pointer<OBX_tree_cursor> cursor,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> metadata,
    ffi.Pointer<ffi.Size> metadata_size,
  ) {
    return _tree_cursor_get_raw(
      cursor,
      path,
      data,
      size,
      metadata,
      metadata_size,
    );
  }

  late final _tree_cursor_get_rawPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_tree_cursor>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('obx_tree_cursor_get_raw');
  late final _tree_cursor_get_raw = _tree_cursor_get_rawPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_tree_cursor>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>)>();

  /// Gets the full path (from the root) of the given leaf ID.
  /// @returns If successful, an allocated path is returned (malloc), which must be free()-ed by the caller.
  /// @returns If not successful, NULL is returned.
  ffi.Pointer<ffi.Char> tree_cursor_get_leaf_path(
    ffi.Pointer<OBX_tree_cursor> cursor,
    int leaf_id,
  ) {
    return _tree_cursor_get_leaf_path(
      cursor,
      leaf_id,
    );
  }

  late final _tree_cursor_get_leaf_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_tree_cursor>,
              obx_id)>>('obx_tree_cursor_get_leaf_path');
  late final _tree_cursor_get_leaf_path =
      _tree_cursor_get_leaf_pathPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_tree_cursor>, int)>();

  /// \brief A "low-level" put operation for a tree leaf using given raw FlatBuffer bytes.
  /// Any non-existing branches and meta nodes are put on the fly if an optional meta-leaf FlatBuffers is given.
  /// A typical usage pattern is to first try without the meta-leaf, and if it does not work, create the meta-leaf and
  /// call again with the meta leaf. This approach takes into account that meta-leaves typically exist, and thus no
  /// resources are wasted for meta-leaf creation if it's not required.
  /// An advantage of using "raw" operations is that custom properties can be passed in the FlatBuffers.
  /// @param leaf_data prepared FlatBuffers bytes for the data leaf (non-const as the data buffer will be mutated);
  /// note: slots for IDs must be already be prepared (zero values)
  /// @param type value type of the given leafObject: it has to be passed to verify against stored metadata
  /// @param leaf_metadata optional FlatBuffers for the meta leaf; at minimum, "name" and "type" must be set.
  /// Note: slots for IDs must be already be prepared (zero values).
  /// Passing null indicates that the branches and meta nodes must already exist; otherwise
  /// the operation will fail and OBX_NOT_FOUND will be returned.
  /// @param leaf_put_mode For the data leaf only (the actual value tree node)
  /// @returns OBX_NOT_FOUND if the path did not exist (and no metadata was given)
  /// @returns OBX_NO_SUCCESS if the put was not successful according to the put mode
  /// @returns also other standard result codes like OBX_SUCCESS or OBX_ERR_*
  int tree_cursor_put_raw(
    ffi.Pointer<OBX_tree_cursor> cursor,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Void> leaf_data,
    int leaf_data_size,
    int type,
    ffi.Pointer<obx_id> out_id,
    ffi.Pointer<ffi.Void> leaf_metadata,
    int leaf_metadata_size,
    int leaf_put_mode,
  ) {
    return _tree_cursor_put_raw(
      cursor,
      path,
      leaf_data,
      leaf_data_size,
      type,
      out_id,
      leaf_metadata,
      leaf_metadata_size,
      leaf_put_mode,
    );
  }

  late final _tree_cursor_put_rawPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_tree_cursor>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int32,
              ffi.Pointer<obx_id>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int32)>>('obx_tree_cursor_put_raw');
  late final _tree_cursor_put_raw = _tree_cursor_put_rawPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_tree_cursor>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<obx_id>,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Explicitly consolidates tree node conflicts (non unique nodes sharing a common path).
  /// See also obx_tree_async_consolidate_node_conflicts() for an asynchronous version.
  int tree_cursor_consolidate_node_conflicts(
    ffi.Pointer<OBX_tree_cursor> cursor,
    ffi.Pointer<ffi.Size> out_consolidated_count,
  ) {
    return _tree_cursor_consolidate_node_conflicts(
      cursor,
      out_consolidated_count,
    );
  }

  late final _tree_cursor_consolidate_node_conflictsPtr = _lookup<
          ffi.NativeFunction<
              obx_err Function(
                  ffi.Pointer<OBX_tree_cursor>, ffi.Pointer<ffi.Size>)>>(
      'obx_tree_cursor_consolidate_node_conflicts');
  late final _tree_cursor_consolidate_node_conflicts =
      _tree_cursor_consolidate_node_conflictsPtr.asFunction<
          int Function(ffi.Pointer<OBX_tree_cursor>, ffi.Pointer<ffi.Size>)>();

  /// \brief Given an existing path, return all existing leaves with their paths.
  /// As this traverses the data tree (i.e. not the meta tree), it will only return nodes that exist (obviously).
  /// Thus, the meta tree may contain additional paths, but these are unused by the data tree (currently at least).
  /// @param path the branch or leaf path to use. Optional: if no path is given (null), the root node is taken.
  /// @returns leaf info ordered by path depth (i.e. starting from paths with the smallest number of branches); paths at
  /// same depth are ordered by id.
  ffi.Pointer<OBX_tree_leaves_info> tree_cursor_get_child_leaves_info(
    ffi.Pointer<OBX_tree_cursor> cursor,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _tree_cursor_get_child_leaves_info(
      cursor,
      path,
    );
  }

  late final _tree_cursor_get_child_leaves_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_tree_leaves_info> Function(
              ffi.Pointer<OBX_tree_cursor>,
              ffi.Pointer<ffi.Char>)>>('obx_tree_cursor_get_child_leaves_info');
  late final _tree_cursor_get_child_leaves_info =
      _tree_cursor_get_child_leaves_infoPtr.asFunction<
          ffi.Pointer<OBX_tree_leaves_info> Function(
              ffi.Pointer<OBX_tree_cursor>, ffi.Pointer<ffi.Char>)>();

  /// Gets the number of leaves from the given leaves info.
  int tree_leaves_info_size(
    ffi.Pointer<OBX_tree_leaves_info> leaves_info,
  ) {
    return _tree_leaves_info_size(
      leaves_info,
    );
  }

  late final _tree_leaves_info_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<OBX_tree_leaves_info>)>>('obx_tree_leaves_info_size');
  late final _tree_leaves_info_size = _tree_leaves_info_sizePtr
      .asFunction<int Function(ffi.Pointer<OBX_tree_leaves_info>)>();

  /// Gets the path of a given leaf (by index).
  ffi.Pointer<ffi.Char> tree_leaves_info_path(
    ffi.Pointer<OBX_tree_leaves_info> leaves_info,
    int index,
  ) {
    return _tree_leaves_info_path(
      leaves_info,
      index,
    );
  }

  late final _tree_leaves_info_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_tree_leaves_info>,
              ffi.Size)>>('obx_tree_leaves_info_path');
  late final _tree_leaves_info_path = _tree_leaves_info_pathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_tree_leaves_info>, int)>();

  /// Gets the property type (as OBXPropertyType) of a given leaf (by index).
  /// @returns OBXPropertyType_Unknown if no property type was found.
  int tree_leaves_info_type(
    ffi.Pointer<OBX_tree_leaves_info> leaves_info,
    int index,
  ) {
    return _tree_leaves_info_type(
      leaves_info,
      index,
    );
  }

  late final _tree_leaves_info_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<OBX_tree_leaves_info>,
              ffi.Size)>>('obx_tree_leaves_info_type');
  late final _tree_leaves_info_type = _tree_leaves_info_typePtr
      .asFunction<int Function(ffi.Pointer<OBX_tree_leaves_info>, int)>();

  /// Gets the id of a given leaf (by index).
  int tree_leaves_info_id(
    ffi.Pointer<OBX_tree_leaves_info> leaves_info,
    int index,
  ) {
    return _tree_leaves_info_id(
      leaves_info,
      index,
    );
  }

  late final _tree_leaves_info_idPtr = _lookup<
      ffi.NativeFunction<
          obx_id Function(ffi.Pointer<OBX_tree_leaves_info>,
              ffi.Size)>>('obx_tree_leaves_info_id');
  late final _tree_leaves_info_id = _tree_leaves_info_idPtr
      .asFunction<int Function(ffi.Pointer<OBX_tree_leaves_info>, int)>();

  /// Frees a leaves info reference.
  void tree_leaves_info_free(
    ffi.Pointer<OBX_tree_leaves_info> leaves_info,
  ) {
    return _tree_leaves_info_free(
      leaves_info,
    );
  }

  late final _tree_leaves_info_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_tree_leaves_info>)>>('obx_tree_leaves_info_free');
  late final _tree_leaves_info_free = _tree_leaves_info_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_tree_leaves_info>)>();

  /// Like obx_tree_cursor_get_raw(), but asynchronous.
  /// @param with_metadata Flag if the callback also wants to receive the metadata (also as raw FlatBuffers).
  /// @param callback Optional (may be null) function that is called with results once the async operation completes.
  /// @param callback_user_data Any value you can supply, which is passed on to the callback (e.g. to identify user
  /// specific context).
  int tree_async_get_raw(
    ffi.Pointer<OBX_tree> tree,
    ffi.Pointer<ffi.Char> path,
    bool with_metadata,
    ffi.Pointer<obx_tree_async_get_callback> callback,
    ffi.Pointer<ffi.Void> callback_user_data,
  ) {
    return _tree_async_get_raw(
      tree,
      path,
      with_metadata,
      callback,
      callback_user_data,
    );
  }

  late final _tree_async_get_rawPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_tree>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Pointer<obx_tree_async_get_callback>,
              ffi.Pointer<ffi.Void>)>>('obx_tree_async_get_raw');
  late final _tree_async_get_raw = _tree_async_get_rawPtr.asFunction<
      int Function(ffi.Pointer<OBX_tree>, ffi.Pointer<ffi.Char>, bool,
          ffi.Pointer<obx_tree_async_get_callback>, ffi.Pointer<ffi.Void>)>();

  /// Like obx_tree_cursor_put_raw(), but asynchronous.
  /// @param callback Optional (may be null) function that is called with results once the async operation completes.
  /// @param callback_user_data Any value you can supply, which is passed on to the callback (e.g. to identify user
  /// specific context).
  int tree_async_put_raw(
    ffi.Pointer<OBX_tree> tree,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Void> leaf_data,
    int leaf_data_size,
    int type,
    ffi.Pointer<ffi.Void> leaf_metadata,
    int leaf_metadata_size,
    int leaf_put_mode,
    ffi.Pointer<obx_tree_async_put_callback> callback,
    ffi.Pointer<ffi.Void> callback_user_data,
  ) {
    return _tree_async_put_raw(
      tree,
      path,
      leaf_data,
      leaf_data_size,
      type,
      leaf_metadata,
      leaf_metadata_size,
      leaf_put_mode,
      callback,
      callback_user_data,
    );
  }

  late final _tree_async_put_rawPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_tree>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int32,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int32,
              ffi.Pointer<obx_tree_async_put_callback>,
              ffi.Pointer<ffi.Void>)>>('obx_tree_async_put_raw');
  late final _tree_async_put_raw = _tree_async_put_rawPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_tree>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<obx_tree_async_put_callback>,
          ffi.Pointer<ffi.Void>)>();

  /// Explicitly consolidates tree node conflicts (non unique nodes sharing a common path) asynchronously.
  /// See also obx_tree_cursor_consolidate_node_conflicts() for a synchronous version.
  int tree_async_consolidate_node_conflicts(
    ffi.Pointer<OBX_tree> tree,
  ) {
    return _tree_async_consolidate_node_conflicts(
      tree,
    );
  }

  late final _tree_async_consolidate_node_conflictsPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_tree>)>>(
          'obx_tree_async_consolidate_node_conflicts');
  late final _tree_async_consolidate_node_conflicts =
      _tree_async_consolidate_node_conflictsPtr
          .asFunction<int Function(ffi.Pointer<OBX_tree>)>();

  /// Creates a weak reference to the given store.
  ffi.Pointer<OBX_weak_store> weak_store(
    ffi.Pointer<OBX_store> store,
  ) {
    return _weak_store(
      store,
    );
  }

  late final _weak_storePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_weak_store> Function(
              ffi.Pointer<OBX_store>)>>('obx_weak_store');
  late final _weak_store = _weak_storePtr.asFunction<
      ffi.Pointer<OBX_weak_store> Function(ffi.Pointer<OBX_store>)>();

  /// Frees a weak store reference.
  void weak_store_free(
    ffi.Pointer<OBX_weak_store> weak_store,
  ) {
    return _weak_store_free(
      weak_store,
    );
  }

  late final _weak_store_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_weak_store>)>>(
      'obx_weak_store_free');
  late final _weak_store_free = _weak_store_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_weak_store>)>();

  /// Tries to get a weak reference to the store with the given ID.
  /// @returns null if no store was found for the given ID
  ffi.Pointer<OBX_weak_store> weak_store_by_id(
    int store_id,
  ) {
    return _weak_store_by_id(
      store_id,
    );
  }

  late final _weak_store_by_idPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<OBX_weak_store> Function(ffi.Uint64)>>(
      'obx_weak_store_by_id');
  late final _weak_store_by_id = _weak_store_by_idPtr
      .asFunction<ffi.Pointer<OBX_weak_store> Function(int)>();

  /// Tries to create a regular store instance for the given weak reference.
  /// @returns null if the store was already closed (all "strong references" are gone)
  ffi.Pointer<OBX_store> weak_store_lock(
    ffi.Pointer<OBX_weak_store> weak_store,
  ) {
    return _weak_store_lock(
      weak_store,
    );
  }

  late final _weak_store_lockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<OBX_weak_store>)>>('obx_weak_store_lock');
  late final _weak_store_lock = _weak_store_lockPtr.asFunction<
      ffi.Pointer<OBX_store> Function(ffi.Pointer<OBX_weak_store>)>();

  void bytes_free(
    ffi.Pointer<OBX_bytes> bytes,
  ) {
    return _bytes_free(
      bytes,
    );
  }

  late final _bytes_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_bytes>)>>(
          'obx_bytes_free');
  late final _bytes_free =
      _bytes_freePtr.asFunction<void Function(ffi.Pointer<OBX_bytes>)>();

  /// Free the array struct
  void bytes_score_array_free(
    ffi.Pointer<OBX_bytes_score_array> array,
  ) {
    return _bytes_score_array_free(
      array,
    );
  }

  late final _bytes_score_array_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<OBX_bytes_score_array>)>>(
      'obx_bytes_score_array_free');
  late final _bytes_score_array_free = _bytes_score_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_bytes_score_array>)>();

  /// Allocate a bytes array struct of the given size, ready for the data to be pushed
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_bytes_array> bytes_array(
    int count,
  ) {
    return _bytes_array(
      count,
    );
  }

  late final _bytes_arrayPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<OBX_bytes_array> Function(ffi.Size)>>(
      'obx_bytes_array');
  late final _bytes_array =
      _bytes_arrayPtr.asFunction<ffi.Pointer<OBX_bytes_array> Function(int)>();

  /// Set the given data as the index in the bytes array. The data is not copied, just referenced through the pointer
  int bytes_array_set(
    ffi.Pointer<OBX_bytes_array> array,
    int index,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _bytes_array_set(
      array,
      index,
      data,
      size,
    );
  }

  late final _bytes_array_setPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_bytes_array>, ffi.Size,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_bytes_array_set');
  late final _bytes_array_set = _bytes_array_setPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_bytes_array>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Free the bytes array struct
  void bytes_array_free(
    ffi.Pointer<OBX_bytes_array> array,
  ) {
    return _bytes_array_free(
      array,
    );
  }

  late final _bytes_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_bytes_array>)>>(
      'obx_bytes_array_free');
  late final _bytes_array_free = _bytes_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_bytes_array>)>();

  /// Create an ID array struct, copying the given IDs as the contents
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_id_array> id_array(
    ffi.Pointer<obx_id> ids,
    int count,
  ) {
    return _id_array(
      ids,
      count,
    );
  }

  late final _id_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_id_array> Function(
              ffi.Pointer<obx_id>, ffi.Size)>>('obx_id_array');
  late final _id_array = _id_arrayPtr.asFunction<
      ffi.Pointer<OBX_id_array> Function(ffi.Pointer<obx_id>, int)>();

  /// Free the array struct
  void id_array_free(
    ffi.Pointer<OBX_id_array> array,
  ) {
    return _id_array_free(
      array,
    );
  }

  late final _id_array_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_id_array>)>>(
          'obx_id_array_free');
  late final _id_array_free =
      _id_array_freePtr.asFunction<void Function(ffi.Pointer<OBX_id_array>)>();

  /// Free the array struct
  void string_array_free(
    ffi.Pointer<OBX_string_array> array,
  ) {
    return _string_array_free(
      array,
    );
  }

  late final _string_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_string_array>)>>(
      'obx_string_array_free');
  late final _string_array_free = _string_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_string_array>)>();

  /// Free the array struct
  void id_score_array_free(
    ffi.Pointer<OBX_id_score_array> array,
  ) {
    return _id_score_array_free(
      array,
    );
  }

  late final _id_score_array_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<OBX_id_score_array>)>>(
      'obx_id_score_array_free');
  late final _id_score_array_free = _id_score_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_id_score_array>)>();

  /// Free the array struct
  void int64_array_free(
    ffi.Pointer<OBX_int64_array> array,
  ) {
    return _int64_array_free(
      array,
    );
  }

  late final _int64_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_int64_array>)>>(
      'obx_int64_array_free');
  late final _int64_array_free = _int64_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_int64_array>)>();

  /// Free the array struct
  void int32_array_free(
    ffi.Pointer<OBX_int32_array> array,
  ) {
    return _int32_array_free(
      array,
    );
  }

  late final _int32_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_int32_array>)>>(
      'obx_int32_array_free');
  late final _int32_array_free = _int32_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_int32_array>)>();

  /// Free the array struct
  void int16_array_free(
    ffi.Pointer<OBX_int16_array> array,
  ) {
    return _int16_array_free(
      array,
    );
  }

  late final _int16_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_int16_array>)>>(
      'obx_int16_array_free');
  late final _int16_array_free = _int16_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_int16_array>)>();

  /// Free the array struct
  void int8_array_free(
    ffi.Pointer<OBX_int8_array> array,
  ) {
    return _int8_array_free(
      array,
    );
  }

  late final _int8_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_int8_array>)>>(
      'obx_int8_array_free');
  late final _int8_array_free = _int8_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_int8_array>)>();

  /// Free the array struct
  void double_array_free(
    ffi.Pointer<OBX_double_array> array,
  ) {
    return _double_array_free(
      array,
    );
  }

  late final _double_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_double_array>)>>(
      'obx_double_array_free');
  late final _double_array_free = _double_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_double_array>)>();

  /// Free the array struct
  void float_array_free(
    ffi.Pointer<OBX_float_array> array,
  ) {
    return _float_array_free(
      array,
    );
  }

  late final _float_array_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_float_array>)>>(
      'obx_float_array_free');
  late final _float_array_free = _float_array_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_float_array>)>();

  /// Only for Apple platforms: set the prefix to use for mutexes based on POSIX semaphores.
  /// You must supply the application group identifier for sand-boxed macOS apps here; see also:
  /// https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html#//apple_ref/doc/uid/TP40011183-CH3-SW24
  /// @param prefix must be at most 20 characters long and end with a forward slash '/'.
  int posix_sem_prefix_set(
    ffi.Pointer<ffi.Char> prefix,
  ) {
    return _posix_sem_prefix_set(
      prefix,
    );
  }

  late final _posix_sem_prefix_setPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<ffi.Char>)>>(
          'obx_posix_sem_prefix_set');
  late final _posix_sem_prefix_set = _posix_sem_prefix_setPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Create a default set of admin options.
  /// @returns NULL on failure, a default set of options on success
  ffi.Pointer<OBX_admin_options> admin_opt() {
    return _admin_opt();
  }

  late final _admin_optPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<OBX_admin_options> Function()>>(
          'obx_admin_opt');
  late final _admin_opt =
      _admin_optPtr.asFunction<ffi.Pointer<OBX_admin_options> Function()>();

  /// Configure admin with an existing, open OBX_store*.
  /// @see also obx_admin_opt_store_path() as an alternative.
  int admin_opt_store(
    ffi.Pointer<OBX_admin_options> opt,
    ffi.Pointer<OBX_store> store,
  ) {
    return _admin_opt_store(
      opt,
      store,
    );
  }

  late final _admin_opt_storePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Pointer<OBX_store>)>>('obx_admin_opt_store');
  late final _admin_opt_store = _admin_opt_storePtr.asFunction<
      int Function(ffi.Pointer<OBX_admin_options>, ffi.Pointer<OBX_store>)>();

  /// Configure admin with an existing, open OBX_store*.
  /// @see also obx_admin_opt_store() as an alternative.
  int admin_opt_store_path(
    ffi.Pointer<OBX_admin_options> opt,
    ffi.Pointer<ffi.Char> directory,
  ) {
    return _admin_opt_store_path(
      opt,
      directory,
    );
  }

  late final _admin_opt_store_pathPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Pointer<ffi.Char>)>>('obx_admin_opt_store_path');
  late final _admin_opt_store_path = _admin_opt_store_pathPtr.asFunction<
      int Function(ffi.Pointer<OBX_admin_options>, ffi.Pointer<ffi.Char>)>();

  /// Set the address and port on which the underlying http-server should server the admin web UI.
  /// Defaults to "http://127.0.0.1:8081"
  /// @note: you can use for e.g. "http://127.0.0.1:0" for automatic free port assignment - see obx_admin_port().
  int admin_opt_bind(
    ffi.Pointer<OBX_admin_options> opt,
    ffi.Pointer<ffi.Char> uri,
  ) {
    return _admin_opt_bind(
      opt,
      uri,
    );
  }

  late final _admin_opt_bindPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Pointer<ffi.Char>)>>('obx_admin_opt_bind');
  late final _admin_opt_bind = _admin_opt_bindPtr.asFunction<
      int Function(ffi.Pointer<OBX_admin_options>, ffi.Pointer<ffi.Char>)>();

  /// Configure the server to use SSL, with the given certificate.
  /// @param cert_path - the file must be in PEM format, and it must have both private key and certificate (public key).
  int admin_opt_ssl_cert(
    ffi.Pointer<OBX_admin_options> opt,
    ffi.Pointer<ffi.Char> cert_path,
  ) {
    return _admin_opt_ssl_cert(
      opt,
      cert_path,
    );
  }

  late final _admin_opt_ssl_certPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Pointer<ffi.Char>)>>('obx_admin_opt_ssl_cert');
  late final _admin_opt_ssl_cert = _admin_opt_ssl_certPtr.asFunction<
      int Function(ffi.Pointer<OBX_admin_options>, ffi.Pointer<ffi.Char>)>();

  /// Sets the number of worker threads the http-server uses to serve requests. Default: 4
  int admin_opt_num_threads(
    ffi.Pointer<OBX_admin_options> opt,
    int num_threads,
  ) {
    return _admin_opt_num_threads(
      opt,
      num_threads,
    );
  }

  late final _admin_opt_num_threadsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Size)>>('obx_admin_opt_num_threads');
  late final _admin_opt_num_threads = _admin_opt_num_threadsPtr
      .asFunction<int Function(ffi.Pointer<OBX_admin_options>, int)>();

  /// Disables authentication to make the web app accessible to anyone, e.g. to allow recovery if users have locked
  /// themselves out. Otherwise, if users have been defined, authentication is enforced.
  int admin_opt_unsecured_no_authentication(
    ffi.Pointer<OBX_admin_options> opt,
    bool value,
  ) {
    return _admin_opt_unsecured_no_authentication(
      opt,
      value,
    );
  }

  late final _admin_opt_unsecured_no_authenticationPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Bool)>>('obx_admin_opt_unsecured_no_authentication');
  late final _admin_opt_unsecured_no_authentication =
      _admin_opt_unsecured_no_authenticationPtr
          .asFunction<int Function(ffi.Pointer<OBX_admin_options>, bool)>();

  /// Disable user management in the database - this is usually only done during development, with local-only access.
  int admin_opt_user_management(
    ffi.Pointer<OBX_admin_options> opt,
    bool value,
  ) {
    return _admin_opt_user_management(
      opt,
      value,
    );
  }

  late final _admin_opt_user_managementPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Bool)>>('obx_admin_opt_user_management');
  late final _admin_opt_user_management = _admin_opt_user_managementPtr
      .asFunction<int Function(ffi.Pointer<OBX_admin_options>, bool)>();

  /// Logs request info, e.g. timing for serving a request
  int admin_opt_log_requests(
    ffi.Pointer<OBX_admin_options> opt,
    bool value,
  ) {
    return _admin_opt_log_requests(
      opt,
      value,
    );
  }

  late final _admin_opt_log_requestsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_admin_options>,
              ffi.Bool)>>('obx_admin_opt_log_requests');
  late final _admin_opt_log_requests = _admin_opt_log_requestsPtr
      .asFunction<int Function(ffi.Pointer<OBX_admin_options>, bool)>();

  /// Free the options.
  /// Note: Only free *unused* options, obx_admin() frees the options internally
  int admin_opt_free(
    ffi.Pointer<OBX_admin_options> opt,
  ) {
    return _admin_opt_free(
      opt,
    );
  }

  late final _admin_opt_freePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_admin_options>)>>(
      'obx_admin_opt_free');
  late final _admin_opt_free = _admin_opt_freePtr
      .asFunction<int Function(ffi.Pointer<OBX_admin_options>)>();

  /// Initialize the http-server with the given options.
  /// Note: the given options are always freed by this function, including when an error occurs.
  /// @param options required parameter holding the options (see obx_admin_opt_*())
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_admin> admin(
    ffi.Pointer<OBX_admin_options> options,
  ) {
    return _admin(
      options,
    );
  }

  late final _adminPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_admin> Function(
              ffi.Pointer<OBX_admin_options>)>>('obx_admin');
  late final _admin = _adminPtr.asFunction<
      ffi.Pointer<OBX_admin> Function(ffi.Pointer<OBX_admin_options>)>();

  /// Returns a port this server listens on. This is especially useful if the port was assigned arbitrarily
  /// (a "0" port was used in the URL given to obx_admin_opt_bind()).
  int admin_port(
    ffi.Pointer<OBX_admin> admin,
  ) {
    return _admin_port(
      admin,
    );
  }

  late final _admin_portPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(ffi.Pointer<OBX_admin>)>>(
          'obx_admin_port');
  late final _admin_port =
      _admin_portPtr.asFunction<int Function(ffi.Pointer<OBX_admin>)>();

  /// Stop the http-server and free all the resources.
  /// @param admin may be NULL
  int admin_close(
    ffi.Pointer<OBX_admin> admin,
  ) {
    return _admin_close(
      admin,
    );
  }

  late final _admin_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_admin>)>>(
          'obx_admin_close');
  late final _admin_close =
      _admin_closePtr.asFunction<int Function(ffi.Pointer<OBX_admin>)>();

  /// Creates a sync client options object, which is used to configure and create a sync client.
  /// The options must be used with obx_sync_create() to create a sync client.
  /// @param store the store to sync; a store can only have one sync client associated with it.
  /// @returns NULL if the options could not be created (e.g. store is NULL)
  ffi.Pointer<OBX_sync_options> sync_opt(
    ffi.Pointer<OBX_store> store,
  ) {
    return _sync_opt(
      store,
    );
  }

  late final _sync_optPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync_options> Function(
              ffi.Pointer<OBX_store>)>>('obx_sync_opt');
  late final _sync_opt = _sync_optPtr.asFunction<
      ffi.Pointer<OBX_sync_options> Function(ffi.Pointer<OBX_store>)>();

  /// Adds a server URL to the sync options; at least one URL must be added before opening the sync client.
  /// Passing multiple URLs allows high availability and load balancing (i.e. using a ObjectBox Sync Server Cluster).
  /// A random URL is selected for each connection attempt.
  int sync_opt_add_url(
    ffi.Pointer<OBX_sync_options> opt,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _sync_opt_add_url(
      opt,
      url,
    );
  }

  late final _sync_opt_add_urlPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_options>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_opt_add_url');
  late final _sync_opt_add_url = _sync_opt_add_urlPtr.asFunction<
      int Function(ffi.Pointer<OBX_sync_options>, ffi.Pointer<ffi.Char>)>();

  /// Adds an SSL certificate path to the sync options.
  /// This allows to pass SSL certificate paths referring to the local file system.
  /// Example use cases are using self-signed certificates in a local development environment and custom CAs.
  int sync_opt_add_cert_path(
    ffi.Pointer<OBX_sync_options> opt,
    ffi.Pointer<ffi.Char> cert_path,
  ) {
    return _sync_opt_add_cert_path(
      opt,
      cert_path,
    );
  }

  late final _sync_opt_add_cert_pathPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_options>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_opt_add_cert_path');
  late final _sync_opt_add_cert_path = _sync_opt_add_cert_pathPtr.asFunction<
      int Function(ffi.Pointer<OBX_sync_options>, ffi.Pointer<ffi.Char>)>();

  /// Sets sync flags to adjust sync behavior; see OBXSyncFlags for available flags.
  /// Combine multiple flags using bitwise OR.
  int sync_opt_flags(
    ffi.Pointer<OBX_sync_options> opt,
    int flags,
  ) {
    return _sync_opt_flags(
      opt,
      flags,
    );
  }

  late final _sync_opt_flagsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_options>,
              ffi.Uint32)>>('obx_sync_opt_flags');
  late final _sync_opt_flags = _sync_opt_flagsPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_options>, int)>();

  /// Creates a sync client with the given options.
  /// This does not initiate any connection attempts yet: call obx_sync_start() to do so.
  /// Before obx_sync_start(), you must configure credentials via obx_sync_credentials.
  /// By default, a sync client automatically receives updates from the server once login succeeded.
  /// To configure this differently, call obx_sync_request_updates_mode() with the wanted mode.
  /// Note: the given options are always freed by this function, including when an error occurs.
  /// @param opt required parameter holding the sync options (at least one URL must be set)
  /// @returns NULL if the operation failed, see functions like obx_last_error_code() to get error details
  ffi.Pointer<OBX_sync> sync_create(
    ffi.Pointer<OBX_sync_options> opt,
  ) {
    return _sync_create(
      opt,
    );
  }

  late final _sync_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync> Function(
              ffi.Pointer<OBX_sync_options>)>>('obx_sync_create');
  late final _sync_create = _sync_createPtr.asFunction<
      ffi.Pointer<OBX_sync> Function(ffi.Pointer<OBX_sync_options>)>();

  /// Frees the sync options object.
  /// Note: Only free *unused* options, obx_sync_create() frees the options internally.
  void sync_opt_free(
    ffi.Pointer<OBX_sync_options> opt,
  ) {
    return _sync_opt_free(
      opt,
    );
  }

  late final _sync_opt_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<OBX_sync_options>)>>(
      'obx_sync_opt_free');
  late final _sync_opt_free = _sync_opt_freePtr
      .asFunction<void Function(ffi.Pointer<OBX_sync_options>)>();

  /// Creates a sync client associated with the given store and sync server URL.
  /// This does not initiate any connection attempts yet: call obx_sync_start() to do so.
  /// Before obx_sync_start(), you must configure credentials via obx_sync_credentials.
  /// By default, a sync client automatically receives updates from the server once login succeeded.
  /// To configure this differently, call obx_sync_request_updates_mode() with the wanted mode.
  ffi.Pointer<OBX_sync> sync1(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<ffi.Char> server_url,
  ) {
    return _sync1(
      store,
      server_url,
    );
  }

  late final _sync1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync> Function(
              ffi.Pointer<OBX_store>, ffi.Pointer<ffi.Char>)>>('obx_sync');
  late final _sync1 = _sync1Ptr.asFunction<
      ffi.Pointer<OBX_sync> Function(
          ffi.Pointer<OBX_store>, ffi.Pointer<ffi.Char>)>();

  /// Creates a sync client associated with the given store and a list of sync server URLs (minimum: one URL).
  /// Passing multiple URLs allows high availability and load balancing (i.e. using a ObjectBox Sync Server Cluster).
  /// A random URL is selected for each connection attempt.
  /// For general details, see obx_sync()
  ffi.Pointer<OBX_sync> sync_urls(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<ffi.Pointer<ffi.Char>> server_urls,
    int server_urls_count,
  ) {
    return _sync_urls(
      store,
      server_urls,
      server_urls_count,
    );
  }

  late final _sync_urlsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync> Function(ffi.Pointer<OBX_store>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Size)>>('obx_sync_urls');
  late final _sync_urls = _sync_urlsPtr.asFunction<
      ffi.Pointer<OBX_sync> Function(
          ffi.Pointer<OBX_store>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  /// Creates a sync client associated with the given store, sync server URLs and SSL certificate paths.
  /// Like obx_sync_urls(), but also allows to pass SSL certificate paths referring to the local file system.
  /// Example use cases are using self-signed certificates in a local development environment and custom CAs.
  ffi.Pointer<OBX_sync> sync_certs(
    ffi.Pointer<OBX_store> store,
    ffi.Pointer<ffi.Pointer<ffi.Char>> server_urls,
    int server_urls_count,
    ffi.Pointer<ffi.Pointer<ffi.Char>> cert_paths,
    int cert_paths_count,
  ) {
    return _sync_certs(
      store,
      server_urls,
      server_urls_count,
      cert_paths,
      cert_paths_count,
    );
  }

  late final _sync_certsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync> Function(
              ffi.Pointer<OBX_store>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Size)>>('obx_sync_certs');
  late final _sync_certs = _sync_certsPtr.asFunction<
      ffi.Pointer<OBX_sync> Function(
          ffi.Pointer<OBX_store>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int)>();

  /// Stops and closes (deletes) the sync client, freeing its resources.
  int sync_close(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_close(
      sync1,
    );
  }

  late final _sync_closePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_close');
  late final _sync_close =
      _sync_closePtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Adds or replaces a sync filter variable value for the given name to the sync client.
  /// Eventually existing values for the same name are replaced.
  /// Client filter variables can be used in server-side sync filters to filter out objects that do not match the filter.
  /// Filter variables must be added before login, e.g. before obx_sync_start() or setting credentials.
  /// @param name non-NULL name of the filter variable
  /// @param value non-NULL value of the filter variable
  int sync_filter_variables_put(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _sync_filter_variables_put(
      sync1,
      name,
      value,
    );
  }

  late final _sync_filter_variables_putPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_filter_variables_put');
  late final _sync_filter_variables_put =
      _sync_filter_variables_putPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Removes a previously added sync filter variable value.
  int sync_filter_variables_remove(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _sync_filter_variables_remove(
      sync1,
      name,
    );
  }

  late final _sync_filter_variables_removePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_filter_variables_remove');
  late final _sync_filter_variables_remove = _sync_filter_variables_removePtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>, ffi.Pointer<ffi.Char>)>();

  /// Removes all previously added sync filter variable values.
  int sync_filter_variables_remove_all(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_filter_variables_remove_all(
      sync1,
    );
  }

  late final _sync_filter_variables_remove_allPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_filter_variables_remove_all');
  late final _sync_filter_variables_remove_all =
      _sync_filter_variables_remove_allPtr
          .asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Sets credentials to authenticate the client with the server.
  /// Any credentials that were set before are replaced;
  /// if you want to pass multiple credentials, use obx_sync_credentials_add() instead.
  /// If the client was waiting for credentials, this can trigger a reconnection/login attempt.
  /// @param type See OBXSyncCredentialsType for available options.
  /// The accepted OBXSyncCredentials type depends on your sync-server configuration.
  /// @param data may be NULL in combination with OBXSyncCredentialsType_NONE
  int sync_credentials(
    ffi.Pointer<OBX_sync> sync1,
    int type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _sync_credentials(
      sync1,
      type,
      data,
      size,
    );
  }

  late final _sync_credentialsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>, ffi.Int32,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('obx_sync_credentials');
  late final _sync_credentials = _sync_credentialsPtr.asFunction<
      int Function(ffi.Pointer<OBX_sync>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Set username/password credentials to authenticate the client with the server.
  /// This is suitable for OBXSyncCredentialsType_OBX_ADMIN_USER and OBXSyncCredentialsType_USER_PASSWORD credential
  /// types. Use obx_sync_credentials() for other credential types.
  /// @param type should be OBXSyncCredentialsType_OBX_ADMIN_USER or OBXSyncCredentialsType_USER_PASSWORD
  /// @returns OBX_ERROR_ILLEGAL_ARGUMENT if credential type does not support username/password authentication.
  int sync_credentials_user_password(
    ffi.Pointer<OBX_sync> sync1,
    int type,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _sync_credentials_user_password(
      sync1,
      type,
      username,
      password,
    );
  }

  late final _sync_credentials_user_passwordPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_credentials_user_password');
  late final _sync_credentials_user_password =
      _sync_credentials_user_passwordPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync>, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// For authentication with multiple credentials, collect credentials by calling this function multiple times.
  /// When adding the last credentials element, the "complete" flag must be set to true.
  /// When completed, it will "activate" the collected credentials and replace any previously set credentials and
  /// potentially trigger a reconnection/login attempt.
  /// @param type See OBXSyncCredentialsType for available options.
  /// The accepted OBXSyncCredentials type depends on your sync-server configuration.
  /// @param data non-NULL (OBXSyncCredentialsType_NONE is not allowed)
  /// @param complete set to true when adding the last credentials element to activate the set of credentials
  int sync_credentials_add(
    ffi.Pointer<OBX_sync> sync1,
    int type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
    bool complete,
  ) {
    return _sync_credentials_add(
      sync1,
      type,
      data,
      size,
      complete,
    );
  }

  late final _sync_credentials_addPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync>,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Bool)>>('obx_sync_credentials_add');
  late final _sync_credentials_add = _sync_credentials_addPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_sync>, int, ffi.Pointer<ffi.Uint8>, int, bool)>();

  /// For authentication with multiple credentials, collect credentials by calling this function multiple times.
  /// When adding the last credentials element, the "complete" flag must be set to true.
  /// When completed, it will "activate" the collected credentials and replace any previously set credentials and
  /// potentially trigger a reconnection/login attempt.
  /// @param type See OBXSyncCredentialsType for available options.
  /// The accepted OBXSyncCredentials type depends on your sync-server configuration.
  /// @param username non-NULL
  /// @param password non-NULL
  /// @param complete set to true when adding the last credentials element to activate the set of credentials
  int sync_credentials_add_user_password(
    ffi.Pointer<OBX_sync> sync1,
    int type,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
    bool complete,
  ) {
    return _sync_credentials_add_user_password(
      sync1,
      type,
      username,
      password,
      complete,
    );
  }

  late final _sync_credentials_add_user_passwordPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('obx_sync_credentials_add_user_password');
  late final _sync_credentials_add_user_password =
      _sync_credentials_add_user_passwordPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync>, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, bool)>();

  /// Configures the maximum number of outgoing TX messages that can be sent without an ACK from the server.
  /// @returns OBX_ERROR_ILLEGAL_ARGUMENT if value is not in the range 1-20
  int sync_max_messages_in_flight(
    ffi.Pointer<OBX_sync> sync1,
    int value,
  ) {
    return _sync_max_messages_in_flight(
      sync1,
      value,
    );
  }

  late final _sync_max_messages_in_flightPtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>, ffi.Int)>>(
      'obx_sync_max_messages_in_flight');
  late final _sync_max_messages_in_flight = _sync_max_messages_in_flightPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>, int)>();

  /// Triggers a reconnection attempt immediately.
  /// By default, an increasing backoff interval is used for reconnection attempts.
  /// But sometimes the user of this API has additional knowledge and can initiate a reconnection attempt sooner.
  /// @return OBX_SUCCESS if a reconnect could be triggered, OBX_NO_SUCCESS if not, or an error code in exceptional cases.
  int sync_trigger_reconnect(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_trigger_reconnect(
      sync1,
    );
  }

  late final _sync_trigger_reconnectPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_trigger_reconnect');
  late final _sync_trigger_reconnect = _sync_trigger_reconnectPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Sets the interval in which the client sends "heartbeat" messages to the server, keeping the connection alive.
  /// To detect disconnects early on the client side, you can also use heartbeats with a smaller interval.
  /// Use with caution, setting a low value (i.e. sending heartbeat very often) may cause an excessive network usage
  /// as well as high server load (with many clients).
  /// @param interval_ms interval in milliseconds; the default is 25 minutes (1 500 000 milliseconds),
  /// which is also the allowed maximum.
  /// @returns OBX_ERROR_ILLEGAL_ARGUMENT if value is not in the allowed range, e.g. larger than the maximum (1 500 000).
  int sync_heartbeat_interval(
    ffi.Pointer<OBX_sync> sync1,
    int interval_ms,
  ) {
    return _sync_heartbeat_interval(
      sync1,
      interval_ms,
    );
  }

  late final _sync_heartbeat_intervalPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>, ffi.Uint64)>>(
      'obx_sync_heartbeat_interval');
  late final _sync_heartbeat_interval = _sync_heartbeat_intervalPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>, int)>();

  /// Triggers the heartbeat sending immediately. This lets you check the network connection at any time.
  /// @see obx_sync_heartbeat_interval()
  int sync_send_heartbeat(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_send_heartbeat(
      sync1,
    );
  }

  late final _sync_send_heartbeatPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_send_heartbeat');
  late final _sync_send_heartbeat =
      _sync_send_heartbeatPtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Switches operation mode that's initialized after successful login
  /// Must be called before obx_sync_start() (returns OBX_ERROR_ILLEGAL_STATE if it was already started)
  int sync_request_updates_mode(
    ffi.Pointer<OBX_sync> sync1,
    int mode,
  ) {
    return _sync_request_updates_mode(
      sync1,
      mode,
    );
  }

  late final _sync_request_updates_modePtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>, ffi.Int32)>>(
      'obx_sync_request_updates_mode');
  late final _sync_request_updates_mode = _sync_request_updates_modePtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>, int)>();

  /// Once the sync client is configured, you can "start" it to initiate synchronization.
  /// This method triggers communication in the background and will return immediately.
  /// If the synchronization destination is reachable, this background thread will connect to the server,
  /// log in (authenticate) and, depending on "update request mode", start syncing data.
  /// If the device, network or server is currently offline, connection attempts will be retried later using
  /// increasing backoff intervals.
  int sync_start(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_start(
      sync1,
    );
  }

  late final _sync_startPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_start');
  late final _sync_start =
      _sync_startPtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Stops this sync client and thus stopping the synchronization. Does nothing if it is already stopped.
  int sync_stop(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_stop(
      sync1,
    );
  }

  late final _sync_stopPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_stop');
  late final _sync_stop =
      _sync_stopPtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Gets the current state of the sync client (0 on error, e.g. given sync was NULL)
  int sync_state(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_state(
      sync1,
    );
  }

  late final _sync_statePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_state');
  late final _sync_state =
      _sync_statePtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Waits for the sync client to get into the given state or until the given timeout is reached.
  /// For an asynchronous alternative, please check the listeners.
  /// @param timeout_millis Must be greater than 0
  /// @returns OBX_SUCCESS if the LOGGED_IN state has been reached within the given timeout
  /// @returns OBX_TIMEOUT if the given timeout was reached before a relevant state change was detected.
  /// Note: obx_last_error_code() is not set.
  /// @returns OBX_NO_SUCCESS if a state was reached within the given timeout that is unlikely to result in a
  /// successful login, e.g. "disconnected". Note: obx_last_error_code() is not set.
  int sync_wait_for_logged_in_state(
    ffi.Pointer<OBX_sync> sync1,
    int timeout_millis,
  ) {
    return _sync_wait_for_logged_in_state(
      sync1,
      timeout_millis,
    );
  }

  late final _sync_wait_for_logged_in_statePtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>, ffi.Uint64)>>(
      'obx_sync_wait_for_logged_in_state');
  late final _sync_wait_for_logged_in_state = _sync_wait_for_logged_in_statePtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>, int)>();

  /// Request updates from the server since we last synced our database.
  /// @param subscribe_for_pushes keep sending us future updates as they come in.
  /// This should only be called in "logged in" state and there are no delivery guarantees given.
  /// @returns OBX_SUCCESS if the request was likely sent (e.g. the sync client is in "logged in" state)
  /// @returns OBX_NO_SUCCESS if the request was not sent (and will not be sent in the future).
  /// Note: obx_last_error_code() is not set.
  int sync_updates_request(
    ffi.Pointer<OBX_sync> sync1,
    bool subscribe_for_pushes,
  ) {
    return _sync_updates_request(
      sync1,
      subscribe_for_pushes,
    );
  }

  late final _sync_updates_requestPtr = _lookup<
          ffi
          .NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>, ffi.Bool)>>(
      'obx_sync_updates_request');
  late final _sync_updates_request = _sync_updates_requestPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>, bool)>();

  /// Cancel updates from the server (once received, the server stops sending updates).
  /// The counterpart to obx_sync_updates_request().
  /// This should only be called in "logged in" state and there are no delivery guarantees given.
  /// @returns OBX_SUCCESS if the request was likely sent (e.g. the sync client is in "logged in" state)
  /// @returns OBX_NO_SUCCESS if the request was not sent (and will not be sent in the future).
  /// Note: obx_last_error_code() is not set.
  int sync_updates_cancel(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_updates_cancel(
      sync1,
    );
  }

  late final _sync_updates_cancelPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_updates_cancel');
  late final _sync_updates_cancel =
      _sync_updates_cancelPtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Count the number of messages in the outgoing queue, i.e. those waiting to be sent to the server.
  /// @param limit pass 0 to count all messages without any limitation or a lower number that's enough for your app logic.
  /// @note This call uses a (read) transaction internally: 1) it's not just a "cheap" return of a single number.
  /// While this will still be fast, avoid calling this function excessively.
  /// 2) the result follows transaction view semantics, thus it may not always match the actual value.
  int sync_outgoing_message_count(
    ffi.Pointer<OBX_sync> sync1,
    int limit,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _sync_outgoing_message_count(
      sync1,
      limit,
      out_count,
    );
  }

  late final _sync_outgoing_message_countPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>, ffi.Uint64,
              ffi.Pointer<ffi.Uint64>)>>('obx_sync_outgoing_message_count');
  late final _sync_outgoing_message_count =
      _sync_outgoing_message_countPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync>, int, ffi.Pointer<ffi.Uint64>)>();

  /// Experimental. This API is likely to be replaced/removed in a future version.
  /// Quickly bring our database up-to-date in a single transaction, without transmitting all the history.
  /// Good for initial sync of new clients.
  /// @returns OBX_SUCCESS if the request was likely sent (e.g. the sync client is in "logged in" state)
  /// @returns OBX_NO_SUCCESS if the request was not sent (and will not be sent in the future).
  /// Note: obx_last_error_code() is not set.
  int sync_full(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_full(
      sync1,
    );
  }

  late final _sync_fullPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_full');
  late final _sync_full =
      _sync_fullPtr.asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Estimates the current server timestamp based on the last known server time and local steady clock.
  /// @param out_timestamp_ns - unix timestamp in nanoseconds - may be set to zero if the last server's time is unknown.
  int sync_time_server(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<ffi.Int64> out_timestamp_ns,
  ) {
    return _sync_time_server(
      sync1,
      out_timestamp_ns,
    );
  }

  late final _sync_time_serverPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>,
              ffi.Pointer<ffi.Int64>)>>('obx_sync_time_server');
  late final _sync_time_server = _sync_time_serverPtr.asFunction<
      int Function(ffi.Pointer<OBX_sync>, ffi.Pointer<ffi.Int64>)>();

  /// Returns the estimated difference between the server time and the local timestamp.
  /// Equivalent to calculating obx_sync_time_server() - "current time" (nanos since epoch).
  /// @param out_diff_ns time difference in nanoseconds; e.g. positive if server time is ahead of local time.
  /// Set to 0 if there has not been a server contact yet and thus the server's time is unknown.
  int sync_time_server_diff(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<ffi.Int64> out_diff_ns,
  ) {
    return _sync_time_server_diff(
      sync1,
      out_diff_ns,
    );
  }

  late final _sync_time_server_diffPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>,
              ffi.Pointer<ffi.Int64>)>>('obx_sync_time_server_diff');
  late final _sync_time_server_diff = _sync_time_server_diffPtr.asFunction<
      int Function(ffi.Pointer<OBX_sync>, ffi.Pointer<ffi.Int64>)>();

  /// Gets the protocol version this client uses.
  int sync_protocol_version() {
    return _sync_protocol_version();
  }

  late final _sync_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>(
          'obx_sync_protocol_version');
  late final _sync_protocol_version =
      _sync_protocol_versionPtr.asFunction<int Function()>();

  /// Gets the protocol version of the server after a connection is established (or attempted), zero otherwise.
  int sync_protocol_version_server(
    ffi.Pointer<OBX_sync> sync1,
  ) {
    return _sync_protocol_version_server(
      sync1,
    );
  }

  late final _sync_protocol_version_serverPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<OBX_sync>)>>(
          'obx_sync_protocol_version_server');
  late final _sync_protocol_version_server = _sync_protocol_version_serverPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync>)>();

  /// Start here to prepare an 'objects message'.
  /// Use obx_sync_msg_objects_builder_add() to set at least one object and then call obx_sync_send_msg_objects() or
  /// obx_sync_server_send_msg_objects() to initiate the sending process.
  /// @param topic optional, application-specific message qualifier (may be NULL), usually a string but can also be binary
  ffi.Pointer<OBX_sync_msg_objects_builder> sync_msg_objects_builder(
    ffi.Pointer<ffi.Uint8> topic,
    int topic_size,
  ) {
    return _sync_msg_objects_builder(
      topic,
      topic_size,
    );
  }

  late final _sync_msg_objects_builderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync_msg_objects_builder> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_sync_msg_objects_builder');
  late final _sync_msg_objects_builder =
      _sync_msg_objects_builderPtr.asFunction<
          ffi.Pointer<OBX_sync_msg_objects_builder> Function(
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Adds an object to the given message (builder). There must be at least one message before sending.
  /// @param id an optional (pass 0 if you don't need it) value that the application can use identify the object
  int sync_msg_objects_builder_add(
    ffi.Pointer<OBX_sync_msg_objects_builder> message,
    int type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
    int id,
  ) {
    return _sync_msg_objects_builder_add(
      message,
      type,
      data,
      size,
      id,
    );
  }

  late final _sync_msg_objects_builder_addPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync_msg_objects_builder>,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Uint64)>>('obx_sync_msg_objects_builder_add');
  late final _sync_msg_objects_builder_add =
      _sync_msg_objects_builder_addPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync_msg_objects_builder>, int,
              ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Free the given message if you end up not sending it. Sending frees it already so never call this after obx_*_send().
  int sync_msg_objects_builder_discard(
    ffi.Pointer<OBX_sync_msg_objects_builder> message,
  ) {
    return _sync_msg_objects_builder_discard(
      message,
    );
  }

  late final _sync_msg_objects_builder_discardPtr = _lookup<
          ffi.NativeFunction<
              obx_err Function(ffi.Pointer<OBX_sync_msg_objects_builder>)>>(
      'obx_sync_msg_objects_builder_discard');
  late final _sync_msg_objects_builder_discard =
      _sync_msg_objects_builder_discardPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync_msg_objects_builder>)>();

  /// Sends the given 'objects message' from the client to the currently connected server.
  /// @param message the prepared outgoing message; it will be freed along with any associated resources during this call
  /// (regardless of the call's success/failure outcome).
  /// @returns OBX_SUCCESS if the message was scheduled to be sent (no guarantees for actual sending/transmission given).
  /// @returns OBX_NO_SUCCESS if the message was not sent (no error will be set).
  /// @returns error code if an unexpected error occurred.
  int sync_send_msg_objects(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_msg_objects_builder> message,
  ) {
    return _sync_send_msg_objects(
      sync1,
      message,
    );
  }

  late final _sync_send_msg_objectsPtr = _lookup<
          ffi.NativeFunction<
              obx_err Function(ffi.Pointer<OBX_sync>,
                  ffi.Pointer<OBX_sync_msg_objects_builder>)>>(
      'obx_sync_send_msg_objects');
  late final _sync_send_msg_objects = _sync_send_msg_objectsPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_sync>, ffi.Pointer<OBX_sync_msg_objects_builder>)>();

  /// Set or overwrite a previously set 'connect' listener.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_connect(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_connect> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_connect(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_connect>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_connect');
  late final _sync_listener_connect = _sync_listener_connectPtr.asFunction<
      void Function(ffi.Pointer<OBX_sync>,
          ffi.Pointer<OBX_sync_listener_connect>, ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'disconnect' listener.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_disconnect(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_disconnect> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_disconnect(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_disconnectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_disconnect>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_disconnect');
  late final _sync_listener_disconnect =
      _sync_listener_disconnectPtr.asFunction<
          void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_disconnect>,
              ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'login' listener.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_login(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_login> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_login(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_loginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_login>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_login');
  late final _sync_listener_login = _sync_listener_loginPtr.asFunction<
      void Function(ffi.Pointer<OBX_sync>, ffi.Pointer<OBX_sync_listener_login>,
          ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'login failure' listener.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_login_failure(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_login_failure> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_login_failure(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_login_failurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_login_failure>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_login_failure');
  late final _sync_listener_login_failure =
      _sync_listener_login_failurePtr.asFunction<
          void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_login_failure>,
              ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'complete' listener - notifies when the latest sync has finished.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_complete(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_complete> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_complete(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_completePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_complete>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_complete');
  late final _sync_listener_complete = _sync_listener_completePtr.asFunction<
      void Function(ffi.Pointer<OBX_sync>,
          ffi.Pointer<OBX_sync_listener_complete>, ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'change' listener - provides information about incoming changes.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_change(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_change> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_change(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_changePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_change>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_change');
  late final _sync_listener_change = _sync_listener_changePtr.asFunction<
      void Function(ffi.Pointer<OBX_sync>,
          ffi.Pointer<OBX_sync_listener_change>, ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'serverTime' listener - provides current time updates from the sync-server.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_server_time(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_server_time> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_server_time(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_server_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_server_time>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_server_time');
  late final _sync_listener_server_time =
      _sync_listener_server_timePtr.asFunction<
          void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_server_time>,
              ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'objects message' listener to receive application specific data objects.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_msg_objects(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_msg_objects> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_msg_objects(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_msg_objectsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_msg_objects>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_msg_objects');
  late final _sync_listener_msg_objects =
      _sync_listener_msg_objectsPtr.asFunction<
          void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_msg_objects>,
              ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'error' listener - provides information about occurred sync-level errors.
  /// @param listener The callback to receive sync errors. Set to NULL to reset.
  /// @param listener_arg is a pass-through argument passed to the listener
  void sync_listener_error(
    ffi.Pointer<OBX_sync> sync1,
    ffi.Pointer<OBX_sync_listener_error> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_listener_error(
      sync1,
      listener,
      listener_arg,
    );
  }

  late final _sync_listener_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<OBX_sync>,
              ffi.Pointer<OBX_sync_listener_error>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_listener_error');
  late final _sync_listener_error = _sync_listener_errorPtr.asFunction<
      void Function(ffi.Pointer<OBX_sync>, ffi.Pointer<OBX_sync_listener_error>,
          ffi.Pointer<ffi.Void>)>();

  /// Get u64 value for sync statistics.
  /// @param counter_type the counter value to be read.
  /// @param out_count receives the counter value.
  /// @return OBX_SUCCESS if the counter has been successfully retrieved.
  /// @return OBX_ERROR_ILLEGAL_ARGUMENT if counter_type is undefined.
  int sync_stats_u64(
    ffi.Pointer<OBX_sync> sync1,
    int counter_type,
    ffi.Pointer<ffi.Uint64> out_count,
  ) {
    return _sync_stats_u64(
      sync1,
      counter_type,
      out_count,
    );
  }

  late final _sync_stats_u64Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync>, ffi.Int32,
              ffi.Pointer<ffi.Uint64>)>>('obx_sync_stats_u64');
  late final _sync_stats_u64 = _sync_stats_u64Ptr.asFunction<
      int Function(ffi.Pointer<OBX_sync>, int, ffi.Pointer<ffi.Uint64>)>();

  /// Prepares an ObjectBox Sync Server to run within your application (embedded server) at the given URI.
  /// Note that you need a special sync edition, which includes the server components. Check https://objectbox.io/sync/.
  /// This call opens a store with the given options (also see obx_store_open()).
  /// The server's store is tied to the server itself and is closed when the server is closed.
  /// Before actually starting the server via obx_sync_server_start(), you can configure:
  /// - accepted credentials via obx_sync_server_credentials() (always required)
  /// - SSL certificate info via obx_sync_server_certificate_path() (required if you use wss)
  /// \note The model given via store_options is also used to verify the compatibility of the models presented by clients.
  /// E.g. a client with an incompatible model will be rejected during login.
  /// @param store_options Options for the server's store.
  /// It is freed automatically (same as with obx_store_open()) - don't use or free it afterwards.
  /// @param url The URL (following the pattern "protocol://IP:port") the server should listen on.
  /// Supported \b protocols are "ws" (WebSockets) and "wss" (secure WebSockets).
  /// To use the latter ("wss"), you must also call obx_sync_server_certificate_path().
  /// To bind to all available \b interfaces, including those that are available from the "outside", use 0.0.0.0 as
  /// the IP. On the other hand, "127.0.0.1" is typically (may be OS dependent) only available on the same device.
  /// If you do not require a fixed \b port, use 0 (zero) as a port to tell the server to pick an arbitrary port
  /// that is available. The port can be queried via obx_sync_server_port() once the server was started.
  /// \b Examples: "ws://0.0.0.0:9999" could be used during development (WS no certificate config needed),
  /// while in a production system, you may want to use WSS and a specific IP for security reasons.
  /// @see obx_store_open()
  /// @returns NULL if server could not be created (e.g. the store could not be opened, bad URL, etc.)
  ffi.Pointer<OBX_sync_server> sync_server(
    ffi.Pointer<OBX_store_options> store_options,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _sync_server(
      store_options,
      url,
    );
  }

  late final _sync_serverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync_server> Function(ffi.Pointer<OBX_store_options>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_server');
  late final _sync_server = _sync_serverPtr.asFunction<
      ffi.Pointer<OBX_sync_server> Function(
          ffi.Pointer<OBX_store_options>, ffi.Pointer<ffi.Char>)>();

  /// Like obx_sync_server(), but retrieves its options for the Sync Server from the given FlatBuffers options.
  /// @param flat_options FlatBuffers serialized options for the server (start of the bytes buffer, not the "table").
  /// @param flat_options_size Size of the FlatBuffers serialized options.
  ffi.Pointer<OBX_sync_server> sync_server_from_flat_options(
    ffi.Pointer<OBX_store_options> store_options,
    ffi.Pointer<ffi.Uint8> flat_options,
    int flat_options_size,
  ) {
    return _sync_server_from_flat_options(
      store_options,
      flat_options,
      flat_options_size,
    );
  }

  late final _sync_server_from_flat_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_sync_server> Function(
              ffi.Pointer<OBX_store_options>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_sync_server_from_flat_options');
  late final _sync_server_from_flat_options =
      _sync_server_from_flat_optionsPtr.asFunction<
          ffi.Pointer<OBX_sync_server> Function(
              ffi.Pointer<OBX_store_options>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Stops and closes (deletes) the sync server, freeing its resources.
  /// This includes the store associated with the server; it gets closed and must not be used anymore after this call.
  int sync_server_close(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_close(
      server,
    );
  }

  late final _sync_server_closePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync_server>)>>(
      'obx_sync_server_close');
  late final _sync_server_close = _sync_server_closePtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>)>();

  /// Gets the store this server uses. This is owned by the server and must NOT be closed manually with obx_store_close().
  ffi.Pointer<OBX_store> sync_server_store(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_store(
      server,
    );
  }

  late final _sync_server_storePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_store> Function(
              ffi.Pointer<OBX_sync_server>)>>('obx_sync_server_store');
  late final _sync_server_store = _sync_server_storePtr.asFunction<
      ffi.Pointer<OBX_store> Function(ffi.Pointer<OBX_sync_server>)>();

  /// Sets SSL certificate for the server to use. Use before obx_sync_server_start().
  int sync_server_certificate_path(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<ffi.Char> certificate_path,
  ) {
    return _sync_server_certificate_path(
      server,
      certificate_path,
    );
  }

  late final _sync_server_certificate_pathPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_server_certificate_path');
  late final _sync_server_certificate_path =
      _sync_server_certificate_pathPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync_server>, ffi.Pointer<ffi.Char>)>();

  /// Sets credentials for the server to accept. Use before obx_sync_server_start().
  /// @param data may be NULL in combination with OBXSyncCredentialsType_NONE
  int sync_server_credentials(
    ffi.Pointer<OBX_sync_server> server,
    int type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _sync_server_credentials(
      server,
      type,
      data,
      size,
    );
  }

  late final _sync_server_credentialsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync_server>,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_sync_server_credentials');
  late final _sync_server_credentials = _sync_server_credentialsPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_sync_server>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Enables authenticator for server. Can be called multiple times. Use before obx_sync_server_start().
  /// Use obx_sync_server_credentials() for authenticators which requires additional credentials data (i.e. Google Auth
  /// and shared secrets authenticators).
  /// @param type should be one of the available authentications, it should not be OBXSyncCredentialsType_USER_PASSWORD.
  int sync_server_enable_auth(
    ffi.Pointer<OBX_sync_server> server,
    int type,
  ) {
    return _sync_server_enable_auth(
      server,
      type,
    );
  }

  late final _sync_server_enable_authPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>,
              ffi.Int32)>>('obx_sync_server_enable_auth');
  late final _sync_server_enable_auth = _sync_server_enable_authPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>, int)>();

  /// Sets the number of worker threads. Use before obx_sync_server_start().
  /// @param thread_count The default is "0" which is hardware dependent, e.g. a multiple of CPU "cores".
  int sync_server_worker_threads(
    ffi.Pointer<OBX_sync_server> server,
    int thread_count,
  ) {
    return _sync_server_worker_threads(
      server,
      thread_count,
    );
  }

  late final _sync_server_worker_threadsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>,
              ffi.Int)>>('obx_sync_server_worker_threads');
  late final _sync_server_worker_threads = _sync_server_worker_threadsPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>, int)>();

  /// Sets a maximum size for sync history entries to limit storage: old entries are removed to stay below this limit.
  /// Deleting older history entries may require clients to do a full sync if they have not contacted the server for
  /// a certain time.
  /// @param max_in_kb Once this maximum size is reached, old history entries are deleted (default 0: no limit).
  /// @param target_in_kb If this value is non-zero, the deletion of old history entries is extended until reaching this
  /// target (lower than the maximum) allowing deletion "batching", which may be more efficient.
  /// If zero, the deletion stops already stops when reaching the max size (or lower).
  int sync_server_history_max_size_in_kb(
    ffi.Pointer<OBX_sync_server> server,
    int max_in_kb,
    int target_in_kb,
  ) {
    return _sync_server_history_max_size_in_kb(
      server,
      max_in_kb,
      target_in_kb,
    );
  }

  late final _sync_server_history_max_size_in_kbPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>, ffi.Uint64,
              ffi.Uint64)>>('obx_sync_server_history_max_size_in_kb');
  late final _sync_server_history_max_size_in_kb =
      _sync_server_history_max_size_in_kbPtr
          .asFunction<int Function(ffi.Pointer<OBX_sync_server>, int, int)>();

  /// Configures the cluster ID for the given embedded server (the cluster feature must be enabled).
  /// @param id A user defined string to identify the cluster (all cluster peer must share the same ID).
  int sync_server_cluster_id(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<ffi.Char> id,
  ) {
    return _sync_server_cluster_id(
      server,
      id,
    );
  }

  late final _sync_server_cluster_idPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<ffi.Char>)>>('obx_sync_server_cluster_id');
  late final _sync_server_cluster_id = _sync_server_cluster_idPtr.asFunction<
      int Function(ffi.Pointer<OBX_sync_server>, ffi.Pointer<ffi.Char>)>();

  /// Adds a remote cluster peer that can be connected to using the given URL and credentials.
  /// Call this method multiple times to add multiple peers (at least 2 times for a cluster of 3).
  /// @param url URL to the remote cluster peer used to connect it.
  /// @param flags For now, always pass 0.
  /// @param credentials the credentials provided to the remote peer to login (it must match the remote's configuration).
  /// May be NULL in combination with OBXSyncCredentialsType_NONE.
  int sync_server_add_cluster_peer(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<ffi.Char> url,
    int credentials_type,
    ffi.Pointer<ffi.Uint8> credentials,
    int credentials_size,
    int flags,
  ) {
    return _sync_server_add_cluster_peer(
      server,
      url,
      credentials_type,
      credentials,
      credentials_size,
      flags,
    );
  }

  late final _sync_server_add_cluster_peerPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Uint32)>>('obx_sync_server_add_cluster_peer');
  late final _sync_server_add_cluster_peer =
      _sync_server_add_cluster_peerPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync_server>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Set or overwrite a previously set 'change' listener - provides information about incoming changes.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  int sync_server_listener_change(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<OBX_sync_listener_change> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_server_listener_change(
      server,
      listener,
      listener_arg,
    );
  }

  late final _sync_server_listener_changePtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<OBX_sync_listener_change>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_server_listener_change');
  late final _sync_server_listener_change =
      _sync_server_listener_changePtr.asFunction<
          int Function(ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<OBX_sync_listener_change>, ffi.Pointer<ffi.Void>)>();

  /// Set or overwrite a previously set 'objects message' listener to receive application specific data objects.
  /// @param listener set NULL to reset
  /// @param listener_arg is a pass-through argument passed to the listener
  int sync_server_listener_msg_objects(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<OBX_sync_listener_msg_objects> listener,
    ffi.Pointer<ffi.Void> listener_arg,
  ) {
    return _sync_server_listener_msg_objects(
      server,
      listener,
      listener_arg,
    );
  }

  late final _sync_server_listener_msg_objectsPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<OBX_sync_listener_msg_objects>,
              ffi.Pointer<ffi.Void>)>>('obx_sync_server_listener_msg_objects');
  late final _sync_server_listener_msg_objects =
      _sync_server_listener_msg_objectsPtr.asFunction<
          int Function(
              ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<OBX_sync_listener_msg_objects>,
              ffi.Pointer<ffi.Void>)>();

  /// After the sync server is fully configured (e.g. credentials), this will actually start the server.
  /// Once this call returns, the server is ready to accept client connections. Also, port and URL will be available.
  int sync_server_start(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_start(
      server,
    );
  }

  late final _sync_server_startPtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync_server>)>>(
      'obx_sync_server_start');
  late final _sync_server_start = _sync_server_startPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>)>();

  /// Stops this sync server. Does nothing if it is already stopped.
  int sync_server_stop(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_stop(
      server,
    );
  }

  late final _sync_server_stopPtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_sync_server>)>>(
      'obx_sync_server_stop');
  late final _sync_server_stop = _sync_server_stopPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>)>();

  /// Whether the server is up and running.
  bool sync_server_running(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_running(
      server,
    );
  }

  late final _sync_server_runningPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<OBX_sync_server>)>>(
      'obx_sync_server_running');
  late final _sync_server_running = _sync_server_runningPtr
      .asFunction<bool Function(ffi.Pointer<OBX_sync_server>)>();

  /// Returns a URL this server is listening on, including the bound port (see obx_sync_server_port().
  /// The returned char* is valid until another call to obx_sync_server_url() or the server is closed.
  ffi.Pointer<ffi.Char> sync_server_url(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_url(
      server,
    );
  }

  late final _sync_server_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<OBX_sync_server>)>>('obx_sync_server_url');
  late final _sync_server_url = _sync_server_urlPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_sync_server>)>();

  /// Returns a port this server listens on. This is especially useful if the port was assigned arbitrarily
  /// (a "0" port was used in the URL given to obx_sync_server()).
  int sync_server_port(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_port(
      server,
    );
  }

  late final _sync_server_portPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint16 Function(ffi.Pointer<OBX_sync_server>)>>(
      'obx_sync_server_port');
  late final _sync_server_port = _sync_server_portPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>)>();

  /// Returns the number of clients connected to this server.
  int sync_server_connections(
    ffi.Pointer<OBX_sync_server> server,
  ) {
    return _sync_server_connections(
      server,
    );
  }

  late final _sync_server_connectionsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint64 Function(ffi.Pointer<OBX_sync_server>)>>(
      'obx_sync_server_connections');
  late final _sync_server_connections = _sync_server_connectionsPtr
      .asFunction<int Function(ffi.Pointer<OBX_sync_server>)>();

  /// Get u64 value for sync server statistics.
  /// @param counter_type the counter value to be read (make sure to choose a uint64_t (u64) metric value type).
  /// @param out_value receives the counter value.
  /// @return OBX_SUCCESS if the counter has been successfully retrieved.
  /// @return OBX_ERROR_ILLEGAL_ARGUMENT if counter_type is undefined (this also happens if the wrong type is requested)
  /// @return OBX_ERROR_ILLEGAL_STATE if the server is not started.
  int sync_server_stats_u64(
    ffi.Pointer<OBX_sync_server> server,
    int counter_type,
    ffi.Pointer<ffi.Uint64> out_value,
  ) {
    return _sync_server_stats_u64(
      server,
      counter_type,
      out_value,
    );
  }

  late final _sync_server_stats_u64Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>, ffi.Int32,
              ffi.Pointer<ffi.Uint64>)>>('obx_sync_server_stats_u64');
  late final _sync_server_stats_u64 = _sync_server_stats_u64Ptr.asFunction<
      int Function(
          ffi.Pointer<OBX_sync_server>, int, ffi.Pointer<ffi.Uint64>)>();

  /// Get double value for sync server statistics.
  /// @param counter_type the counter value to be read (make sure to use a double (f64) metric value type).
  /// @param out_value receives the counter value.
  /// @return OBX_SUCCESS if the counter has been successfully retrieved.
  /// @return OBX_ERROR_ILLEGAL_ARGUMENT if counter_type is undefined (this also happens if the wrong type is requested)
  /// @return OBX_ERROR_ILLEGAL_STATE if the server is not started.
  int sync_server_stats_f64(
    ffi.Pointer<OBX_sync_server> server,
    int counter_type,
    ffi.Pointer<ffi.Double> out_value,
  ) {
    return _sync_server_stats_f64(
      server,
      counter_type,
      out_value,
    );
  }

  late final _sync_server_stats_f64Ptr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_sync_server>, ffi.Int32,
              ffi.Pointer<ffi.Double>)>>('obx_sync_server_stats_f64');
  late final _sync_server_stats_f64 = _sync_server_stats_f64Ptr.asFunction<
      int Function(
          ffi.Pointer<OBX_sync_server>, int, ffi.Pointer<ffi.Double>)>();

  /// Get server runtime statistics.
  /// The returned char* is valid until another call to obx_sync_server_stats_string() or the server is closed.
  ffi.Pointer<ffi.Char> sync_server_stats_string(
    ffi.Pointer<OBX_sync_server> server,
    bool include_zero_values,
  ) {
    return _sync_server_stats_string(
      server,
      include_zero_values,
    );
  }

  late final _sync_server_stats_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_sync_server>,
              ffi.Bool)>>('obx_sync_server_stats_string');
  late final _sync_server_stats_string =
      _sync_server_stats_stringPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<OBX_sync_server>, bool)>();

  /// Broadcast the given 'objects message' from the server to all currently connected (and logged-in) clients.
  /// @param message the prepared outgoing message; it will be freed along with any associated resources during this call
  /// (regardless of the call's success/failure outcome).
  /// @returns OBX_SUCCESS if the message was scheduled to be sent (no guarantees for actual sending/transmission given).
  /// @returns OBX_NO_SUCCESS if the message was not sent (no error will be set).
  /// @returns error code if an unexpected error occurred.
  int sync_server_send_msg_objects(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<OBX_sync_msg_objects_builder> message,
  ) {
    return _sync_server_send_msg_objects(
      server,
      message,
    );
  }

  late final _sync_server_send_msg_objectsPtr = _lookup<
          ffi.NativeFunction<
              obx_err Function(ffi.Pointer<OBX_sync_server>,
                  ffi.Pointer<OBX_sync_msg_objects_builder>)>>(
      'obx_sync_server_send_msg_objects');
  late final _sync_server_send_msg_objects =
      _sync_server_send_msg_objectsPtr.asFunction<
          int Function(ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<OBX_sync_msg_objects_builder>)>();

  /// Configure admin with a sync server, attaching the store and enabling custom sync-server functionality in the UI.
  /// This is a replacement for obx_admin_opt_store() and obx_admin_opt_store_path() - don't set them for the server.
  /// After configuring, this acts as obx_admin() - see for more details.
  /// You must use obx_admin_close() to stop & free resources after you're done; obx_sync_server_stop() doesn't do that.
  /// @param options configuration set up with obx_admin_opt_*. You can pass NULL to use the default options.
  ffi.Pointer<OBX_admin> sync_server_admin(
    ffi.Pointer<OBX_sync_server> server,
    ffi.Pointer<OBX_admin_options> options,
  ) {
    return _sync_server_admin(
      server,
      options,
    );
  }

  late final _sync_server_adminPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_admin> Function(ffi.Pointer<OBX_sync_server>,
              ffi.Pointer<OBX_admin_options>)>>('obx_sync_server_admin');
  late final _sync_server_admin = _sync_server_adminPtr.asFunction<
      ffi.Pointer<OBX_admin> Function(
          ffi.Pointer<OBX_sync_server>, ffi.Pointer<OBX_admin_options>)>();

  /// Must be called to register a protocol for a custom messaging server. Call before starting a server.
  /// @param protocol the communication protocol to use, e.g. "tcp"
  /// @param functions the custom server function callbacks
  /// @param config_user_data user provided data set at registration of custom server
  /// @returns OBX_SUCCESS if the operation was successful
  /// @returns Any other fitting error code (OBX_ERROR_*) if the protocol could not be registered
  int custom_msg_server_register(
    ffi.Pointer<ffi.Char> protocol,
    ffi.Pointer<OBX_custom_msg_server_functions> functions,
    ffi.Pointer<ffi.Void> config_user_data,
  ) {
    return _custom_msg_server_register(
      protocol,
      functions,
      config_user_data,
    );
  }

  late final _custom_msg_server_registerPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<OBX_custom_msg_server_functions>,
              ffi.Pointer<ffi.Void>)>>('obx_custom_msg_server_register');
  late final _custom_msg_server_register =
      _custom_msg_server_registerPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<OBX_custom_msg_server_functions>,
              ffi.Pointer<ffi.Void>)>();

  /// Must be called from the custom server when a new client connection becomes available.
  /// @param server_id the ID that was assigned to the custom server instance
  /// @param user_data user provided data set at registration of custom server
  /// @returns a client connection ID that must be passed on to obx_custom_msg_server_receive_message_from_client().
  /// @returns 0 in case the operation encountered an exceptional issue
  int custom_msg_server_add_client_connection(
    int server_id,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _custom_msg_server_add_client_connection(
      server_id,
      user_data,
    );
  }

  late final _custom_msg_server_add_client_connectionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Uint64, ffi.Pointer<ffi.Void>)>>(
      'obx_custom_msg_server_add_client_connection');
  late final _custom_msg_server_add_client_connection =
      _custom_msg_server_add_client_connectionPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>)>();

  /// Must be called from the custom server when a client connection becomes inactive (e.g. closed) and can be removed.
  /// @param server_id the ID that was assigned to the custom server instance
  /// @param client_connection_id the ID that was assigned to the custom client connection
  /// @returns OBX_SUCCESS if the operation was successful
  /// @returns OBX_NO_SUCCESS if no active server or active connection was found matching the given IDs
  /// @returns OBX_ERROR_* in case the operation encountered an exceptional issue
  int custom_msg_server_remove_client_connection(
    int server_id,
    int client_connection_id,
  ) {
    return _custom_msg_server_remove_client_connection(
      server_id,
      client_connection_id,
    );
  }

  late final _custom_msg_server_remove_client_connectionPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Uint64, ffi.Uint64)>>(
          'obx_custom_msg_server_remove_client_connection');
  late final _custom_msg_server_remove_client_connection =
      _custom_msg_server_remove_client_connectionPtr
          .asFunction<int Function(int, int)>();

  /// Must be called from the custom server when a message is received from a client connection.
  /// @param server_id the ID that was assigned to the custom server instance
  /// @param client_connection_id the ID that was assigned to the custom client connection
  /// @param message_data the message data in bytes
  /// @returns OBX_SUCCESS if the operation was successful
  /// @returns OBX_NO_SUCCESS if no active server or active connection was found matching the given IDs
  /// @returns OBX_ERROR_* in case the operation encountered an exceptional issue
  int custom_msg_server_receive_message_from_client(
    int server_id,
    int client_connection_id,
    ffi.Pointer<ffi.Uint8> message_data,
    int message_size,
  ) {
    return _custom_msg_server_receive_message_from_client(
      server_id,
      client_connection_id,
      message_data,
      message_size,
    );
  }

  late final _custom_msg_server_receive_message_from_clientPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_custom_msg_server_receive_message_from_client');
  late final _custom_msg_server_receive_message_from_client =
      _custom_msg_server_receive_message_from_clientPtr
          .asFunction<int Function(int, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Must be called to register a protocol for your custom messaging client. Call before starting a client.
  /// @param protocol the communication protocol to use, e.g. "tcp"
  /// @returns OBX_SUCCESS if the operation was successful
  /// @returns Any other fitting error code (OBX_ERROR_*) if the protocol could not be registered
  int custom_msg_client_register(
    ffi.Pointer<ffi.Char> protocol,
    ffi.Pointer<OBX_custom_msg_client_functions> functions,
    ffi.Pointer<ffi.Void> config_user_data,
  ) {
    return _custom_msg_client_register(
      protocol,
      functions,
      config_user_data,
    );
  }

  late final _custom_msg_client_registerPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<OBX_custom_msg_client_functions>,
              ffi.Pointer<ffi.Void>)>>('obx_custom_msg_client_register');
  late final _custom_msg_client_register =
      _custom_msg_client_registerPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<OBX_custom_msg_client_functions>,
              ffi.Pointer<ffi.Void>)>();

  /// The custom msg client must call this whenever a message is received from the server.
  /// @param client_id the ID that was assigned to the client instance
  /// @param message_data the message data in bytes
  /// @returns OBX_SUCCESS if the given message could be forwarded
  /// @returns OBX_NO_SUCCESS if no active client or active connection was found matching the given ID
  /// @returns OBX_ERROR_* in case the operation encountered an exceptional issue
  int custom_msg_client_receive_message_from_server(
    int client_id,
    ffi.Pointer<ffi.Uint8> message_data,
    int message_size,
  ) {
    return _custom_msg_client_receive_message_from_server(
      client_id,
      message_data,
      message_size,
    );
  }

  late final _custom_msg_client_receive_message_from_serverPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Uint64, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('obx_custom_msg_client_receive_message_from_server');
  late final _custom_msg_client_receive_message_from_server =
      _custom_msg_client_receive_message_from_serverPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Uint8>, int)>();

  /// The custom msg client must call this whenever the state (according to given enum values) changes.
  /// @param client_id the ID that was assigned to the client instance
  /// @param state the state to transition the custom client to
  /// @returns OBX_SUCCESS if the client was in a state that allowed the transition to the given state.
  /// @returns OBX_NO_SUCCESS if no active client or active connection was found matching the given ID.
  /// @returns OBX_NO_SUCCESS if no state transition was possible from the current to the given state (e.g. an internal
  /// "closed" state was reached).
  /// @returns OBX_ERROR_* in case the operation encountered an exceptional issue
  int custom_msg_client_set_state(
    int client_id,
    int state,
  ) {
    return _custom_msg_client_set_state(
      client_id,
      state,
    );
  }

  late final _custom_msg_client_set_statePtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Uint64, ffi.Int32)>>(
          'obx_custom_msg_client_set_state');
  late final _custom_msg_client_set_state =
      _custom_msg_client_set_statePtr.asFunction<int Function(int, int)>();

  /// The custom msg client may call this if it has knowledge when a reconnection attempt makes sense,
  /// for example, when the network becomes available.
  /// @param client_id the ID that was assigned to the client instance
  /// @returns OBX_SUCCESS if a reconnect was actually triggered.
  /// @returns OBX_NO_SUCCESS if no reconnect was triggered.
  /// @returns OBX_ERROR_* in case the operation encountered an exceptional issue
  int custom_msg_client_trigger_reconnect(
    int client_id,
  ) {
    return _custom_msg_client_trigger_reconnect(
      client_id,
    );
  }

  late final _custom_msg_client_trigger_reconnectPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Uint64)>>(
          'obx_custom_msg_client_trigger_reconnect');
  late final _custom_msg_client_trigger_reconnect =
      _custom_msg_client_trigger_reconnectPtr.asFunction<int Function(int)>();

  /// Initializes Dart API - call before any other obx_dart_* functions.
  int dartc_init_api(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _dartc_init_api(
      data,
    );
  }

  late final _dartc_init_apiPtr =
      _lookup<ffi.NativeFunction<obx_err Function(ffi.Pointer<ffi.Void>)>>(
          'obx_dart_init_api');
  late final _dartc_init_api =
      _dartc_init_apiPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// @see obx_observe()
  /// Note: use obx_observer_close() to free unassign the observer and free resources after you're done with it
  ffi.Pointer<OBX_observer> dartc_observe(
    ffi.Pointer<OBX_store> store,
    int native_port,
  ) {
    return _dartc_observe(
      store,
      native_port,
    );
  }

  late final _dartc_observePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_observer> Function(
              ffi.Pointer<OBX_store>, ffi.Int64)>>('obx_dart_observe');
  late final _dartc_observe = _dartc_observePtr.asFunction<
      ffi.Pointer<OBX_observer> Function(ffi.Pointer<OBX_store>, int)>();

  ffi.Pointer<OBX_observer> dartc_observe_single_type(
    ffi.Pointer<OBX_store> store,
    int type_id,
    int native_port,
  ) {
    return _dartc_observe_single_type(
      store,
      type_id,
      native_port,
    );
  }

  late final _dartc_observe_single_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_observer> Function(ffi.Pointer<OBX_store>,
              obx_schema_id, ffi.Int64)>>('obx_dart_observe_single_type');
  late final _dartc_observe_single_type =
      _dartc_observe_single_typePtr.asFunction<
          ffi.Pointer<OBX_observer> Function(
              ffi.Pointer<OBX_store>, int, int)>();

  /// @param listener may be NULL
  int dartc_sync_listener_close(
    ffi.Pointer<OBX_dart_sync_listener> listener,
  ) {
    return _dartc_sync_listener_close(
      listener,
    );
  }

  late final _dartc_sync_listener_closePtr = _lookup<
          ffi.NativeFunction<
              obx_err Function(ffi.Pointer<OBX_dart_sync_listener>)>>(
      'obx_dart_sync_listener_close');
  late final _dartc_sync_listener_close = _dartc_sync_listener_closePtr
      .asFunction<int Function(ffi.Pointer<OBX_dart_sync_listener>)>();

  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_connect(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_connect(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_connect');
  late final _dartc_sync_listener_connect =
      _dartc_sync_listener_connectPtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_sync_listener_disconnect()
  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_disconnect(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_disconnect(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_disconnectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_disconnect');
  late final _dartc_sync_listener_disconnect =
      _dartc_sync_listener_disconnectPtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_sync_listener_login()
  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_login(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_login(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_loginPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_login');
  late final _dartc_sync_listener_login =
      _dartc_sync_listener_loginPtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_sync_listener_login_failure()
  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_login_failure(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_login_failure(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_login_failurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_login_failure');
  late final _dartc_sync_listener_login_failure =
      _dartc_sync_listener_login_failurePtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_sync_listener_complete()
  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_complete(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_complete(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_completePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_complete');
  late final _dartc_sync_listener_complete =
      _dartc_sync_listener_completePtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_sync_listener_change()
  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_change(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_change(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_changePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_change');
  late final _dartc_sync_listener_change =
      _dartc_sync_listener_changePtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_sync_listener_server_time()
  ffi.Pointer<OBX_dart_sync_listener> dartc_sync_listener_server_time(
    ffi.Pointer<OBX_sync> sync1,
    int native_port,
  ) {
    return _dartc_sync_listener_server_time(
      sync1,
      native_port,
    );
  }

  late final _dartc_sync_listener_server_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(ffi.Pointer<OBX_sync>,
              ffi.Int64)>>('obx_dart_sync_listener_server_time');
  late final _dartc_sync_listener_server_time =
      _dartc_sync_listener_server_timePtr.asFunction<
          ffi.Pointer<OBX_dart_sync_listener> Function(
              ffi.Pointer<OBX_sync>, int)>();

  /// @see obx_async_put_object()
  int dartc_async_put_object(
    ffi.Pointer<OBX_async> async1,
    int native_port,
    ffi.Pointer<ffi.Void> data,
    int size,
    int mode,
  ) {
    return _dartc_async_put_object(
      async1,
      native_port,
      data,
      size,
      mode,
    );
  }

  late final _dartc_async_put_objectPtr = _lookup<
      ffi.NativeFunction<
          obx_id Function(
              ffi.Pointer<OBX_async>,
              ffi.Int64,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int32)>>('obx_dart_async_put_object');
  late final _dartc_async_put_object = _dartc_async_put_objectPtr.asFunction<
      int Function(
          ffi.Pointer<OBX_async>, int, ffi.Pointer<ffi.Void>, int, int)>();

  int dartc_stream_close(
    ffi.Pointer<OBX_dart_stream> stream,
  ) {
    return _dartc_stream_close(
      stream,
    );
  }

  late final _dartc_stream_closePtr = _lookup<
          ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_dart_stream>)>>(
      'obx_dart_stream_close');
  late final _dartc_stream_close = _dartc_stream_closePtr
      .asFunction<int Function(ffi.Pointer<OBX_dart_stream>)>();

  /// @see obx_dart_stream_query_find
  ffi.Pointer<OBX_dart_stream> dartc_query_find(
    ffi.Pointer<OBX_query> query,
    int native_port,
  ) {
    return _dartc_query_find(
      query,
      native_port,
    );
  }

  late final _dartc_query_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_stream> Function(
              ffi.Pointer<OBX_query>, ffi.Int64)>>('obx_dart_query_find');
  late final _dartc_query_find = _dartc_query_findPtr.asFunction<
      ffi.Pointer<OBX_dart_stream> Function(ffi.Pointer<OBX_query>, int)>();

  ffi.Pointer<OBX_dart_stream> dartc_query_find_ptr(
    ffi.Pointer<OBX_query> query,
    int native_port,
  ) {
    return _dartc_query_find_ptr(
      query,
      native_port,
    );
  }

  late final _dartc_query_find_ptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_stream> Function(
              ffi.Pointer<OBX_query>, ffi.Int64)>>('obx_dart_query_find_ptr');
  late final _dartc_query_find_ptr = _dartc_query_find_ptrPtr.asFunction<
      ffi.Pointer<OBX_dart_stream> Function(ffi.Pointer<OBX_query>, int)>();

  /// Attaches a finalizer (destructor) to be called when the given object is garbage-collected.
  /// @param dart_object marks the object owning the native pointer
  /// @param native_object is the native pointer to be freed
  /// @param closer is the function that frees native_object
  /// @param native_object_size is an allocated size estimate - can be used by a the Dart garbage collector to prioritize
  /// @return a finalizer freed automatically when the GC finalizer runs (or manually by obx_dart_detach_finalizer())
  /// @return NULL if the finalizer couldn't be attached, in which case the caller is responsible for running the closer
  ffi.Pointer<OBX_dart_finalizer> dartc_attach_finalizer(
    Object dart_object,
    ffi.Pointer<obx_dart_closer> closer,
    ffi.Pointer<ffi.Void> native_object,
    int native_object_size,
  ) {
    return _dartc_attach_finalizer(
      dart_object,
      closer,
      native_object,
      native_object_size,
    );
  }

  late final _dartc_attach_finalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<OBX_dart_finalizer> Function(
              ffi.Handle,
              ffi.Pointer<obx_dart_closer>,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('obx_dart_attach_finalizer');
  late final _dartc_attach_finalizer = _dartc_attach_finalizerPtr.asFunction<
      ffi.Pointer<OBX_dart_finalizer> Function(
          Object, ffi.Pointer<obx_dart_closer>, ffi.Pointer<ffi.Void>, int)>();

  /// Detach the finalizer preliminarily, without executing its "closer"
  int dartc_detach_finalizer(
    ffi.Pointer<OBX_dart_finalizer> finalizer,
    Object dart_object,
  ) {
    return _dartc_detach_finalizer(
      finalizer,
      dart_object,
    );
  }

  late final _dartc_detach_finalizerPtr = _lookup<
      ffi.NativeFunction<
          obx_err Function(ffi.Pointer<OBX_dart_finalizer>,
              ffi.Handle)>>('obx_dart_detach_finalizer');
  late final _dartc_detach_finalizer = _dartc_detach_finalizerPtr
      .asFunction<int Function(ffi.Pointer<OBX_dart_finalizer>, Object)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final ObjectBoxC _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_store>)>>
      get store_close => _library._store_closePtr;
  ffi.Pointer<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_query>)>>
      get query_close => _library._query_closePtr;
  ffi.Pointer<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_query_prop>)>>
      get query_prop_close => _library._query_prop_closePtr;
  ffi.Pointer<ffi.NativeFunction<obx_err Function(ffi.Pointer<OBX_admin>)>>
      get admin_close => _library._admin_closePtr;
}

/// Object ID with its associated query score, which is used for special query results.
class OBX_id_score extends ffi.Struct {
  @obx_id()
  external int id;

  /// The query score indicates some quality measurement.
  /// E.g. for vector nearest neighbor searches, the score is the distance to the given vector.
  @ffi.Double()
  external double score;
}

/// ID of a single Object stored in the database
typedef obx_id = ffi.Uint64;

/// This bytes score struct is an input/output wrapper used for a single data object (represented as FlatBuffers)
/// with its associated query score, which is used for special query results.
class OBX_bytes_score extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;

  /// The query score indicates some quality measurement.
  /// E.g. for vector nearest neighbor searches, the score is the distance to the given vector.
  @ffi.Double()
  external double score;
}

abstract class OBXFeature {
  /// Functions that are returning multiple results (e.g. multiple objects) can be only used if this is available.
  /// This is only available for 64-bit OSes and is the opposite of "chunked mode", which forces to consume results
  /// in chunks (e.g. one by one).
  /// Since chunked mode consumes a bit less RAM, ResultArray style functions are typically only preferable if
  /// there's an additional overhead per call, e.g. caused by a higher level language abstraction like CGo.
  static const int ResultArray = 1;

  /// TimeSeries support (date/date-nano companion ID and other time-series functionality).
  static const int TimeSeries = 2;

  /// Sync client availability. Visit https://objectbox.io/sync for more details.
  static const int Sync = 3;

  /// Check whether debug log can be enabled during runtime.
  static const int DebugLog = 4;

  /// Admin UI including a database browser, user management, and more.
  /// Depends on HttpServer (if Admin is available HttpServer is too).
  static const int Admin = 5;

  /// Tree with special GraphQL support
  static const int Tree = 6;

  /// Sync server availability. Visit https://objectbox.io/sync for more details.
  static const int SyncServer = 7;

  /// Implicitly added by Sync or SyncServer; disable via NoWebSockets
  static const int WebSockets = 8;

  /// Sync Server has cluster functionality.
  /// Implicitly added by SyncServer; disable via NoCluster
  static const int Cluster = 9;

  /// Embedded HTTP server.
  static const int HttpServer = 10;

  /// Embedded GraphQL server (via HTTP).
  /// Depends on HttpServer (if GraphQL is available HttpServer is too).
  static const int GraphQL = 11;

  /// Database Backup functionality; typically only enabled in Sync Server builds.
  static const int Backup = 12;

  /// The default database "provider"; writes data persistently to disk (ACID).
  static const int Lmdb = 13;

  /// Vector search functionality; enables indexing for nearest neighbor search.
  static const int VectorSearch = 14;

  /// WAL (write-ahead logging).
  static const int Wal = 15;

  /// Sync connector to integrate MongoDB with SyncServer.
  static const int SyncMongoDb = 16;

  /// Enables additional authentication/authorization methods for sync login, e.g. JWT based methods.
  static const int Auth = 17;

  /// This is a free trial version; only applies to server builds (no trial builds for database and Sync clients).
  static const int Trial = 18;

  /// Server-side filters to return individual data for each sync user (user-specific data).
  static const int SyncFilters = 19;
}

/// Log level as passed to obx_log_callback.
abstract class OBXLogLevel {
  /// Log level for verbose messages (not emitted at the moment)
  static const int Verbose = 10;

  /// Log level for debug messages (may be limited to special debug builds)
  static const int Debug = 20;

  /// Log level for info messages
  static const int Info = 30;

  /// Log level for warning messages
  static const int Warn = 40;

  /// Log level for error messages
  static const int Error = 50;
}

/// Error/success code returned by an obx_* function; see defines OBX_SUCCESS, OBX_NOT_FOUND, and OBX_ERROR_*
typedef obx_err = ffi.Int;

abstract class OBXPropertyType {
  /// < Not a actual type; represents an uninitialized or invalid type
  static const int Unknown = 0;

  /// < A boolean (flag)
  static const int Bool = 1;

  /// < 8-bit integer
  static const int Byte = 2;

  /// < 16-bit integer
  static const int Short = 3;

  /// < 16-bit character
  static const int Char = 4;

  /// < 32-bit integer
  static const int Int = 5;

  /// < 64-bit integer
  static const int Long = 6;

  /// < 32-bit floating point number
  static const int Float = 7;

  /// < 64-bit floating point number
  static const int Double = 8;

  /// < UTF-8 encoded string (variable length)
  static const int String = 9;

  /// < 64-bit (integer) timestamp; milliseconds since 1970-01-01 (unix epoch)
  static const int Date = 10;

  /// < Relation to another entity
  static const int Relation = 11;

  /// < High precision 64-bit timestamp; nanoseconds since 1970-01-01 (unix epoch)
  static const int DateNano = 12;

  /// < Flexible" type, which may contain scalars (integers, floating points), strings or
  /// < containers (lists and maps). Note: a flex map must use string keys.
  static const int Flex = 13;

  /// < Variable sized vector of Bool values (note: each value is one byte)
  static const int BoolVector = 22;

  /// < Variable sized vector of Byte values (8-bit integers)
  static const int ByteVector = 23;

  /// < Variable sized vector of Short values (16-bit integers)
  static const int ShortVector = 24;

  /// < Variable sized vector of Char values (16-bit characters)
  static const int CharVector = 25;

  /// < Variable sized vector of Int values (32-bit integers)
  static const int IntVector = 26;

  /// < Variable sized vector of Long values (64-bit integers)
  static const int LongVector = 27;

  /// < Variable sized vector of Float values (32-bit floating point numbers)
  static const int FloatVector = 28;

  /// < Variable sized vector of Double values (64-bit floating point numbers)
  static const int DoubleVector = 29;

  /// < Variable sized vector of String values (UTF-8 encoded strings).
  static const int StringVector = 30;

  /// < Variable sized vector of Date values (64-bit timestamp).
  static const int DateVector = 31;

  /// < Variable sized vector of Date values (high precision 64-bit timestamp).
  static const int DateNanoVector = 32;
}

/// The vector distance algorithm used by an HNSW index (vector search).
abstract class OBXVectorDistanceType {
  /// Not a real type, just best practice (e.g. forward compatibility)
  static const int Unknown = 0;

  /// The default; typically "Euclidean squared" internally.
  static const int Euclidean = 1;

  /// Cosine similarity compares two vectors irrespective of their magnitude (compares the angle of two vectors).
  /// Often used for document or semantic similarity.
  /// Value range: 0.0 - 2.0 (0.0: same direction, 1.0: orthogonal, 2.0: opposite direction)
  static const int Cosine = 2;

  /// For normalized vectors (vector length == 1.0), the dot product is equivalent to the cosine similarity.
  /// Because of this, the dot product is often preferred as it performs better.
  /// Value range (normalized vectors): 0.0 - 2.0 (0.0: same direction, 1.0: orthogonal, 2.0: opposite direction)
  static const int DotProduct = 3;

  /// For geospatial coordinates aka latitude/longitude pairs.
  /// Note, that the vector dimension must be 2, with the latitude being the first element and longitude the second.
  /// Internally, this uses haversine distance.
  static const int Geo = 6;

  /// A custom dot product similarity measure that does not require the vectors to be normalized.
  /// Note: this is no replacement for cosine similarity (like DotProduct for normalized vectors is).
  /// The non-linear conversion provides a high precision over the entire float range (for the raw dot product).
  /// The higher the dot product, the lower the distance is (the nearer the vectors are).
  /// The more negative the dot product, the higher the distance is (the farther the vectors are).
  /// Value range: 0.0 - 2.0 (nonlinear; 0.0: nearest, 1.0: orthogonal, 2.0: farthest)
  static const int DotProductNonNormalized = 10;
}

/// Bit-flags to influence the behavior of HNSW index (vector search).
abstract class OBXHnswFlags {
  static const int None = 0;

  /// Enables debug logs.
  static const int DebugLogs = 1;

  /// Enables "high volume" debug logs, e.g. individual gets/puts.
  static const int DebugLogsDetailed = 2;

  /// Padding for SIMD is enabled by default, which uses more memory but may be faster. This flag turns it off.
  static const int VectorCacheSimdPaddingOff = 4;

  /// If the speed of removing nodes becomes a concern in your use case, you can speed it up by setting this flag.
  /// By default, repairing the graph after node removals creates more connections to improve the graph's quality.
  /// The extra costs for this are relatively low (e.g. vs. regular indexing), and thus the default is recommended.
  static const int ReparationLimitCandidates = 8;
}

/// Bit-flags defining the behavior of entities.
/// Note: Numbers indicate the bit position
abstract class OBXEntityFlags {
  /// Enable "data synchronization" for this entity type: objects will be synced with other stores over the network.
  /// It's possible to have local-only (non-synced) types and synced types in the same store (schema/data model).
  static const int SYNC_ENABLED = 2;

  /// Makes object IDs for a synced types (SYNC_ENABLED is set) global.
  /// By default (not using this flag), the 64 bit object IDs have a local scope and are not unique globally.
  /// This flag tells ObjectBox to treat object IDs globally and thus no ID mapping (local <-> global) is performed.
  /// Often this is used with assignable IDs (ID_SELF_ASSIGNABLE property flag is set) and some special ID scheme.
  /// Note: typically you won't do this with automatically assigned IDs, set by the local ObjectBox store.
  /// Two devices would likely overwrite each other's object during sync as object IDs are prone to collide.
  /// It might be OK if you can somehow ensure that only a single device will create new IDs.
  static const int SHARED_GLOBAL_IDS = 4;
}

/// Bit-flags defining the behavior of properties.
/// Note: Numbers indicate the bit position
abstract class OBXPropertyFlags {
  /// 64 bit long property (internally unsigned) representing the ID of the entity.
  /// May be combined with: NON_PRIMITIVE_TYPE, ID_MONOTONIC_SEQUENCE, ID_SELF_ASSIGNABLE.
  static const int ID = 1;

  /// On languages like Java, a non-primitive type is used (aka wrapper types, allowing null)
  static const int NON_PRIMITIVE_TYPE = 2;

  /// Unused yet
  static const int NOT_NULL = 4;
  static const int INDEXED = 8;

  /// Unused yet
  static const int RESERVED = 16;

  /// Unique index
  static const int UNIQUE = 32;

  /// Unused yet: Use a persisted sequence to enforce ID to rise monotonic (no ID reuse)
  static const int ID_MONOTONIC_SEQUENCE = 64;

  /// Allow IDs to be assigned by the developer
  static const int ID_SELF_ASSIGNABLE = 128;

  /// Unused yet
  static const int INDEX_PARTIAL_SKIP_NULL = 256;

  /// Used by References for 1) back-references and 2) to clear references to deleted objects (required for ID reuse)
  static const int INDEX_PARTIAL_SKIP_ZERO = 512;

  /// Virtual properties may not have a dedicated field in their entity class, e.g. target IDs of to-one relations
  static const int VIRTUAL = 1024;

  /// Index uses a 32 bit hash instead of the value
  /// 32 bits is shorter on disk, runs well on 32 bit systems, and should be OK even with a few collisions
  static const int INDEX_HASH = 2048;

  /// Index uses a 64 bit hash instead of the value
  /// recommended mostly for 64 bit machines with values longer >200 bytes; small values are faster with a 32 bit hash
  static const int INDEX_HASH64 = 4096;

  /// The actual type of the variable is unsigned (used in combination with numeric OBXPropertyType_*).
  /// While our default are signed ints, queries & indexes need do know signing info.
  /// Note: Don't combine with ID (IDs are always unsigned internally).
  static const int UNSIGNED = 8192;

  /// By defining an ID companion property, a special ID encoding scheme is activated involving this property.
  ///
  /// For Time Series IDs, a companion property of type Date or DateNano represents the exact timestamp.
  static const int ID_COMPANION = 16384;

  /// Unique on-conflict strategy: the object being put replaces any existing conflicting object (deletes it).
  static const int UNIQUE_ON_CONFLICT_REPLACE = 32768;

  /// If a date property has this flag (max. one per entity type), the date value specifies the time by which
  /// the object expires, at which point it MAY be removed (deleted), which can be triggered by an API call.
  static const int EXPIRATION_TIME = 65536;
}

/// A property type of an external system (e.g. another database) that has no default mapping to an ObjectBox type.
/// External property types numeric values start at 100 to avoid overlaps with ObjectBox's PropertyType.
/// (And if we ever support one of these as a primary type, we could share the numeric value?)
abstract class OBXExternalPropertyType {
  /// Not a real type: represents uninitialized state and can be used for forward compatibility.
  static const int Unknown = 0;

  /// Representing type: ByteVector
  /// Encoding: 1:1 binary representation, little endian (16 bytes)
  static const int Int128 = 100;

  /// A UUID (Universally Unique Identifier) as defined by RFC 9562.
  /// ObjectBox uses the UUIDv7 scheme (timestamp + random) to create new UUIDs.
  /// UUIDv7 is a good choice for database keys as it's mostly sequential and encodes a timestamp.
  /// However, if keys are used externally, consider UuidV4 for better privacy by not exposing any time information.
  /// Representing type: ByteVector
  /// Encoding: 1:1 binary representation (16 bytes)
  static const int Uuid = 102;

  /// IEEE 754 decimal128 type, e.g. supported by MongoDB
  /// Representing type: ByteVector
  /// Encoding: 1:1 binary representation (16 bytes)
  static const int Decimal128 = 103;

  /// UUID represented as a string of 36 characters, e.g. "019571b4-80e3-7516-a5c1-5f1053d23fff".
  /// For efficient storage, consider the Uuid type instead, which occupies only 16 bytes (20 bytes less).
  /// This type may still be a convenient alternative as the string type is widely supported and more human-readable.
  /// In accordance to standards, new UUIDs generated by ObjectBox use lowercase hexadecimal digits.
  /// Representing type: String
  static const int UuidString = 104;

  /// A UUID (Universally Unique Identifier) as defined by RFC 9562.
  /// ObjectBox uses the UUIDv4 scheme (completely random) to create new UUIDs.
  /// Representing type: ByteVector
  /// Encoding: 1:1 binary representation (16 bytes)
  static const int UuidV4 = 105;

  /// Like UuidString, but using the UUIDv4 scheme (completely random) to create new UUID.
  /// Representing type: String
  static const int UuidV4String = 106;

  /// A key/value map; e.g. corresponds to a JSON object or a MongoDB document (although not keeping the key order).
  /// Unlike the Flex type, this must contain a map value (e.g. not a vector or a scalar).
  /// Representing type: Flex
  /// Encoding: Flex
  static const int FlexMap = 107;

  /// A vector (aka list or array) of flexible elements; e.g. corresponds to a JSON array or a MongoDB array.
  /// Unlike the Flex type, this must contain a vector value (e.g. not a map or a scalar).
  /// Representing type: Flex
  /// Encoding: Flex
  static const int FlexVector = 108;

  /// Placeholder (not yet used) for a JSON document.
  /// Representing type: String
  static const int Json = 109;

  /// Placeholder (not yet used) for a BSON document.
  /// Representing type: ByteVector
  static const int Bson = 110;

  /// JavaScript source code
  /// Representing type: String
  static const int JavaScript = 111;

  /// A JSON string that is converted to a native representation in the external system.
  /// For example, a JSON object on the ObjectBox side (string) would be converted to an embedded document in MongoDB.
  /// It depends on the external system what kind of JSON structures is supported.
  /// For MongoDB, this is very flexible and allows (nested) objects, arrays, primitives, etc.
  /// Representing type: String
  static const int JsonToNative = 112;

  /// A vector (array) of Int128 values
  static const int Int128Vector = 116;

  /// A vector (array) of Uuid values
  static const int UuidVector = 118;

  /// The 12-byte ObjectId type in MongoDB
  /// Representing type: ByteVector
  /// Encoding: 1:1 binary representation (12 bytes)
  static const int MongoId = 123;

  /// A vector (array) of MongoId values
  static const int MongoIdVector = 124;

  /// Representing type: Long
  /// Encoding: Two unsigned 32-bit integers merged into a 64-bit integer.
  static const int MongoTimestamp = 125;

  /// Representing type: ByteVector
  /// Encoding: 3 zero bytes (reserved, functions as padding), fourth byte is the sub-type,
  /// followed by the binary data.
  static const int MongoBinary = 126;

  /// Representing type: string vector with 2 elements (index 0: pattern, index 1: options)
  /// Encoding: 1:1 string representation
  static const int MongoRegex = 127;
}

class OBX_model extends ffi.Opaque {}

/// Schema entity & property identifiers
typedef obx_schema_id = ffi.Uint32;

/// Universal identifier used in schema for entities & properties
typedef obx_uid = ffi.Uint64;

class OBX_store extends ffi.Opaque {}

class OBX_store_options extends ffi.Opaque {}

/// Debug flags typically enable additional "debug logging" that can be helpful to better understand what is going on
/// internally. These are intended for the development process only; typically one does not enable them for releases.
abstract class OBXDebugFlags {
  static const int LOG_TRANSACTIONS_READ = 1;
  static const int LOG_TRANSACTIONS_WRITE = 2;
  static const int LOG_QUERIES = 4;
  static const int LOG_QUERY_PARAMETERS = 8;
  static const int LOG_ASYNC_QUEUE = 16;
  static const int LOG_CACHE_HITS = 32;
  static const int LOG_CACHE_ALL = 64;
  static const int LOG_TREE = 128;

  /// For a limited number of error conditions, this will try to print stack traces.
  /// Note: this is Linux-only, experimental, and has several limitations:
  /// The usefulness of these stack traces depends on several factors and might not be helpful at all.
  static const int LOG_EXCEPTION_STACK_TRACE = 256;

  /// Run a quick self-test to verify basic threading; somewhat paranoia to check the platform and the library setup.
  static const int RUN_THREADING_SELF_TEST = 512;
}

/// Flags used to control pages validation options when opening the store.
abstract class OBXValidateOnOpenPagesFlags {
  /// < No special flags
  static const int None = 0;

  /// Enable validation of leaf pages (by default only branch pages are validated)
  static const int VisitLeafPages = 1;
}

/// Flags used to control key/value pairs validation options when opening the store.
/// Note: this enum does not contain any actual values besides "None" yet; it's only used to future proof the API.
abstract class OBXValidateOnOpenKvFlags {
  /// < No special flags
  static const int None = 0;
}

/// Defines a padding mode for putting data bytes.
/// Depending on how that data is created, this mode may optimize data handling by avoiding copying memory.
/// Internal background: data buffers used by put operations are required to have a size divisible by 4 for an
/// efficient data layout.
abstract class OBXPutPaddingMode {
  /// Adds a padding when needed (may require a memory copy): this is the safe option and also the default.
  /// The extra memory copy may impact performance, however this is usually not noticeable.
  static const int PaddingAutomatic = 1;

  /// Indicates that data buffers are safe to be extended for padding (adding up to 3 bytes to size is OK).
  /// Typically, it depends on the used FlatBuffers builder; e.g. the official C++ seems to ensure it, but
  /// flatcc (3rd party implementation for plain C) may not.
  static const int PaddingAllowedByBuffer = 2;

  /// The caller ensures that all data bytes are already padded.
  /// ObjectBox will verify the buffer size and returns an error if it's not divisible by 4.
  static const int PaddingByCaller = 3;
}

/// Backup flags control how the store creates backup files.
/// E.g. when you want "deterministic" file content, you can exclude timestamp and salt.
abstract class OBXBackupFlags {
  /// Do not include a timestamp in the backup file (time when the backup file is generated).
  static const int ExcludeTimestamp = 1;

  /// Do not include a random salt in the backup file.
  static const int ExcludeSalt = 2;
}

/// WAL flags control how the store handles WAL files.
abstract class OBXWalFlags {
  /// Enable Wal
  static const int EnableWal = 1;

  /// Does not wait for the disk to acknowledge; faster but not ACID compliant (not generally recommended).
  static const int NoSyncFile = 2;
}

/// This bytes struct is an input/output wrapper used for a single data object (represented as FlatBuffers).
class OBX_bytes extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;
}

/// This bytes array struct is an input/output wrapper for multiple data objects (represented as FlatBuffers).
class OBX_bytes_array extends ffi.Struct {
  external ffi.Pointer<OBX_bytes> bytes;

  @ffi.Size()
  external int count;
}

/// This bytes score array struct is an input/output wrapper pointing to multiple OBX_bytes_score instances.
/// If count is zero, bytes_scores is allowed to be invalid.
class OBX_bytes_score_array extends ffi.Struct {
  external ffi.Pointer<OBX_bytes_score> bytes_scores;

  @ffi.Size()
  external int count;
}

class OBX_bytes_lazy extends ffi.Opaque {}

/// ID array struct is an input/output wrapper for an array of object IDs.
class OBX_id_array extends ffi.Struct {
  external ffi.Pointer<obx_id> ids;

  @ffi.Size()
  external int count;
}

/// ID score array struct is an input/output wrapper for an array of OBX_id_score structs.
/// If count is zero, bytes_scores is allowed to be invalid.
class OBX_id_score_array extends ffi.Struct {
  external ffi.Pointer<OBX_id_score> ids_scores;

  @ffi.Size()
  external int count;
}

/// String array struct is an input/output wrapper for an array of character strings.
class OBX_string_array extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Char>> items;

  @ffi.Size()
  external int count;
}

/// Int64 array struct is an input/output wrapper for an array of int64 numbers.
class OBX_int64_array extends ffi.Struct {
  external ffi.Pointer<ffi.Int64> items;

  @ffi.Size()
  external int count;
}

/// Int32 array struct is an input/output wrapper for an array of int32 numbers.
class OBX_int32_array extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> items;

  @ffi.Size()
  external int count;
}

/// Int16 array struct is an input/output wrapper for an array of int16 numbers.
class OBX_int16_array extends ffi.Struct {
  external ffi.Pointer<ffi.Int16> items;

  @ffi.Size()
  external int count;
}

/// Int8 array struct is an input/output wrapper for an array of int8 numbers.
class OBX_int8_array extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> items;

  @ffi.Size()
  external int count;
}

/// Double array struct is an input/output wrapper for an array of double precision floating point numbers.
class OBX_double_array extends ffi.Struct {
  external ffi.Pointer<ffi.Double> items;

  @ffi.Size()
  external int count;
}

/// Float array struct is an input/output wrapper for an array of single precision floating point numbers.
class OBX_float_array extends ffi.Struct {
  external ffi.Pointer<ffi.Float> items;

  @ffi.Size()
  external int count;
}

/// Callback for logging, which can be provided to store creation via options.
typedef obx_log_callback = ffi.NativeFunction<
    ffi.Void Function(ffi.Int32 log_level, ffi.Pointer<ffi.Char> message,
        ffi.Size message_size, ffi.Pointer<ffi.Void> user_data)>;

/// Backup restore flags control how backups are restored to the database.
abstract class OBXBackupRestoreFlags {
  /// Overwrite any existing database with the content of the backup file.
  static const int OverwriteExistingData = 1;
}

/// Store type to be registered with obx_store_type_id_register_default().
abstract class OBXStoreTypeId {
  /// Default store type: persistent data storage (based on LMDB)
  static const int LMDB = 1;

  /// Store type ID for in-memory database (non-persistent)
  static const int InMemory = 2;

  /// Store type ID for in-memory WAL-enabled (persistent)
  static const int InMemoryWal = 3;
}

class OBX_txn extends ffi.Opaque {}

class OBX_cursor extends ffi.Opaque {}

abstract class OBXPutMode {
  /// Standard put ("insert or update")
  static const int PUT = 1;

  /// Put succeeds only if the entity does not exist yet.
  static const int INSERT = 2;

  /// Put succeeds only if the entity already exist.
  static const int UPDATE = 3;
}

class OBX_box extends ffi.Opaque {}

/// The callback for reading data (i.e. object bytes) one-by-one.
/// @param data is the read data buffer
/// @param size specifies the length of the read data
/// @param user_data is a pass-through argument passed to the called API
/// @return The visitor returns true to keep going or false to cancel.
typedef obx_data_visitor = ffi.NativeFunction<
    ffi.Bool Function(ffi.Pointer<ffi.Uint8> data, ffi.Size size,
        ffi.Pointer<ffi.Void> user_data)>;

/// Callback for simple async functions that only deliver a obx_err status.
/// @param status The result status of the async operation
/// @param user_data The data initially passed to the async function call is passed back.
typedef obx_status_callback = ffi.NativeFunction<
    ffi.Void Function(obx_err status, ffi.Pointer<ffi.Void> user_data)>;

class OBX_async extends ffi.Opaque {}

class OBX_query_builder extends ffi.Opaque {}

/// Not really an enum, but binary flags to use across languages
abstract class OBXOrderFlags {
  /// Reverse the order from ascending (default) to descending.
  static const int DESCENDING = 1;

  /// Sort upper case letters (e.g. "Z") before lower case letters (e.g. "a").
  /// If not specified, the default is case insensitive for ASCII characters.
  static const int CASE_SENSITIVE = 2;

  /// For scalars only: change the comparison to unsigned (default is signed).
  static const int UNSIGNED = 4;

  /// null values will be put last.
  /// If not specified, by default null values will be put first.
  static const int NULLS_LAST = 8;

  /// null values should be treated equal to zero (scalars only).
  static const int NULLS_ZERO = 16;
}

/// Query Builder condition identifier
/// - returned by condition creating functions,
/// - used to combine conditions with any/all, thus building more complex conditions
typedef obx_qb_cond = ffi.Int;

class OBX_query extends ffi.Opaque {}

/// The callback for reading data (i.e. object bytes) with a search score one-by-one.
/// @param data contains the current data with score element
/// @param user_data is a pass-through argument passed to the called API
/// @return The visitor returns true to keep going or false to cancel.
typedef obx_data_score_visitor = ffi.NativeFunction<
    ffi.Bool Function(
        ffi.Pointer<OBX_bytes_score> data, ffi.Pointer<ffi.Void> user_data)>;

class OBX_query_prop extends ffi.Opaque {}

class OBX_observer extends ffi.Opaque {}

/// Callback for obx_observe()
/// @param user_data user data given to obx_observe()
/// @param type_ids array of object type IDs that had changes
/// @param type_ids_count number of IDs of type_ids
typedef obx_observer = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<obx_schema_id> type_ids,
        ffi.Size type_ids_count, ffi.Pointer<ffi.Void> user_data)>;

/// Callback for obx_observe_single_type()
typedef obx_observer_single_type
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> user_data)>;

abstract class OBXTreeOptionFlags {
  /// If true, debug logs are always disabled for this tree regardless of the store's debug flags.
  static const int DebugLogsDisable = 1;

  /// If true, debug logs are always enabled for this tree regardless of the store's debug flags.
  static const int DebugLogsEnable = 2;

  /// By default, a path such as "a/b/c" can address a branch and a leaf at the same time.
  /// E.g. under the common parent path "a/b", a branch "c" and a "c" leaf may exist.
  /// To disable this, set this flag to true.
  /// This will enable an additional check when inserting new leafs and new branches for the existence of the other.
  static const int EnforceUniquePath = 4;

  /// In some scenarios, e.g. when using Sync, multiple node objects of the same type (e.g. branch or leaf) at the
  /// same path may exist temporarily. By enabling this flag, this is not considered an error situation. Instead, the
  /// first node is picked.
  static const int AllowNonUniqueNodes = 8;

  /// Nodes described in AllowNonUniqueNodes will be automatically detected to consolidate them (manually).
  static const int DetectNonUniqueNodes = 16;

  /// Nodes described in AllowNonUniqueNodes will be automatically consolidated to make them unique.
  /// This consolidation happens e.g. on put/remove operations.
  /// Using this value implies DetectNonUniqueNodes.
  static const int AutoConsolidateNonUniqueNodes = 32;
}

class OBX_tree_options extends ffi.Opaque {}

class OBX_tree extends ffi.Opaque {}

class OBX_tree_cursor extends ffi.Opaque {}

class OBX_tree_leaves_info extends ffi.Opaque {}

/// Callback for obx_tree_async_get_raw().
/// \note If the given status is an error, you can use functions like obx_last_error_message() to gather more info
/// during this callback (error state is thread bound and the callback uses an internal thread).
/// @param status The result status of the async operation
/// @param id If the operation was successful, the ID of the leaf, which was get (otherwise zero).
/// @param path The leafs path as string.
/// @param leaf_data The leafs data flatbuffer pointer.
/// @param leaf_data_size The leafs data flatbuffer size.
/// @param leaf_metadata The leafs metadata flatbuffer pointer.
/// @param leaf_metadata_size The leafs meatdata flatbuffer size.
/// @param user_data The data initially passed to the async function call is passed back.
typedef obx_tree_async_get_callback = ffi.NativeFunction<
    ffi.Void Function(
        obx_err status,
        obx_id id,
        ffi.Pointer<ffi.Char> path,
        ffi.Pointer<ffi.Uint8> leaf_data,
        ffi.Size leaf_data_size,
        ffi.Pointer<ffi.Uint8> leaf_metadata,
        ffi.Size leaf_metadata_size,
        ffi.Pointer<ffi.Void> user_data)>;

/// Callback for obx_tree_async_put_raw().
/// \note If the given status is an error, you can use functions like obx_last_error_message() to gather more info
/// during this callback (error state is thread bound and the callback uses an internal thread).
/// @param status The result status of the async operation
/// @param id If the operation was successful, the ID of the leaf, which was put (otherwise zero).
/// @param user_data The data initially passed to the async function call is passed back.
typedef obx_tree_async_put_callback = ffi.NativeFunction<
    ffi.Void Function(
        obx_err status, obx_id id, ffi.Pointer<ffi.Void> user_data)>;

class OBX_weak_store extends ffi.Opaque {}

class OBX_admin_options extends ffi.Opaque {}

class OBX_admin extends ffi.Opaque {}

class OBX_sync extends ffi.Opaque {}

/// Specifies user-side credential types as well as server-side authenticator types.
/// Some credential types do not make sense as authenticators such as OBXSyncCredentialsType_USER_PASSWORD which
/// specifies a generic client-side credential type.
abstract class OBXSyncCredentialsType {
  static const int NONE = 1;

  /// < Deprecated, replaced by SHARED_SECRET_SIPPED
  static const int SHARED_SECRET = 2;
  static const int GOOGLE_AUTH = 3;

  /// < Uses shared secret to create a hashed credential.
  static const int SHARED_SECRET_SIPPED = 4;

  /// < ObjectBox admin users (username/password)
  static const int OBX_ADMIN_USER = 5;

  /// < Generic credential type suitable for ObjectBox admin
  /// < (and possibly others in the future)
  static const int USER_PASSWORD = 6;

  /// < JSON Web Token (JWT): an ID token that typically provides identity
  /// < information about the authenticated user.
  static const int JWT_ID = 7;

  /// < JSON Web Token (JWT): an access token that is used to access resources.
  static const int JWT_ACCESS = 8;

  /// < JSON Web Token (JWT): a refresh token that is used to obtain a new
  /// < access token.
  static const int JWT_REFRESH = 9;

  /// < JSON Web Token (JWT): a token that is neither an ID, access,
  /// < nor refresh token.
  static const int JWT_CUSTOM = 10;
}

abstract class OBXRequestUpdatesMode {
  /// no updates by default, obx_sync_updates_request() must be called manually
  static const int MANUAL = 0;

  /// same as calling obx_sync_updates_request(sync, TRUE)
  /// default mode unless overridden by obx_sync_request_updates_mode
  static const int AUTO = 1;

  /// same as calling obx_sync_updates_request(sync, FALSE)
  static const int AUTO_NO_PUSHES = 2;
}

abstract class OBXSyncState {
  static const int CREATED = 1;
  static const int STARTED = 2;
  static const int CONNECTED = 3;
  static const int LOGGED_IN = 4;
  static const int DISCONNECTED = 5;
  static const int STOPPED = 6;
  static const int DEAD = 7;
}

abstract class OBXSyncCode {
  static const int OK = 20;
  static const int REQ_REJECTED = 40;
  static const int CREDENTIALS_REJECTED = 43;
  static const int UNKNOWN = 50;
  static const int AUTH_UNREACHABLE = 53;
  static const int BAD_VERSION = 55;
  static const int CLIENT_ID_TAKEN = 61;
  static const int TX_VIOLATED_UNIQUE = 71;
}

/// Sync-level error reporting codes, passed via obx_sync_listener_error().
abstract class OBXSyncError {
  /// Sync client received rejection of transaction writes due to missing permissions.
  /// Until reconnecting with new credentials client will run in receive-only mode.
  static const int REJECT_TX_NO_PERMISSION = 1;
}

abstract class OBXSyncObjectType {
  static const int FlatBuffers = 1;
  static const int String = 2;
  static const int Raw = 3;
}

class OBX_sync_change extends ffi.Struct {
  @obx_schema_id()
  external int entity_id;

  external ffi.Pointer<OBX_id_array> puts;

  external ffi.Pointer<OBX_id_array> removals;
}

class OBX_sync_change_array extends ffi.Struct {
  external ffi.Pointer<OBX_sync_change> list;

  @ffi.Size()
  external int count;
}

/// A single data object contained in a OBX_sync_msg_objects message.
class OBX_sync_object extends ffi.Struct {
  @ffi.Int32()
  external int type;

  /// < optional value that the application can use identify the object (may be zero)
  @ffi.Uint64()
  external int id;

  /// < Pointer to object data, which is to be interpreted according to its type
  external ffi.Pointer<ffi.Uint8> data;

  /// < Size of the object data (including the trailing \0 in case of OBXSyncObjectType_String)
  @ffi.Size()
  external int size;
}

/// Incubating message that carries multiple data "objects" (e.g. FlatBuffers, strings, raw bytes).
/// Interpretation is up to the application. Does not involve any persistence or delivery guarantees at the moment.
class OBX_sync_msg_objects extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> topic;

  /// < topic is usually a string, but could also be binary (up to the application)
  @ffi.Size()
  external int topic_size;

  external ffi.Pointer<OBX_sync_object> objects;

  @ffi.Size()
  external int count;
}

/// An outgoing sync objects-message.
class OBX_sync_msg_objects_builder extends ffi.Opaque {}

/// Flags to adjust sync client behavior.
abstract class OBXSyncFlags {
  /// Enable (rather extensive) logging on how IDs are mapped (local <-> global)
  static const int DebugLogIdMapping = 1;

  /// If the client gets in a state that does not allow any further synchronization, this flag instructs Sync to
  /// keep local data nevertheless. While this preserves data, you need to resolve the situation manually.
  /// For example, you could backup the data and start with a fresh database.
  /// Note that the default behavior (this flag is not set) is to wipe existing data from all sync-enabled types and
  /// sync from scratch from the server.
  /// Client-only: setting this flag for Sync server has no effect.
  static const int KeepDataOnSyncError = 2;

  /// Logs sync filter variables used for each client, e.g. values provided by JWT or the client's login message.
  static const int DebugLogFilterVariables = 4;

  /// When set, remove operations will include the full object data in the TX log (REMOVE_OBJECT command).
  /// This allows sync filters to filter out remove operations based on the object content.
  /// Without this flag, remove operations only contain the object ID and cannot be filtered.
  /// Note: this increases the size of TX logs for remove operations.
  static const int RemoveWithObjectData = 8;

  /// Enables debug logging of TX log processing.
  /// For now, this only has an effect on SyncClients (Sync Server has extensive debug logs already).
  static const int DebugLogTxLogs = 16;

  // Note: manually added, 5.1.0 release objectbox-sync.h file is missing it
  /// Skips invalid (put object) operations in the TX log instead of failing.
  static const int SkipInvalidTxOps = 32;
}

class OBX_sync_options extends ffi.Opaque {}

/// Called when connection is established
/// @param arg is a pass-through argument passed to the called API
typedef OBX_sync_listener_connect
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg)>;

/// Called when connection is closed/lost
/// @param arg is a pass-through argument passed to the called API
typedef OBX_sync_listener_disconnect
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg)>;

/// Called on successful login
/// @param arg is a pass-through argument passed to the called API
typedef OBX_sync_listener_login
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg)>;

/// Called on a login failure
/// @param arg is a pass-through argument passed to the called API
/// @param code error code indicating why the login failed
typedef OBX_sync_listener_login_failure = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> arg, ffi.Int32 code)>;

/// Called when synchronization is complete
/// @param arg is a pass-through argument passed to the called API
typedef OBX_sync_listener_complete
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg)>;

/// Called with fine grained sync changes (IDs of put and removed entities)
/// @param arg is a pass-through argument passed to the called API
typedef OBX_sync_listener_change = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void> arg, ffi.Pointer<OBX_sync_change_array> changes)>;

/// Called when a server time information is received on the client.
/// @param arg is a pass-through argument passed to the called API
/// @param timestamp_ns is timestamp in nanoseconds since Unix epoch
typedef OBX_sync_listener_server_time = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> arg, ffi.Int64 timestamp_ns)>;
typedef OBX_sync_listener_msg_objects = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> arg,
        ffi.Pointer<OBX_sync_msg_objects> msg_objects)>;

/// Callend when sync-level errors occur
/// @param arg is a pass-through argument passed to the called API
/// @param error error code indicating sync-level error events
typedef OBX_sync_listener_error = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> arg, ffi.Int32 error)>;

/// Stats counter type IDs as passed to obx_sync_stats_u64().
abstract class OBXSyncStats {
  /// Total number of connects (u64)
  static const int connects = 1;

  /// Total number of succesful logins (u64)
  static const int logins = 2;

  /// Total number of messages received (u64)
  static const int messagesReceived = 3;

  /// Total number of messages sent (u64)
  static const int messagesSent = 4;

  /// Total number of errors during message sending (u64)
  static const int messageSendFailures = 5;

  /// Total number of bytes received via messages.
  /// Note: this is measured on the application level and thus may not match e.g. the network level. (u64)
  static const int messageBytesReceived = 6;

  /// Total number of bytes sent via messages.
  /// Note: this is measured on the application level and thus may not match e.g. the network level.
  /// E.g. messages may be still enqueued so at least the timing will differ. (u64)
  static const int messageBytesSent = 7;
}

class OBX_sync_server extends ffi.Opaque {}

/// Stats counter type IDs as passed to obx_sync_server_stats_u64() (for u64 values) and obx_sync_server_stats_f64()
/// (for double (f64) values).
abstract class OBXSyncServerStats {
  /// Total number of client connections established (u64)
  static const int connects = 1;

  /// Total number of messages received from clients (u64)
  static const int messagesReceived = 2;

  /// Total number of messages sent to clients (u64)
  static const int messagesSent = 3;

  /// Total number of bytes received from clients via messages. (u64)
  /// Note: this is measured on the application level and thus may not match e.g. the network level.
  static const int messageBytesReceived = 4;

  /// Total number of bytes sent to clients via messages. (u64)
  /// Note: this is measured on the application level and thus may not match e.g. the network level.
  /// E.g. messages may be still enqueued so at least the timing will differ.
  static const int messageBytesSent = 5;

  /// Full syncs performed (u64)
  static const int fullSyncs = 6;

  /// Processing was aborted due to clients disconnected (u64)
  static const int disconnectAborts = 7;

  /// Total number of client transactions applied (u64)
  static const int clientTxsApplied = 8;

  /// Total size in bytes of client transactions applied (u64)
  static const int clientTxBytesApplied = 9;

  /// Total size in number of operations of transactions applied (u64)
  static const int clientTxOpsApplied = 10;

  /// Total number of local (server initiated) transactions applied (u64)
  static const int localTxsApplied = 11;

  /// AsyncQ committed TXs (u64)
  static const int asyncDbCommits = 12;

  /// Total number of skipped transactions duplicates (have been already applied before) (u64)
  static const int skippedTxDups = 13;

  /// Total number of login successes (u64)
  static const int loginSuccesses = 14;

  /// Total number of login failures (u64)
  static const int loginFailures = 15;

  /// Total number of login failures due to bad user credentials (u64)
  static const int loginFailuresUserBadCredentials = 16;

  /// Total number of login failures due to authenticator not available (u64)
  static const int loginFailuresAuthUnavailable = 17;

  /// Total number of login failures due to user has no permissions (u64)
  static const int loginFailuresUserNoPermission = 18;

  /// Total number of errors during message sending (u64)
  static const int messageSendFailures = 19;

  /// Total number of protocol errors; e.g. offending clients (u64)
  static const int errorsProtocol = 20;

  /// Total number of errors in message handlers (u64)
  static const int errorsInHandlers = 21;

  /// Total number of times a client has been disconnected due to heart failure (u64)
  static const int heartbeatFailures = 22;

  /// Total number of received client heartbeats (u64)
  static const int heartbeatsReceived = 23;

  /// Total APPLY_TX messages HistoryPusher has sent out (u64)
  static const int historicUpdateTxsSent = 24;

  /// Total APPLY_TX messages newDataPusher has sent out (u64)
  static const int newUpdateTxsSent = 25;

  /// Total number of messages received from clients (u64)
  static const int forwardedMessagesReceived = 26;

  /// Total number of messages sent to clients (u64)
  static const int forwardedMessagesSent = 27;

  /// Total number of global-to-local cache hits (u64)
  static const int cacheGlobalToLocalHits = 28;

  /// Total number of global-to-local cache misses (u64)
  static const int cacheGlobalToLocalMisses = 29;

  /// Internal dev stat for ID Map caching  (u64)
  static const int cacheGlobalToLocalSize = 30;

  /// Internal dev stat for ID Map caching  (u64)
  static const int cachePeerToLocalHits = 31;

  /// Internal dev stat for ID Map caching  (u64)
  static const int cachePeerToLocalMisses = 32;

  /// Internal dev stat for ID Map caching  (u64)
  static const int cacheLocalToPeerHits = 33;

  /// Internal dev stat for ID Map caching  (u64)
  static const int cacheLocalToPeerMisses = 34;

  /// Internal dev stat for ID Map caching  (u64)
  static const int cachePeerSize = 35;

  /// Current cluster peer state (0 = unknown, 1 = leader, 2 = follower, 3 = candidate) (u64)
  static const int clusterPeerState = 36;

  /// Number of transactions between the current Tx and the oldest Tx currently ACKed on any client (current)
  /// (f64)
  static const int clientTxsBehind = 37;

  /// Number of transactions between the current Tx and the oldest Tx currently ACKed on any client (minimum)
  /// (u64)
  static const int clientTxsBehind_min = 38;

  /// Number of transactions between the current Tx and the oldest Tx currently ACKed on any client (maximum)
  /// (u64)
  static const int clientTxsBehind_max = 39;

  /// Number of connected clients (current) (f64)
  static const int connectedClients = 40;

  /// Number of connected clients (minimum) (u64)
  static const int connectedClients_min = 41;

  /// Number of connected clients (maximum) (u64)
  static const int connectedClients_max = 42;

  /// Length of the queue for regular Tasks (current) (f64)
  static const int queueLength = 43;

  /// Length of the queue for regular Tasks (minimum) (u64)
  static const int queueLength_min = 44;

  /// Length of the queue for regular Tasks (maximum) (u64)
  static const int queueLength_max = 45;

  /// Length of the async queue (current) (f64)
  static const int queueLengthAsync = 46;

  /// Length of the async queue (minimum) (u64)
  static const int queueLengthAsync_min = 47;

  /// Length of the async queue (maximum) (u64)
  static const int queueLengthAsync_max = 48;

  /// Sequence number of TX log history (current) (f64)
  static const int txHistorySequence = 49;

  /// Sequence number of TX log history (minimum) (u64)
  static const int txHistorySequence_min = 50;

  /// Sequence number of TX log history (maximum) (u64)
  static const int txHistorySequence_max = 51;
}

/// Struct of the custom server function callbacks. In order to implement the custom server, you must provide
/// custom methods for each of the members of this struct. This is then passed to obx_custom_msg_server_register()
/// to register the custom server.
class OBX_custom_msg_server_functions extends ffi.Struct {
  /// Must be initialized with sizeof(OBX_custom_msg_server_functions) to "version" the struct.
  /// This allows the library (whi) to detect older or newer versions and react properly.
  @ffi.Size()
  external int version;

  external ffi.Pointer<OBX_custom_msg_server_func_create> func_create;

  external ffi.Pointer<OBX_custom_msg_server_func_start> func_start;

  external ffi.Pointer<OBX_custom_msg_server_func_stop> func_stop;

  external ffi.Pointer<OBX_custom_msg_server_func_shutdown> func_shutdown;

  external ffi.Pointer<OBX_custom_msg_server_func_client_connection_send_async>
      func_conn_send_async;

  external ffi.Pointer<OBX_custom_msg_server_func_client_connection_close>
      func_conn_close;

  external ffi.Pointer<OBX_custom_msg_server_func_client_connection_shutdown>
      func_conn_shutdown;
}

/// Callback to create a custom messaging server.
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// @param server_id the ID that was assigned to the custom server instance
/// @param config_user_data user provided data set at registration of the server
/// @returns server user data, which will be passed on to the subsequent callbacks (OBX_custom_msg_server_func_*)
/// @returns null to indicate an error that the server could not be created
typedef OBX_custom_msg_server_func_create = ffi.NativeFunction<
    ffi.Pointer<ffi.Void> Function(
        ffi.Uint64 server_id,
        ffi.Pointer<ffi.Char> url,
        ffi.Pointer<ffi.Char> cert_path,
        ffi.Pointer<ffi.Void> config_user_data)>;

/// Callback to start a custom server.
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// @param server_user_data User supplied data returned by the function that created the server
/// @param out_port When starting, the custom server can optionally supply a port by writing to the given pointer.
/// The port value is arbitrary and, for now, is only used for debug logs.
/// @returns OBX_SUCCESS if the server was successfully started
/// @returns Any other fitting error code (OBX_ERROR_*) if the server could be started
typedef OBX_custom_msg_server_func_start = ffi.NativeFunction<
    obx_err Function(ffi.Pointer<ffi.Void> server_user_data,
        ffi.Pointer<ffi.Uint64> out_port)>;

/// Callback to stop and close the custom server (e.g. further messages delivery will be rejected).
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// This includes the store associated with the server; it gets closed and must not be used anymore after this call.
/// @param server_user_data User supplied data returned by the function that created the server
typedef OBX_custom_msg_server_func_stop = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> server_user_data)>;

/// Callback to shut the custom server down, freeing its resources (the custom server is not used after this point).
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// @param server_user_data User supplied data returned by the function that created the server
typedef OBX_custom_msg_server_func_shutdown = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> server_user_data)>;

/// Callback to enqueue a message for sending.
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// @param bytes lazy bytes storing the message
/// @param server_user_data User supplied data returned by the function that created the server
typedef OBX_custom_msg_server_func_client_connection_send_async
    = ffi.NativeFunction<
        ffi.Bool Function(
            ffi.Pointer<OBX_bytes_lazy> bytes,
            ffi.Pointer<ffi.Void> server_user_data,
            ffi.Pointer<ffi.Void> connection_user_data)>;

/// Callback to close the sync client connection to the custom server.
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// @param server_user_data User supplied data returned by the function that created the server
typedef OBX_custom_msg_server_func_client_connection_close = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> server_user_data,
        ffi.Pointer<ffi.Void> connection_user_data)>;

/// Callback to shutdown and free all resources associated with the sync client connection to the custom server.
/// Note that the custom server may already have been shutdown at this point (e.g. no server user data is supplied).
/// Must be provided to implement a custom server. See notes on OBX_custom_msg_server_functions for more details.
/// @param connection_user_data User supplied data returned by the function that created the server
typedef OBX_custom_msg_server_func_client_connection_shutdown
    = ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> connection_user_data)>;

/// Struct of the custom client function callbacks. In order to implement the custom client, you must provide
/// custom methods for each of the members of this struct. This is then passed to obx_custom_msg_client_register()
/// to register the custom client.
class OBX_custom_msg_client_functions extends ffi.Struct {
  /// Must be initialized with sizeof(OBX_custom_msg_client_functions) to "version" the struct.
  /// This allows the library to detect older or newer versions and react properly.
  @ffi.Size()
  external int version;

  external ffi.Pointer<OBX_custom_msg_client_func_create> func_create;

  external ffi.Pointer<OBX_custom_msg_client_func_start> func_start;

  external ffi.Pointer<OBX_custom_msg_client_func_connect> func_connect;

  external ffi.Pointer<OBX_custom_msg_client_func_disconnect> func_disconnect;

  external ffi.Pointer<OBX_custom_msg_client_func_stop> func_stop;

  external ffi.Pointer<OBX_custom_msg_client_func_join> func_join;

  external ffi.Pointer<OBX_custom_msg_client_func_shutdown> func_shutdown;

  external ffi.Pointer<OBX_custom_msg_client_func_send_async> func_send_async;

  external ffi.Pointer<OBX_custom_msg_client_func_clear_outgoing_messages>
      func_clear_outgoing_messages;
}

/// Callback to create a custom messaging client.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_id the ID that was assigned to the client instance
/// @param config_user_data user provided data set at registration of the client
/// @returns client user data, which will be passed on to the subsequent callbacks (OBX_custom_msg_client_func_*)
/// @returns null to indicate an error that the client could not be created
typedef OBX_custom_msg_client_func_create = ffi.NativeFunction<
    ffi.Pointer<ffi.Void> Function(
        ffi.Uint64 client_id,
        ffi.Pointer<ffi.Char> url,
        ffi.Pointer<ffi.Char> cert_path,
        ffi.Pointer<ffi.Void> config_user_data)>;

/// Callback to start the client.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
/// @returns OBX_SUCCESS if the client was successfully started
/// @returns Any other fitting error code (OBX_ERROR_*) if the client could be started
typedef OBX_custom_msg_client_func_start = ffi
    .NativeFunction<obx_err Function(ffi.Pointer<ffi.Void> client_user_data)>;

/// Callback that tells the client it shall start trying to connect.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_connect = ffi
    .NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> client_user_data)>;

/// Callback that tells the client it shall disconnect.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_disconnect = ffi.NativeFunction<
    ffi.Void Function(ffi.Bool clear_outgoing_messages,
        ffi.Pointer<ffi.Void> client_user_data)>;

/// Callback to stop and close the client (e.g. further messages delivery will be rejected).
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_stop = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> client_user_data)>;

/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_join = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> client_user_data)>;

/// Callback to shut the custom client down, freeing its resources.
/// The custom client is not used after this point.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_shutdown = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> client_user_data)>;

/// Callback to enqueue a message for sending.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param bytes lazy bytes storing the message
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_send_async = ffi.NativeFunction<
    ffi.Bool Function(ffi.Pointer<OBX_bytes_lazy> bytes,
        ffi.Pointer<ffi.Void> client_user_data)>;

/// Callback to clear all outgoing messages.
/// Must be provided to implement a custom client. See notes on OBX_custom_msg_client_functions for more details.
/// @param client_user_data user supplied data returned by the function that created the client
typedef OBX_custom_msg_client_func_clear_outgoing_messages = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> client_user_data)>;

/// States of custom msg client that must be forwarded to obx_custom_msg_client_set_state().
abstract class OBXCustomMsgClientState {
  static const int Connecting = 1;
  static const int Connected = 2;
  static const int Disconnected = 3;
}

class OBX_dart_sync_listener extends ffi.Opaque {}

class OBX_dart_stream extends ffi.Opaque {}

class OBX_dart_finalizer extends ffi.Opaque {}

/// A function to clean up native resources. Must be a c-function (non-throwing). The returned error is ignored.
/// e.g. obx_query_close(), obx_store_close(), ...
typedef obx_dart_closer
    = ffi.NativeFunction<obx_err Function(ffi.Pointer<ffi.Void> native_object)>;

const int OBX_VERSION_MAJOR = 5;

const int OBX_VERSION_MINOR = 1;

const int OBX_VERSION_PATCH = 0;

const int OBX_ID_NEW = -1;

const int OBX_SUCCESS = 0;

const int OBX_NOT_FOUND = 404;

const int OBX_NO_SUCCESS = 1001;

const int OBX_TIMEOUT = 1002;

const int OBX_ERROR_ILLEGAL_STATE = 10001;

const int OBX_ERROR_ILLEGAL_ARGUMENT = 10002;

const int OBX_ERROR_ALLOCATION = 10003;

const int OBX_ERROR_NUMERIC_OVERFLOW = 10004;

const int OBX_ERROR_FEATURE_NOT_AVAILABLE = 10005;

const int OBX_ERROR_SHUTTING_DOWN = 10006;

const int OBX_ERROR_IO = 10007;

const int OBX_ERROR_BACKUP_FILE_INVALID = 10008;

const int OBX_ERROR_NO_ERROR_INFO = 10097;

const int OBX_ERROR_GENERAL = 10098;

const int OBX_ERROR_UNKNOWN = 10099;

const int OBX_ERROR_DB_FULL = 10101;

const int OBX_ERROR_MAX_READERS_EXCEEDED = 10102;

const int OBX_ERROR_STORE_MUST_SHUTDOWN = 10103;

const int OBX_ERROR_MAX_DATA_SIZE_EXCEEDED = 10104;

const int OBX_ERROR_DB_GENERAL = 10198;

const int OBX_ERROR_STORAGE_GENERAL = 10199;

const int OBX_ERROR_UNIQUE_VIOLATED = 10201;

const int OBX_ERROR_NON_UNIQUE_RESULT = 10202;

const int OBX_ERROR_PROPERTY_TYPE_MISMATCH = 10203;

const int OBX_ERROR_ID_ALREADY_EXISTS = 10210;

const int OBX_ERROR_ID_NOT_FOUND = 10211;

const int OBX_ERROR_TIME_SERIES = 10212;

const int OBX_ERROR_CONSTRAINT_VIOLATED = 10299;

const int OBX_ERROR_STD_ILLEGAL_ARGUMENT = 10301;

const int OBX_ERROR_STD_OUT_OF_RANGE = 10302;

const int OBX_ERROR_STD_LENGTH = 10303;

const int OBX_ERROR_STD_BAD_ALLOC = 10304;

const int OBX_ERROR_STD_RANGE = 10305;

const int OBX_ERROR_STD_OVERFLOW = 10306;

const int OBX_ERROR_STD_OTHER = 10399;

const int OBX_ERROR_SCHEMA = 10501;

const int OBX_ERROR_FILE_CORRUPT = 10502;

const int OBX_ERROR_FILE_PAGES_CORRUPT = 10503;

const int OBX_ERROR_SCHEMA_OBJECT_NOT_FOUND = 10504;

const int OBX_ERROR_TREE_MODEL_INVALID = 10601;

const int OBX_ERROR_TREE_VALUE_TYPE_MISMATCH = 10602;

const int OBX_ERROR_TREE_PATH_NON_UNIQUE = 10603;

const int OBX_ERROR_TREE_PATH_ILLEGAL = 10604;

const int OBX_ERROR_TREE_OTHER = 10699;
